{"pages":[],"posts":[{"title":"BindingX","text":"基于weex / React Native的富交互解决方案。 官网:https://alibaba.github.io/bindingx/ 它提供了一种称之为表达式绑定(Expression Binding)的机制可以在 weex上让手势等复杂交互操作以60fps的帧率流畅执行，而不会导致卡顿，因而带来了更优秀的用户体验 。 简要介绍由于weex/RN框架底层使用的JS-NativeBridge具有天然的异步特性，这使得JS和Native之间的通信会有固定的性能损耗，因此在一些复杂的实时交互场景中(如手势)，JS代码很难以高帧率运行，这极大地限制了框架的能力。目前官方并没有很好的方式解决。 而我们通过探索，提出了一种全新的方式用来解决这个问题，方案称之为ExpressionBinding。它的核心思想是将”交互行为”以表达式的方式描述，并提前预置到Native从而避免Native与JS频繁通信。 示例展示下面展示了一部分使用bindingx的示例。您可以下载或者编译我们的playgroundapp来获取更多的示例。同时，您也可以在我们的在线playground上编写您自己的demo。 注意：Weex支持两种前端写法（rax和vue），链接是直接跳转到Playground。 React-Native由于目前Playground还不支持，所以直接跳转到源码。 特性复杂但流畅的交互效果 强大的表达式解析引擎 丰富的缓动函数 文档与教程https://alibaba.github.io/bindingx/guide/introduce","link":"/blog/2019/05/25/React-Native/BindingX/"},{"title":"React-Native-DeviceEventEmitter","text":"实现DeviceEventEmitter在RN内的发送和接受消息。例如： A页面注册通知： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import {DeviceEventEmitter} from&apos;react-native&apos;; //… //调用事件通知 DeviceEventEmitter.emit(&apos;xxxName’,param); //xxxName:通知的名称 param：发送的消息（传参）B页面接收通知： componentDidMount(){ varself =this; this.listener =DeviceEventEmitter.addListener(&apos;xxxName&apos;,function(param){ // use param do something }); } //xxxName:通知的名称 param:接收到的消息（传参） componentWillUnmount(){ this.listener.remove(); } //在componentWillUnmount 内需要我们手动移除通知 知道DeviceEventEmitter的简单使用后 我的页面在获取到用户数据后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//注册监听事件，时间名称：changeMine 传参：jsonData.avatar（头像url） DeviceEventEmitter.emit(&apos;changeMine&apos;,jsonData.avatar);tabbar.js 文件: componentDidMount(){ varself =this; this.listener = DeviceEventEmitter.addListener(&apos;changeMine&apos;,function(url){ self.setState({ avatar:url }) }); //通知开始，获取到url，调用setState 方法，刷新状态机，这时候实时的刷新了‘我的’图标 //最后别忘了移除通知 componentWillUnmount(){ this.listener.remove(); } js 向 js 发送数据DeviceEventEmitter.emit('自定义名称',发送数据); 例：边看边买退出登录之后，我的淘宝和详情页的钱包数据应该改变。这时，我们可以在退出登录请求返回退出登录成功时发送一个通知 1234567891011121314151617181920212223242526272829303132333435363738userInfo.userLogout((success) = { if (success) {DeviceEventEmitter.emit(&apos;taobaoBind&apos;,{taobaoBind:false,walletSum:0.00,couponNum:0}); const nav = this.props.navigator; const routers = nav.getCurrentRoutes(); if (routers.length 1) { nav.pop(); } } }); 然后在我的淘宝和详情页接收通知，并使用setState改变数据 DeviceEventEmitter.addListener('taobaoBind',(events) ={this.setState({walletSum : events.walletSum});}); js接受数据 DeviceEventEmitter.addListener('名称',(events) ={使用数据events}); android向js发送数据 12345678WritableMap params = Arguments.createMap(); params.putString(&quot;message&quot;,msg.obj.toString());reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(eventName, params); 例：扫码轮询时，扫码成功可以向扫码页发送一个扫码成功的状态，输入密码完成时，也可以发送一个状态，使扫码页自动关闭。并将用户信息发给我的淘宝，详情页等。","link":"/blog/2019/05/25/React-Native/React-Native-DeviceEventEmitter/"},{"title":"React-Native-VSCode插件","text":"","link":"/blog/2019/05/25/React-Native/React-Native-VSCode插件/"},{"title":"React-Native-bundle拆分与合并之安卓篇","text":"在网上看到携程之前拆分的一些经验 先来说一组数据，一个Helloorld的App，如果使用0.30 RN 官方命令react-nativebundle打包出来的JSBundle文件大小大约为531KB，RN框架JavaScript本身占了530KB， zip压缩之后也有148KB。 如果只有一两个业务使用，这点大小算不了什么，但是对于我们这种动辄几十个业务的场景，如果每个业务的JSBundle都需要这么大的一个RN框架本身，那将是不可接受的。 因此，我们需要对RN官方的打包脚本做改造，将框架代码拆分出来，让所有业务使用一份框架代码。 开始拆分之前, 我们先以HelloWorld的RNApp为基础介绍几个背景知识。 上述是一个HelloWorld RNApp代码的结构，基本分为3部分 头部：各依赖模块引用部分； 中间：入口模块和各业务模块定义部分； 尾部：入口模块注册部分； 上述是HelloWorld RNApp打包之后JSBundle文件的结构，基本分为3部分头部：全局定义，主要是define，require等全局模块的定义； 中间：模块定义，RN框架和业务的各个模块定义； 尾部：引擎初始化和入口函数执行； d是RN自定义的define，符合CommonJS规范，d后面的数字是模块的id，是在RN打包过程中，解析依赖关系，自增长生成的。 如果所有业务代码，都遵照一个规则：入口JS文件首先require的都是react/react-native, 则打包生成的JSBundle里面react/react-native相关的模块id都是固定的。 拆分方案一 基于上面2点背景知识介绍，我们很容易发现，如果将打包之后的JSBundle文件，拆分成2部分(框架部分+业务模块部分)，使用的时候合并起来，然后去加载，即可实现拆分功能。 具体实现步骤： 创建一个空工程，入口文件只需要2行代码，require react/react-native即可； 使用react-native bundle命令，打包该入口文件，生成common.js; 使用react-native bundle打包业务工程(有一点要保证，业务工程入口文件前面2行代码也是require react/react-native), 生成business_all.js； 开发工具，从business_all.js里面删除common.js的内容，剩下的就是business.js; App加载的时候将common.js和business.js合并在一起，然后加载； 貌似功能完成，可是回到Dive into React Native performance，这么做还是优化不了JSBundle的执行时间，因为我们不能把拆分开的2个文件分别执行，因为加载common.js会提示找不到RNApp的入口，先执行business.js,会提示一堆依赖的RN模块找不到。 显然，这种拆分方式不能满足我们这种需要。 那这个方案就完全没有价值吗？不是的，如果你做的是一个纯RNApp，native只是一个壳，里面业务全是RN开发的，完全可以使用这种方式做拆分，这种方案简单，无侵入，实现成本低，不需要修改任何RN打包代码和RNRuntime代码。 拆分方案二 RN框架部分文件(common.js)大小530KB，如此大的js文件，占用了绝大部分的JS执行时间，这块时间如果能放到后台预先做完，进入业务也只需执行业务页面的几个JS文件，将可以大大提升页面加载速度，参考上面的RN性能瓶颈图，预估可以提升100%。 按照这个思路，能后台加载的JS文件, 实际上是就是一个RNApp，因此我们设计了一个空白页面的FakeApp，这个FakeApp做一件事情，就是监听要显示的真实的业务JS模块，收到监听之后，渲染业务模块，显示页面。 FakeApp设计如下： 为了实现该拆包方案，需要改造react-native的打包命令； 基于FakeApp打common.js包的时候， 需要记录RN各个模块名和模块id之间的mapping关系； 打业务模块包的时候，判断，如果已经在mapping文件里面的模块，不要打包到业务包中 改造页面加载流程： 因为要能够后台加载，所以需分离UI和JS加载引擎&lt;iOS-RCTBridge, Android-ReactInstanceManager; 进入业务RN页面时候，获取预加载好的JS引擎，然后发送消息给FakeApp，告知该渲染的业务JS模块； 通过后台预加载，省去了绝大部分的JS加载时间，似乎问题已经完美解决。 但是，如果随着业务不断膨胀，一个RN业务JS代码也达到500KB，进入这个业务页面，500多KB JS文件读取出来，执行，整个JS执行的时间瓶颈会再次出现。 拆分方案三 正在此时，我们研究RN在Facebook App里面的使用情况，发现了Unbundle，简单点说，就是将所有的JS模块都拆分成独立的文件。 下面截图就是unbundle打包的文件格式： entry.js就是global部分定义+RNApp入口； UNBUNDLE文件是用于标识这是一个unbundle包的flag； 12.js,13.js就是各个模块，文件名就是模块id； 在业务执行，需要加载模块(require)的时候，就去磁盘查找该文件，读取、执行。 RN里面加载模块流程说明,以require(66666)模块为例： 首先从__d&lt;就是前文提到的define的缓存列表里面查找是否有定义过模块66666，如果有，直接返回，如果没有走到下面第二步的nativeRequire； nativeRequire根据模块id，查找文件所在路径，读取文件内容； 定义模块，_d(66666)＝eval(JS文件内容)，会将这个模块ID和JS代码执行结果记录在define的缓存列表里面； 打包通过react-native unbundle 命令，可以给android平台打出这样的unbundle包。 顺便提一下，这个unbundle方案，只在android上有效，打ios平台的unbundle包，是打不出来的，在RN的打包脚本上有一行注释，大致意思是在iOS上众多小文件读取，文件IO效率不够高，android上没这样的问题，然后判断如果是打iOS的unbundle包的时候，直接return了。 相对应的，iOS开发了一个prepack的打包模式，简单点说，就是把所有的JS模块打包到一个文件里面，打包成一个二进制文件，并固定0xFB0BD1E5为文件开始，这个二进制文件里面有个meta-table，记录各个模块在文件中的相对位置，在加载模块(require)的时候，通过fseek，找到相应的文件开始，读取，执行。 在Unbundle的启发下，我们修改打包工具，开发了CRNUnbunle，做了简单的优化，把众多零散的JS文件做了简单的合并。 将common部分的JS文件，合并成一个common_ios(android).js. _crn_config记录了这个RNApp的入口模块ID以及其他配置信息，详见下图： main_module为当前业务模块入口模块ID； module_path为业务模块JS文件所在当前包的相对路径； 666666=0.js,说明666666这个模块在0.js文件里面； 做完这个拆包和加载优化之后，我们用自己的几个业务做了下测试，下图是当时的测试验证数据。 可以看出，iOS和android基本都比官方打包方式的加载时间，减少了50%。 这是自己单机测试的数据，那上线之后，数据如何呢？ 下图，是我们分析一天的数据，得出的平均值&lt;排除掉了5s以上的异常数据，后面实测下来5s以上数据极少； 看到这个数据，发现和我们自己测试的基本一致，但是还有一个疑问，加载的时间分布，是否服从正态分布，会不会很离散，快的设备很快，慢的设备很慢呢？ 然后我又进一步分析这一天的数据，按照页面加载时间区间分布统计。 看图上数据，很明显，iOS&amp;Android基本一致，将近98%的用户都能在1s内加载完成页面，符合我们期望的正态分布，所以bundle拆分到此基本完成。 实践我先用bundle打包命令打一个bundle出来 react-nativebundle –platform android –devfalse–entry-file index.android.js–bundle-output finalbundle/index.android.bundle –assets-dest finalbundle/ 只有一个简单的3k左右的index.android.js,打出了一个五百多k的index.android.bundle，看看里面是些什么 密密麻麻但又有规则 !function打头的是公共的头部部分 _d(function是JS文件，用ctrl+s搜索welcome，找到我们的index.android.js,原来是在第一行的_d(function,而且结尾有个参数0，其余部分其实都是公共的js ;require(120)，是基础文件的配置入口，require（0）则是业务的入口 基于以上，能想到一个办法： 内置一个common.js文件，里面包含了bundle文件公共部分的代码， 业务代码单独生成一个js文件 在需要展示加载某一个页面的时，将common.js和当前页面需要加载的业务js合并，然后再加载 这个办法解决了一部分问题，但加载时还是一个整体。如果common部分能重用，就能大大提升效率。所以就来试试上面提到的unbundle命令 react-nativeunbundle –platform android –devfalse–entry-fileindex.android.js –bundle-output build/index.android.bundle 生成的bundle只有14行了 但多了一个js-modules文件夹，里面的xx.js里面的内容就是将之前的__d(xx)抽出来单独放到一个文件里面，通过require(xx)加载到内存供调用 基于unbundle命令再设计一个上面提到的fake页面用来加载相应的业务模块，这个页面可以预先在后台初始化js引擎，将公共部分的common.js文件读取到内存，然后设置一个监听事件，通过emmit方式，当需要加载某个页面的的module的时候讲这个页面的module的id传递过来，然后通过require方法调用这个模块。 思路差不多是这样了，来试试看实现起来有没什么坑。 首先我拿例子跑了一下，瞬间明白了流程是怎么回事，有几个关键： DeviceEventEmitter 前端发起监听，后端需要用的时候调用emit触发，通过返回模块id,然后returnReact.createElement(返回的模块ID,this.props)即可定制加载 配置文件 这个配置文件之前不是很理解为什么好多等于0.js、等于1.js,现在明白其实就是不同bu的入口JS,因为都是单页路由的形式，不过这个配置其实是一套打包的一个流程，不在这里做，以后研究打包工具的时候加上。 然后 我试着把这样融入到之前的demo里。 先建两个test页面，用于测试切换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101importReact, { Component }from&apos;react&apos;; import{ AppRegistry, StyleSheet, Text, View, }from&apos;react-native&apos;; classtesteightextendsComponent{ render() { return( &lt;Viewstyle={styles.container} &lt;Textstyle={styles.welcome} Welcome to Test 8888 &lt;/Text &lt;/View ); } } conststyles = StyleSheet.create({ welcome: { fontSize:20, textAlign:&apos;center&apos;, margin:10, } }); module.exports = testeight; 然后在index.android.js加入切换按钮 /**123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397* Sample React Native App* https://github.com/facebook/react-native* @flow*/importReact, { Component }from&apos;react&apos;;import{AppRegistry,StyleSheet,Text,View,Image,NativeModules,DeviceEventEmitter,}from&apos;react-native&apos;;exportdefaultclassAwesomeProjectextendsComponent{constructor(props){super(props);this.state = {content:null,showModule:false};DeviceEventEmitter.addListener(&quot;test&quot;, (result) = {letmainComponent =require(result.name);this.setState({content:mainComponent,showModule:true})});}render() {let_content =null;if(this.state.content){_content = React.createElement(this.state.content,this.props);return_content;}else{return(&lt;Viewstyle={styles.container}&gt;&lt;Textstyle={styles.welcome}&gt;Welcome to React Native!&lt;/Text&gt;&lt;Textstyle={styles.instructions}&gt;To get started, edit index.android.js&lt;/Text&gt;&lt;Textstyle={styles.instructions}&gt;Double tap R on your keyboard to reload,{&apos;\\n&apos;}Shake or press menu button for dev menu&lt;/Text&gt;&lt;Textstyle={styles.instructions}onPress={()=this.showToast()}&gt;点我调用原生&lt;/Text&gt;&lt;Textstyle={styles.instructions}onPress={()=this.updateBundle()}&gt;点我更新bundle&lt;/Text&gt;&lt;Textstyle={styles.instructions}onPress={()=this.goNine()}&gt;点我加载页面9999&lt;/Text&gt;&lt;Textstyle={styles.instructions}onPress={()=this.goEight()}&gt;点我加载页面8888&lt;/Text&gt;&lt;Image&gt;source={require(&apos;./img/music_play.png&apos;)}style={{width:92,height:92}}/&lt;/View&gt;);}}updateBundle () {NativeModules.updateBundle.check(&quot;5.0.0&quot;);}showToast () {//调用原生NativeModules.RNToastAndroid.show(&apos;from native&apos;,100);}goNine () {NativeModules.BundleLoad.goPage(9999);}goEight () {NativeModules.BundleLoad.goPage(8888);}}const styles = StyleSheet.create({container: {flex: 1,justifyContent: &apos;center&apos;,alignItems: &apos;center&apos;,backgroundColor: &apos;#F5FCFF&apos;,},welcome: {fontSize: 20,textAlign: &apos;center&apos;,margin: 10,},instructions: {textAlign: &apos;center&apos;,color: &apos;#333333&apos;,marginBottom: 5,},});AppRegistry.registerComponent(&apos;rnandnative&apos;, () = AwesomeProject); 然后把index.android和两个test页面都用unbundle打包 123456789101112react-nativeunbundle --platform android --devfalse--entry-fileindex.android.js --bundle-output unbundle/index.android.bundle react-nativeunbundle --platform android --devfalse--entry-filebundletest1.js --bundle-output unbundle/index.android.bundle1 react-nativeunbundle --platform android --devfalse--entry-filebundletest2.js --bundle-output unbundle/index.android.bundle2 然后把index.android.bundle1、index.android.bundle2中除了_d的那句打头的去掉,把__d(0的0改为9999、8888，把文件名改为9999.js和8888.js丢到js-modules里，这个讲的估计不是很明白，但去看看代码就懂了。 然后建一个触发emit的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class RNBundleLoadModule extends ReactContextBaseJavaModule{ private ReactApplicationContext reactApplicationContext; public RNBundleLoadModule(ReactApplicationContext reactApplicationContext){ super(reactApplicationContext); } @Override public String getName(){ return &quot;BundleLoad&quot;; } @ReactMethod public void goPage(final Integer pageid){ System.out.print(&quot;########&quot;+pageid+&quot;########&quot;); // failedCallback.invoke(); WritableMap params = Arguments.createMap(); params.putInt(&quot;name&quot;, pageid); reactApplicationContext .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class) .emit(&quot;test&quot;, params); } } 跑起来，一切OK。 参考 https://github.com/pukaicom/reactNativeBundleBreak","link":"/blog/2019/05/25/React-Native/React-Native-bundle拆分与合并之安卓篇/"},{"title":"React-Native-WebStorm代码模版","text":"在React-Native日常开发中，新建文件或者组件是最常用的操作。可是，在我们新建不同的文件或者组件时，一些代码固定不变，此时，需要重新写一遍就费事费力了，而最常用的操作就是复制，粘贴，修改，重复而无趣。若是不想重复如此无聊的机械动作，又想快速高效的来完成任务，编写代码，那怎么办呢？此时，解决方案出现了。–Fileand Code Templates 使用此配置，可减省重复无用的劳动力，真正提升效率。 如果你觉得有用，请点个赞，或者分享给其他朋友。 一：配置有两种方式(以mac配置为例)： 一： 1-： 选择Preferences; 2-：搜索框输入Templates; 3-：点击File and Code Templates 4-：选中JavaScript File 5-：删除里面的代码，把以下代码复制进去(此代码可以自定义)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React, { Component } from &apos;react&apos;; import { StyleSheet, Text, View, Image, } from &apos;react-native&apos;; export default class ${NAME} extends Component { render() { return ( &lt;View style={styles.container}&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { flex: 1, }, }); 6-：点击Apply 示例图如下： 二： 1-： 选择Preferences; 2-：搜索框输入Templates; 3-：点击File and Code Templates 4-：点击左上角“+”号按钮 示例图如下： 注意点： 1-：注意新建文件的名字，本例子中取名为:React-Native; 2-：注意Extension的输入框填写为js; 三：使用方式： 分为两种，与上面配置方式一一对应： 一： 1-：点击New ，选择Java Script File； 2-：输入新建文件的名字，并点击OK； 3-：查看新建文件内容为填写的模版内容 二： 1-：点击New ，选择React-Native文件类型(与使用第二中配置方式时新建的名字一一对应)； 2-：输入新建文件的名字，并点击OK； 3-：查看新建文件内容为填写的模版内容 四：使用效果截图：","link":"/blog/2019/05/25/React-Native/React-Native-WebStorm代码模版/"},{"title":"React-Native国际化多语言","text":"库属性介绍项目地址：&lt;https://github.com/AlexanderZaytsev/react-native-i18n 属性 解释 支持RN版本 所有版本 支持平台 iOS+Android 是否需要NativeModule 是 是否可移植 是 是否含有jni模块 否 使用1.install（略，git里都写着了，就是npm那些事） 2.项目中使用 因为是一些静态属性引用，所以你用redux做储存替换也可以，直接做饮用也可以(本文拿en,zh为例)。 首先是建英文版本的配置文件，en/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798exportdefault{ home:{ greeting:&apos;Greeting in en&apos;, tab_home:&apos;Home&apos;, tab_donate:&apos;Donate&apos;, tab_demo:&apos;Demo&apos;, language:&apos;language&apos;, live_demo:&apos;Live Demo&apos;, buy_me_coffee:&apos;Buy me a coffee&apos;, gitee:&apos;Gitee&apos;, star_me:&apos;Star me&apos;, donate:&apos;donate&apos;, exit:&apos;exit?&apos;, }, donate:{ donate:&apos;donate us~~~&apos;, donate_desc:&apos;© 2017 Pactera Technology International Limited. All rightsreserved.&apos;, }, demo:{ dialog:&apos;dialog&apos;, button:&apos;button&apos;, switch:&apos;switch&apos;, action_sheet:&apos;Action Sheet&apos;, } }; 然后是中文的zh/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 exportdefault{ home:{ greeting:&apos;Greeting in zh&apos;, tab_home:&apos;首页&apos;, tab_donate:&apos;捐赠&apos;, tab_demo:&apos;例子&apos;, language:&apos;语言&apos;, live_demo:&apos;例子&apos;, buy_me_coffee:&apos;请我一杯coffee&apos;, gitee:&apos;Gitee&apos;, star_me:&apos;关注我&apos;, donate:&apos;贡献&apos;, exit:&apos;是否退出?&apos;, }, donate:{ donate:&apos;支持我们～~&apos;, donate_desc:&apos;© 2017 Pactera Technology International Limited. All rightsreserved.&apos;, }, demo:{ dialog:&apos;提示框&apos;, button:&apos;按钮&apos;, switch:&apos;开关&apos;, action_sheet:&apos;&apos;, } }; 属性名，结构是一致的只是属性不同，当然这里是静态的2个文件，如果场景需要可以服务端下发json,那就是完全动态的了，这部分看业务需求了。 默认的语言环境我们在上面写了2种语言配置，那么哪种作为初始化的呢？在业务层调用前，我们可以先进行预设 i18n/index.js 12345678910111213141516171819202122232425262728293031323334353637import i18nfrom&apos;react-native-i18n&apos;; import enfrom&apos;./en&apos;; import zhfrom&apos;./zh&apos;; i18n.defaultLocale =&apos;en&apos;; i18n.fallbacks = true; i18n.translations = { en, zh, }; export {i18n}; 这边进行了一些预设，默认语境为en，允许fallbacks状态（为true时，顺序向下遍历翻译），预设转换的文件就2个，一个en一个zh，这个你也可以自行后续添加根据需求而定。 业务层调用先是倒包 import {i18n} from ‘你预设的index的目录’; 调用(拿一个Toast做个例子) ToastAndroid.show(i18n.t(‘home.exit’),ToastAndroid.SHORT); 源码分析这个库的实现分为2部分，一部分是Native的版本判断等功能以及js部分的核心实现fnando/i18n-js i18n-js是一个轻量级的js翻译库，他支持各种格式和内容的换算和语言内容的切换，地址如下：&lt;https://github.com/fnando/i18n-js 那么翻译转换这块是 I18n.js做的那么Native做了些啥呢？我们来一探究竟(以安卓为例，苹果看不懂，抱歉) Native代码就两个类，所以我之前说你直接把Native代码copy走然后项目依赖I18n.js也能达到这个效果 RNI18nPackage是一个普通的Package类，它的作用就是把我们的module加到主应用的getPackages()方法中的列表里，然后一起打进包里而已。 具体功能都在RNI18nModule里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213publicclassRNI18nModuleextendsReactContextBaseJavaModule{ publicRNI18nModule(ReactApplicationContext reactContext) { super(reactContext); } //RN调用的控件名 @Override publicStringgetName() { return&quot;RNI18n&quot;; } //对取出的Locale列表进行格式化的方法 privateStringtoLanguageTag(Locale locale) { if(Build.VERSION.SDK_INT = Build.VERSION_CODES.LOLLIPOP) { returnlocale.toLanguageTag(); } StringBuilder builder =newStringBuilder(); builder.append(locale.getLanguage()); if(locale.getCountry() !=null) { builder.append(&quot;-&quot;); builder.append(locale.getCountry()); } returnbuilder.toString(); } privateWritableArraygetLocaleList() { WritableArray array = Arguments.createArray(); if(Build.VERSION.SDK_INT = Build.VERSION_CODES.N) { //获取区域设置列表。这是获取区域的首选方法。 LocaleList locales = getReactApplicationContext() .getResources().getConfiguration().getLocales(); for(inti =0; i &lt; locales.size(); i++) { array.pushString(this.toLanguageTag(locales.get(i))); } }else{ array.pushString(this.toLanguageTag(getReactApplicationContext() .getResources().getConfiguration().locale)); } returnarray; } //js端可获取属性的列表 @Override publicMap&lt;String, ObjectgetConstants() { HashMap&lt;String, Object constants =newHashMap&lt;String,Object(); constants.put(&quot;languages&quot;,this.getLocaleList()); returnconstants; } //提供给js端调用的方法，用来获取默认的语言环境，回调方式用的是promise @ReactMethod publicvoidgetLanguages(Promise promise) { try{ promise.resolve(this.getLocaleList()); }catch(Exception e) { promise.reject(e); } } } 加一个toast看下locale会出现什么 Toast.makeText(getReactApplicationContext(),”locales.get(i)“+locales.get(i),Toast.LENGTH_LONG).show(); 本想一探究竟内部的实现，结果是个不公开的类 总结首先Native那里获取本手机的LocaleList然后格式化取第一个元素交由I18n.js处理，然后I18n.js根据key选用一套有效的语言规则，再之后流程就和使用时候的顺序一样了。 整个库集成难度较低，使用起来比较简便，使用下来没碰到大坑，配合redux更美味。 准备阶段[react-native-i18n](https://github.com/AlexanderZaytsev/react-native-i18n)第三方多语言库 安装:yarn add react-native-i18n [react-native-device-info](https://www.jianshu.com/p/%5Bhttps://github.com/rebeccahughes/react-native-device-info%5D(https://github.com/rebeccahughes/react-native-device-info))用户获取系统本地语言环境 安装:yarn add react-native-device-infoandreact-native link react-native-device-info 实践阶段： 在项目中创建zh.js、en.js、I18n.js三个js文件，DataRepository.js是一个我自定义的数据持久化类，在这个demo中的作用是存取用户改变后的语言环境，直接拷贝过去就可以用(不是必须的)。 代码分别为： zh.js 12345678910111213141516171819202122232425exportdefault{ english:&apos;英文&apos;, chinese:&apos;中文&apos;, changeToEnglish:&apos;切换到英文&apos;, changeToChinese:&apos;切换到中文&apos;, changeToSystem:&apos;切换到系统语言&apos;, } en.js 12345678910111213141516171819202122232425exportdefault{ english:&apos;english&apos;, chinese:&apos;chinese&apos;, changeToEnglish:&apos;change to english&apos;, changeToChinese:&apos;change to chinese&apos;, changeToSystem:&apos;change to System&apos;, } I18n.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485importI18n,{ getLanguages }from&apos;react-native-i18n&apos; importDeviceInfofrom&apos;react-native-device-info&apos; importDataRepositoryfrom&apos;../dao/DataRepository&apos; importenfrom&apos;./en&apos; importzhfrom&apos;./zh&apos; I18n.defaultLocale =&apos;en&apos;; I18n.fallbacks =true; I18n.translations = { en, zh, }; I18n.localeLanguage =()={ newDataRepository().fetchLocalRepository(&apos;localLanguage&apos;) .then((res)={ I18n.locale = res; }) .catch((error)={ I18n.locale = DeviceInfo.getDeviceLocale(); }); returnI18n.locale; }; export{ I18n, getLanguages }; 重点方法、属性讲解 I18n.t(): 使用频率是最高的，举个栗子： &lt;Textstyle={styles.welcome} {I18n.t(‘english’)} &lt;/Text 以上I18n.t(‘english’)中的english参数就是在zh.js、en.js文件中的语言配置项 具体显示内容会随着语言环境调用相应的语言配置文件，呈现给用户相应的语言内容。 I18n.getLanguages获取用户首选的语言环境 I18n.locale: 设置本地语言环境。 I18n.defaultLocale首选默认语言 I18n.fallbacks: 看文档说明我理解的意思是：如果获取到的系统语言类似en_USen-GB这样的，插件初始化的时候发现没有en_US.jsen-GB.js，这个时候如果设置了I18n.fallbacks =true;系统就会按这样的（en_USen.js）顺序去查找文件，就会去找有一个en.js这样的文件， 官方建议使用I18n.fallbacks =true; 更多关于i18n-js的属性和方法请点击这里查看 ios需要配置语言环境 使用过程中发现一个刷新的问题： 我在使用过程中发现调用了I18n.locale=‘我设置的语言’后，当前的界面语言并没有改变，而其他界面的语言已经改变了，就比如说我上面截图的侧滑菜单，当我在侧滑菜单切换语言后发现侧滑菜单里面的语言并没有发现变化，而首页的语言环境已经改变了，我不知道为什么，摸索最后找到了一种解决方案（可能不是最佳方案，但是解决了刷新当前界面语言的问题，如果有更好的方法欢迎分享），解决方案：调用一下setState（无论设置的这个state属性在render中有没有被使用，都有效）。具体代码看App.js，我项目中有使用localeLanguage所以我把改变后的语言存到state中 123456789this.setState({ localeLanguage: I18n.locale }); 请注意，js的名字最好都是语言的缩写，下面提供参考： 突然有个想法看看没有支持的语言会变成什么：看来如果没有支持某种语言就会默认使用英语，我曾经试过分别调换这两个的引入顺序发现结果还是英语","link":"/blog/2019/05/25/React-Native/React-Native国际化多语言/"},{"title":"React-Native-中组件的生命周期","text":"概述就像 Android 开发中的 View 一样，React Native（RN）中的组件也有生命周期（Lifecycle）。所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。RN组件的生命周期整理如下图： 如图，可以把组件生命周期大致分为三个阶段： 第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化； 第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面； 第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。 生命周期回调函数下面来详细介绍生命周期中的各回调函数。 getDefaultProps在组件创建之前，会先调用getDefaultProps()，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用getInitialState()，来初始化组件的状态。 componentWillMount然后，准备加载组件，会调用componentWillMount()，其原型如下： void componentWillMount() 这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制render()之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。 componentDidMount在组件第一次绘制之后，会调用componentDidMount()，通知组件已经加载完成。函数原型如下： void componentDidMount() 这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN框架是先调用子组件的componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS其他框架交互了，例如设置计时setTimeout或者setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。 componentWillReceiveProps如果组件收到新的属性（props），就会调用componentWillReceiveProps()，其原型如下： 123456789void componentWillReceiveProps( object nextProps ) 输入参数nextProps是即将被设置的属性，旧的属性还是可以通过this.props来获取。在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，这里调用更新状态是安全的，并不会触发额外的render()调用。如下： 1234567891011121314151617componentWillReceiveProps: function(nextProps) { this.setState({ likesIncreasing: nextProps.likeCount this.props.likeCount }); } shouldComponentUpdate当组件接收到新的属性和状态改变的话，都会触发调用shouldComponentUpdate(…)，函数原型如下： 123456789boolean shouldComponentUpdate( object nextProps, object nextState ) 输入参数nextProps和上面的componentWillReceiveProps函数一样，nextState表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果true表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。 默认情况下，这个函数永远返回true用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定UI 是否需要更新，能有效提高应用性能。 componentWillUpdate如果组件状态或者属性改变，并且上面的shouldComponentUpdate(…)返回为true，就会开始准更新组件，并调用componentWillUpdate()，其函数原型如下： 12345678910void componentWillUpdate(object nextProps, object nextState) 输入参数与shouldComponentUpdate一样，在这个回调中，可以做一些在更新界面之前要做的事情。需要特别注意的是，在这个函数里面，你就不能使用this.setState来修改状态。这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。紧接着这个函数，就会调用render()来更新界面了。 componentDidUpdate调用了render()更新完成界面之后，会调用componentDidUpdate()来得到通知，其函数原型如下： 12345678910void componentDidUpdate(object prevProps, object prevState) 因为到这里已经完成了属性和状态的更新了，此函数的输入参数变成了prevProps和prevState。 componentWillUnmount当组件要被从界面上移除的时候，就会调用componentWillUnmount()，其函数原型如下： void componentWillUnmount() 在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等。 总结到这里，RN 的组件的完整的生命都介绍完了，在回头来看一下前面的图，就比较清晰了，把生命周期的回调函数总结成如下表格： 生命周期 调用次数 能否使用setSate() getDefaultProps 1(全局调用一次) 否 getInitialState 1否 componentWillMount 1 是 render =1否 componentDidMount 1 是 componentWillReceiveProps =0 是 shouldComponentUpdate =0 否 componentWillUpdate =0 否 componentDidUpdate =0 否 componentWillUnmount 1 否","link":"/blog/2019/05/25/React-Native/React-Native-中组件的生命周期/"},{"title":"React-Native原理浅析","text":"&lt;https://github.com/guoxiaoxing/react-native/tree/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87&gt; 线程模型RN应用中存在3个线程： UI线程：即Android中的主线程，负责绘制UI以及监听用户操作。 Native线程：负责执行C++代码，该线程主要负责Java与C++的通信。 JS线程：负责解释执行JS。 渲染模型 渲染模型框架： VirtualDom的diff模型： 具体VirtualDom的算法模型可以参考这篇文章： [深度剖析：如何实现一个 Virtual DOM 算法](https://www.cnblogs.com/fengyuqing/p/virtual-dom.html) Js渲染Native具体范例： JS端通过调用RCTUIManager的createView的方法,传递json格式的数据,通知native端进行UI组件的初始化和渲染。 通信模型 JNI作为C++与Java的桥梁，JSC作为C++与JavaScript的桥梁，而C++最终连接了Java与JavaScript。 Java调Js 原理使用了JSCore从Native执行JS代码，RN在此基础上给我们提供了通知发送的执行方式 具体实现：Java通过注册表调用到CatalystInstance实例，透过ReactBridge的jni，调用到Onload.cpp中的callFunction，最后通过javascriptCore，调用BatchedBridge.js，根据参数｛moduleID,methodID｝require相应Js模块执行。流程如下图： Js调Java 一般情况下，JS调Java的机制是［JS把对应的methodId和paramspush到MessageQueue中，等待native调用JS，然后把MessageQueue中的数据发送到C层，再通过jni转到java层］ 但如果JS的MessageQueue中的message超过 5ms 都没有取走，那么 JavaScript就会主动调用方法nativeFlushQueueImmediate，通知C层将message取走。流程如下图： JS的解析是在Webkit-JavaScriptCore中完成的，JSCExexutor对JavaScriptCore的功能做了进一步的封装","link":"/blog/2019/05/25/React-Native/React-Native原理浅析/"},{"title":"React-Native国际化多语言","text":"使用 React Native 替代基于 WebView 的框架来开发 App 的一个强有力的理由，就是为了使 App 可以达到每秒 60帧（足够流畅），并且能有类似原生 App 的外观和手感。因此我们也尽可能地优化 React Native 去实现这一目标，使开发者能集中精力处理 App的业务逻辑，而不用费心考虑性能。但是，总还是有一些地方有所欠缺，以及在某些场合 React Native还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的。 本文的目的是教给你一些基本的知识，来帮你排查性能方面的问题，以及探讨这些问题产生的原因和推荐的解决方法。 关于“帧”你所需要知道的老一辈人常常把电影称为“移动的画”，是因为视频中逼真的动态效果其实是一种幻觉，这种幻觉是由一组静态的图片以一个稳定的速度快速变化所产生的。我们把这组图片中的每一张图片叫做一帧，而每秒钟显示的帧数直接的影响了视频（或者说用户界面）的流畅度和真实感。iOS设备提供了每秒 60 的帧率，这就留给了开发者和 UI 系统大约 16.67ms 来完成生成一张静态图片（帧）所需要的所有工作。如果在这分派的16.67ms 之内没有能够完成这些工作，就会引发‘丢帧’的后果，使界面表现的不够流畅。 下面要讲的事情可能更为复杂：请先调出你应用的开发菜单，打开Show FPS Monitor. 你会注意到有两个不同的帧率. JS 帧率(JavaScript 线程)对大多数 React Native 应用来说，业务逻辑是运行在 JavaScript 线程上的。这是 React 应用所在的线程，也是发生 API调用，以及处理触摸事件等操作的线程。更新数据到原生支持的视图是批量进行的，并且在事件循环每进行一次的时候被发送到原生端，这一步通常会在一帧时间结束之前处理完（如果一切顺利的话）。如果JavaScript 线程有一帧没有及时响应，就被认为发生了一次丢帧。例如，你在一个复杂应用的根组件上调用了this.setState，从而导致一次开销很大的子组件树的重绘，可想而知，这可能会花费 200ms 也就是整整 12帧的丢失。此时，任何由 JavaScript 控制的动画都会卡住。只要卡顿超过 100ms，用户就会明显的感觉到。 这种情况经常发生在老的Navigator导航器的切换过程中：当你 push 一个新的路由时，JavaScript需要绘制新场景所需的所有组件，以发送正确的命令给原生端去创建视图。由于切换是由 JavaScript线程所控制，因此经常会占用若干帧的时间，引起一些卡顿。有的时候，组件会在componentDidMount函数中做一些额外的事情，这甚至可能会导致页面切换过程中多达一秒的卡顿。 另一个例子是老的触摸事件的响应：如果你正在 JavaScript线程处理一个跨越多个帧的工作，你可能会注意到TouchableOpacity的响应被延迟了。这是因为 JavaScript线程太忙了，不能够处理主线程发送过来的原始触摸事件，结果TouchableOpacity就不能及时响应这些事件并命令主线程的页面去调整透明度了。 UI 帧率(主线程)很多人会注意到，NavigatorIOS的性能要比老的纯 JS 实现的Navigator好的多。原因就是它的切换动画是完全在主线程上执行的，因此不会被JavaScript 线程上的掉帧所影响。 同样，当 JavaScript线程卡住的时候，你仍然可以欢快的上下滚动ScrollView，因为ScrollView运行在主线程之上（尽管滚动事件会被分发到 JS线程，但是接收这些事件对于滚动这个动作来说并不必要）。 性能问题的常见原因开发模式 (dev=true)JavaScript线程的性能在开发模式下是很糟糕的。这是不可避免的，因为有许多工作需要在运行的时候去做，譬如使你获得良好的警告和错误信息，又比如验证属性类型（propTypes）以及产生各种其他的警告。请务必注意在[release模式](https://reactnative.cn/docs/running-on-device#%E5%8F%91%E5%B8%83%E5%BA%94%E7%94%A8)下去测试性能。 console.log 语句在运行打好了离线包的应用时，控制台打印语句可能会极大地拖累 JavaScript 线程。注意有些第三方调试库也可能包含控制台打印语句，比如[redux-logger](https://github.com/evgenyrodionov/redux-logger)，所以在发布应用前请务必仔细检查，确保全部移除。 这里有个小技巧可以在发布时屏蔽掉所有的console.*调用。React Native中有一个全局变量DEV用于指示当前运行环境是否是开发环境。我们可以据此在正式环境中替换掉系统原先的 console 实现。 123456789101112131415161718192021222324252627282930313233if (!__DEV__) { global.console = { info: () = {}, log: () = {}, warn: () = {}, debug: () = {}, error: () = {} }; } 这样在打包发布时，所有的控制台语句就会被自动替换为空函数，而在调试时它们仍然会被正常调用。 还有个[babel 插件](https://babeljs.io/docs/plugins/transform-remove-console/)可以帮你移除所有的console.*调用。首先需要使用yarn add –dev babel-plugin-transform-remove-console来安装，然后在项目根目录下编辑（或者是新建）一个名为·.babelrc`的文件，在其中加入： 123456789101112131415161718192021222324252627{ &quot;env&quot;: { &quot;production&quot;: { &quot;plugins&quot;: [&quot;transform-remove-console&quot;] } }} 这样在打包发布时，所有的控制台语句就会被自动移除，而在调试时它们仍然会被正常调用。 ListViewinitial rendering is too slow or scroll performance is bad forlarge lists Use thenewFlatListorSectionListcomponentinstead. Besides simplifying the API, the new list components also havesignificant performance enhancements, the main one being nearly constantmemory usage for any number of rows. If yourFlatListis rendering slow, besure that you’ve implemented[getItemLayout](https://facebook.github.io/react-native/flatlist.md#getitemlayout)to optimize rendering speed by skippingmeasurement of the rendered items. 在重绘一个几乎没有什么变化的页面时，JS 帧率严重降低你可以实现shouldComponentUpdate函数来指明在什么样的确切条件下，你希望这个组件得到重绘。如果你编写的是纯粹的组件（界面完全由 props和 state所决定），你可以利用PureComponent来为你做这个工作。再强调一次，不可变的数据结构（immutable，即对于引用类型数据，不修改原值，而是复制后修改并返回新值）在提速方面非常有用—— 当你不得不对一个长列表对象做一个深度的比较，它会使重绘你的整个组件更加快速，而且代码量更少。 在屏幕上移动视图（滚动，切换，旋转）时，UI 线程掉帧当具有透明背景的文本位于一张图片上时，或者在每帧重绘视图时需要用到透明合成的任何其他情况下，这种现象尤为明显。设置shouldRasterizeIOS或者renderToHardwareTextureAndroid属性可以显著改善这一现象。注意不要过度使用该特性，否则你的内存使用量将会飞涨。在使用时，要评估你的性能和内存使用情况。如果你没有需要移动这个视图的需求，请关闭这一属性。 使用动画改变图片的尺寸时，UI 线程掉帧在 iOS 上，每次调整 Image组件的宽度或者高度，都需要重新裁剪和缩放原始图片。这个操作开销会非常大，尤其是大的图片。比起直接修改尺寸，更好的方案是使用transform:[{scale}]的样式属性来改变尺寸。比如当你点击一个图片，要将它放大到全屏的时候，就可以使用这个属性。 Touchable 系列组件不能很好的响应有些时候，如果我们有一项操作与点击事件所带来的透明度改变或者高亮效果发生在同一帧中，那么有可能在onPress函数结束之前我们都看不到这些效果。比如在onPress执行了一个setState的操作，这个操作需要大量计算工作并且导致了掉帧。对此的一个解决方案是将onPress处理函数中的操作封装到requestAnimationFrame中： 12345678910111213141516171819202122232425handleOnPress() { // 谨记在使用requestAnimationFrame、setTimeout以及setInterval时 // 要使用TimerMixin（其作用是在组件unmount时，清除所有定时器） this.requestAnimationFrame(() = { this.doExpensiveAction(); }); } 分析你可以利用内置的分析器来同时获取 JavaScript 线程和主线程中代码执行情况的详细信息。 对于 iOS 来说，Instruments 是一个宝贵的工具库，Android 的话可以使用 systrace，具体可以参考下面的使用 systrace调试 Android UI 性能。 But first,[make sure that Development Mode isOFF!](https://reactnative.cn/docs/performance#running-in-development-mode-dev-true)You should see__DEV__ === false, development-level warning are OFF,performance optimizations are ONin your application logs. Another way to profile JavaScript is to use the Chrome profiler whiledebugging. This won’t give you accurate results as the code is running inChrome but will give you a general idea of where bottlenecks might be. Run theprofiler under Chrome’sPerformancetab. A flame graph will appear underUserTiming. To view more details in tabular format, click at theBottom Uptab belowand then selectDedicatedWorker Threadat the top left menu. 使用 systrace 调试 Android UI 性能Android supports 10k+ different phones and is generalized to support softwarerendering: the framework architecture and need to generalize across manyhardware targets unfortunately means you get less for free relative to iOS.But sometimes, there are things you can improve – and many times it’s notnative code’s fault at all! The first step for debugging this jank is to answer the fundamental questionof where your time is being spent during each 16ms frame. For that, we’ll beusing a standard Android profiling tool calledsystrace. systraceis a standard Android marker-based profiling tool (and is installedwhen you install the Android platform-tools package). Profiled code blocks aresurrounded by start/end markers which are then visualized in a colorful chartformat. Both the Android SDK and React Native framework provide standardmarkers that you can visualize. 1. Collecting a traceFirst, connect a device that exhibits the stuttering you want to investigateto your computer via USB and get it to the point right before thenavigation/animation you want to profile. Runsystraceas follows: $ &lt;path_to_android_sdk/platform-tools/systrace/systrace.py –time=10 -otrace.html sched gfx view -a &lt;your_package_name A quick breakdown of this command: timeis the length of time the trace will be collected in seconds sched,gfx, andvieware the android SDK tags (collections of markers) we careabout:schedgives you information about what’s running on each core of yourphone,gfxgives you graphics info such as frame boundaries, andviewgives youinformation about measure, layout, and draw passes -a &lt;your_package_nameenables app-specific markers, specifically the ones built into the React Native framework.your_package_namecan be found in theAndroidManifest.xmlof your app and looks likecom.example.app Once the trace starts collecting, perform the animation or interaction youcare about. At the end of the trace, systrace will give you a link to thetrace which you can open in your browser. 2. Reading the traceAfter opening the trace in your browser (preferably Chrome), you should seesomething like this: HINT: Use the WASD keys to strafe and zoom If your trace .html file isn’t opening correctly, check your browser consolefor the following: SinceObject.observewas deprecated in recent browsers, you may have to open thefile from the Google Chrome Tracing tool. You can do so by: Opening tab inchromechrome://tracing Selecting load Selecting the html file generated from the previous command. Enable VSync highlighting Check this checkbox at the top right of the screen to highlight the 16msframe boundaries: You should see zebra stripes as in the screenshot above. If you don’t, tryprofiling on a different device: Samsung has been known to have issuesdisplaying vsyncs while the Nexus series is generally pretty reliable. 3. Find your processScroll until you see (part of) the name of your package. In this case, I wasprofilingcom.facebook.adsmanager, which shows up asbook.adsmanagerbecause ofsilly thread name limits in the kernel. On the left side, you’ll see a set of threads which correspond to the timelinerows on the right. There are a few threads we care about for our purposes: theUI thread (which has your package name or the name UI Thread),mqt_js,andmqt_native_modules. If you’re running on Android 5+, we also care about theRender Thread. UI Thread.This is where standard android measure/layout/draw happens. Thethread name on the right will be your package name (in my casebook.adsmanager) or UI Thread. The events that you see on this thread shouldlook something like this and have to do withChoreographer,traversals,andDispatchUI: JS Thread.This is where JavaScript is executed. The thread name will beeithermqt_jsor&lt;…depending on how cooperative the kernel on your device isbeing. To identify it if it doesn’t have a name, look for thingslikeJSCall,Bridge.executeJSCall, etc: Native Modules Thread.This is where native module calls (e.g. theUIManager)are executed. The thread name will be eithermqt_native_modulesor&lt;…. Toidentify it in the latter case, look for thingslikeNativeCall,callJavaModuleMethod, andonBatchComplete: Bonus: Render Thread.If you’re using Android L (5.0) and up, you will alsohave a render thread in your application. This thread generates the actualOpenGL commands used to draw your UI. The thread name will beeitherRenderThreador&lt;…. To identify it in the latter case, look for thingslikeDrawFrameandqueueBuffer: Identifying a culpritA smooth animation should look something like the following: Each change in color is a frame – remember that in order to display a frame,all our UI work needs to be done by the end of that 16ms period. Notice thatno thread is working close to the frame boundary. An application renderinglike this is rendering at 60 FPS. If you noticed chop, however, you might see something like this: Notice that the JS thread is executing basically all the time, and acrossframe boundaries! This app is not rendering at 60 FPS. In this case,theproblem lies in JS. You might also see something like this: In this case, the UI and render threads are the ones that have work crossingframe boundaries. The UI that we’re trying to render on each frame isrequiring too much work to be done. In this case,the problem lies in thenative views being rendered. At this point, you’ll have some very helpful information to inform your nextsteps. Resolving JavaScript issuesIf you identified a JS problem, look for clues in the specific JS that you’reexecuting. In the scenario above, we seeRCTEventEmitterbeing called multipletimes per frame. Here’s a zoom-in of the JS thread from the trace above: This doesn’t seem right. Why is it being called so often? Are they actuallydifferent events? The answers to these questions will probably depend on yourproduct code. And many times, you’ll want to lookinto[shouldComponentUpdate](https://facebook.github.io/react/component-specs.md#updating-shouldcomponentupdate). Resolving native UI IssuesIf you identified a native UI problem, there are usually two scenarios: the UI you’re trying to draw each frame involves too much work on the GPU, or You’re constructing new UI during the animation/interaction (e.g. loading innew content during a scroll). Too much GPU work In the first scenario, you’ll see a trace that has the UI thread and/or RenderThread looking like this: Notice the long amount of time spent inDrawFramethat crosses frame boundaries.This is time spent waiting for the GPU to drain its command buffer from theprevious frame. To mitigate this, you should: investigate usingrenderToHardwareTextureAndroidfor complex, static contentthat is being animated/transformed (e.g. theNavigatorslide/alpha animations) make sure that you arenotusingneedsOffscreenAlphaCompositing, which isdisabled by default, as it greatly increases the per-frame load on the GPU inmost cases. If these don’t help and you want to dig deeper into what the GPU is actuallydoing, you can check outTracer for OpenGLES. Creating new views on the UI thread In the second scenario, you’ll see something more like this: Notice that first the JS thread thinks for a bit, then you see some work doneon the native modules thread, followed by an expensive traversal on the UIthread. There isn’t an easy way to mitigate this unless you’re able to postponecreating new UI until after the interaction, or you are able to simplify theUI you’re creating. The react native team is working on an infrastructurelevel solution for this that will allow new UI to be created and configuredoff the main thread, allowing the interaction to continue smoothly. 拆包(RAM bundles)和内联引用如果你有一个较为庞大的应用程序，你可能要考虑使用RAM(Random Access Modules，随机存取模块）格式的 bundle和内联引用。这对于具有大量页面的应用程序是非常有用的，这些页面在应用程序的典型使用过程中可能不会被打开。通常对于启动后一段时间内不需要大量代码的应用程序来说是非常有用的。例如应用程序包含复杂的配置文件屏幕或较少使用的功能，但大多数会话只涉及访问应用程序的主屏幕更新。我们可以通过使用RAM格式来优化bundle的加载，并且内联引用这些功能和页面（当它们被实际使用时）。 加载 JavaScript在 react-native 执行 JS 代码之前，必须将代码加载到内存中并进行解析。如果你加载了一个 50MB 的 bundle，那么所有的 50mb都必须被加载和解析才能被执行。RAM 格式的 bundle 则对此进行了优化，即启动时只加载 50MB 中实际需要的部分，之后再逐渐按需加载更多的包。 内联引用内联引用(require 代替 import)可以延迟模块或文件的加载，直到实际需要该文件。一个基本的例子看起来像这样： 优化前 1234567891011121314151617181920212223242526272829303132333435363738394041import React, { Component } from &apos;react&apos;; import { Text } from &apos;react-native&apos;; // ... import some very expensive modules // You may want to log at the file level to verify when this is happening console.log(&apos;VeryExpensive component loaded&apos;); export default class VeryExpensive extends Component { // lots and lots of code render() { return &lt;TextVery Expensive Component&lt;/Text; } } 优化后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import React, { Component } from &apos;react&apos;; import { TouchableOpacity, View, Text } from &apos;react-native&apos;; let VeryExpensive = null; export default class Optimized extends Component { state = { needsExpensive: false }; didPress = () = { if (VeryExpensive == null) { VeryExpensive = require(&apos;./VeryExpensive&apos;).default; } this.setState(() = ({ needsExpensive: true, })); }; render() { return ( &lt;View style={{ marginTop: 20 }}&gt; &lt;TouchableOpacity onPress={this.didPress}&gt; &lt;TextLoad&gt;&lt;/Text&gt; &lt;/TouchableOpacity&gt; {this.state.needsExpensive ? &lt;VeryExpensive /&gt; : null} &lt;/View&gt; ); } } 即便不使用 RAM 格式，内联引用也会使启动时间减少，因为优化后的代码只有在第一次 require 时才会执行。 启用 RAM 格式在 iOS 上使用 RAM 格式将创建一个简单的索引文件，React Native 将根据此文件一次加载一个模块。在 Android上，默认情况下它会为每个模块创建一组文件。你可以像 iOS 一样，强制 Android 只创建一个文件，但使用多个文件可以提高性能，并降低内存占用。 在 Xcode 中启用 RAM 格式，需要编辑 build phase 里的”Bundle React Native code andimages”。在../node_modules/react-native/packager/react-native-xcode.sh中添加exportBUNDLE_COMMAND=”ram-bundle”: export BUNDLE_COMMAND=”ram-bundle” export NODE_BINARY=node ../node_modules/react-native/packager/react-native-xcode.sh 在 Android 上启用 RAM 格式，需要编辑 android/app/build.gradle 文件。在apply from:“../../node_modules/react-native/react.gradle”之前修改或添加project.ext.react： 123456789project.ext.react = [ bundleCommand: &quot;ram-bundle&quot;, ] 如果在 Android 上，你想使用单个索引文件（如前所述），请在 Android 上使用以下行： 12345678910111213project.ext.react = [ bundleCommand: &quot;ram-bundle&quot;, extraPackagerArgs: [&quot;--indexed-ram-bundle&quot;] ] 配置预加载及内联引用现在我们已经启用了RAM格式，然而调用require会造成额外的开销。因为当遇到尚未加载的模块时，require需要通过bridge来发送消息。这主要会影响到启动速度，因为在应用程序加载初始模块时可能触发相当大量的请求调用。幸运的是，我们可以配置一部分模块进行预加载。为了做到这一点，你将需要实现某种形式的内联引用。 添加 packager 配置文件在项目中创建一个名为 packager 的文件夹，并创建一个名为 config.js 的文件。添加以下内容： cons12345678910111213141516171819202122232425262728293031323334353637t config = { transformer: { getTransformOptions: () = { return { transform: { inlineRequires: true }, }; }, }, }; module.exports = config; 在 Xcode 的 Build phase 中添加export BUNDLE_CONFIG=”packager/config.js” 123456789export BUNDLE_COMMAND=&quot;ram-bundle&quot; export BUNDLE_CONFIG=&quot;packager/config.js&quot; export NODE_BINARY=node ../node_modules/react-native/packager/react-native-xcode.sh 编辑 android/app/build.gradle 文件，添加bundleConfig: “packager/config.js”, 12345678910111213project.ext.react = [ bundleCommand: &quot;ram-bundle&quot;, bundleConfig: &quot;packager/config.js&quot; ] 最后，在 package.json 的“scripts”下修改“start”命令来启用配置文件： “start”: “node node_modules/react-native/local-cli/cli.js start –config../../../../packager/config.js”, 此时用npm start启动你的 packager 服务即会加载配置文件。请注意，如果你仍然通过 xcode 或是 react-native run-android 等方式自动启动 packager 服务，则由于没有使用上面的参数，不会加载配置文件。 调试预加载的模块 在您的根文件 (index.(ios|android).js) 中，您可以在初始导入(initial imports)之后添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const modules = require.getModules(); const moduleIds = Object.keys(modules); const loadedModuleNames = moduleIds .filter(moduleId = modules[moduleId].isInitialized) .map(moduleId = modules[moduleId].verboseName); const waitingModuleNames = moduleIds .filter(moduleId = !modules[moduleId].isInitialized) .map(moduleId = modules[moduleId].verboseName); // make sure that the modules you expect to be waiting are actually waiting console.log( &apos;loaded:&apos;, loadedModuleNames.length, &apos;waiting:&apos;, waitingModuleNames.length ); // grab this text blob, and put it in a file named packager/modulePaths.js console.log(`module.exports =${JSON.stringify(loadedModuleNames.sort())};`); 当你运行你的应用程序时，你可以查看 console 控制台，有多少模块已经加载，有多少模块在等待。你可能想查看moduleNames，看看是否有任何意外。注意在首次 import时调用的内联引用。你可能需要检查和重构，以确保只有你想要的模块在启动时加载。请注意，您可以根据需要修改 Systrace 对象，以帮助调试有问题的引用。 1234567891011121314151617require.Systrace.beginEvent = (message) = { if(message.includes(problematicModule)) { throw new Error(); } } 虽然每个 App 各有不同，但只加载第一个页面所需的模块是有普适意义的。当你满意时，把 loadedModuleNames 的输出放到packager/modulePaths.js 文件中。 更新配置文件Returning to packager/config.js we should update it to use our newly generatedmodulePaths.js file. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const modulePaths = require(&apos;./modulePaths&apos;); const resolve = require(&apos;path&apos;).resolve; const fs = require(&apos;fs&apos;); // Update the following line if the root folder of your app is somewhereelse. const ROOT_FOLDER = path.resolve(__dirname, &apos;..&apos;); const config = { transformer: { getTransformOptions: () = { const moduleMap = {}; modulePaths.forEach(path = { if (fs.existsSync(path)) { moduleMap[resolve(path)] = true; } }); return { preloadedModules: moduleMap, transform: { inlineRequires: { blacklist: moduleMap } }, }; }, }, }; module.exports = config; 在启用RAM格式之后，配置文件中的preloadedModules条目指示哪些模块需要预加载。当 bundle 被加载时，这些模块立即被加载，甚至在任何requires 执行之前。blacklist 表明这些模块不应该被要求内联引用，因为它们是预加载的，所以使用内联没有性能优势。实际上每次解析内联引用JavaScript 都会花费额外的时间。 测试和衡量改进您现在应该准备好使用RAM格式和内联引用来构建您的应用了。保存启动前后的时间，来测试下有多少改进吧！ 无状态组件需使用 PureComponent 而不是 Component； 说明：无状态组件是指内部没有使用 state 的组件，但是可以使用 props来进行某些属性控制; 使用 InteractionManager.runAfterInteractions，在动画或者某些特定场景中利用 InteractionManager来选择性的渲染新场景所需的最小限度的内容； 使用场景类似于： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class ExpensiveScene extends [React.Component](http://react.component/){ constructor(props, context) { super(props, context); this.state = { renderPlaceholderOnly: true }; } componentDidMount() { InteractionManager.runAfterInteractions(() = { this.setState({ renderPlaceholderOnly: false }); }); } render() { if (this.state.renderPlaceholderOnly) { return this.renderPlaceholderView(); } return ( &lt;View &lt;TextYour full view goes here&lt;/Text &lt;/View ); } renderPlaceholderView() { return ( &lt;View &lt;TextLoading...&lt;/Text &lt;/View ); } } 使用新版本组件替换旧办法组件； 例如：FlatList 替换 ListView，React Navigation 替换 Navigator 等 在使用 Touchable 系列组件时，进行 setState 或者大量调帧操作，请使用如下方式 1234567891011121314151617handleOnPress() { this.requestAnimationFrame(() = { //todo }); }","link":"/blog/2019/05/25/React-Native/React-Native性能优化/"},{"title":"React-Native常用三方组件库大全","text":"作者整理的一套常用的ReactNative开发中使用到的三方组件库大全，后续也会持续更新，同学们如果发现有好用的组件但是文章中没有列出的，也请给作者留言告知组件名称，作者好将读者们反馈的组件添加到文章中，以便帮助更多的RN开发者。后续持续更新的三方组件会放到文章的开头部分，代表是新追加的组件，小伙伴们请知晓！ 如果小伙伴们想学习React Native 框架的搭建以及Redux框架的学习使用，可以参考作者的开源项目OneM:https://github.com/guangqiang-liu/OneM 记得给个star哦 当然也欢迎小伙伴们加入作者的React Native实战开发QQ交流群:620792950, 开发中遇到的问题可以在群里随意的提问，互相交流学习。 react-native -30 (每天一个Demo，共三十个，有些demo很不错哦)https://github.com/fangwei716/30-days-of-react-native 自动管理Timer组件此组件目前只支持ES5 语法，ES6语法 请在componentWillUnmount() 中清除timer https://github.com/reactjs/react-timer-mixin 蚂蚁金服组件库 antd-mobilehttps://github.com/ant-design/ant-design-mobile react-native-buttonhttps://github.com/ide/react-native-button 点击图片放大缩小https://github.com/ascoders/react-native-image-viewer 进度组件https://github.com/oblador/react-native-progress 路由组件react-native-router-fluxhttps://github.com/aksonov/react-native-router-flux 简单的storage封装https://github.com/jasonmerino/react-native-simple-store tabBar组件react-native-tab-navigatorhttps://github.com/happypancake/react-native-tab-navigator iconFont组件https://github.com/oblador/react-native-vector-icons 分页组件 react-native-viewpagerhttps://github.com/race604/react-native-viewpager 导航组件 react-navigationhttps://github.com/react-community/react-navigation 动画https://github.com/oblador/react-native-animatable 轮播https://github.com/nick/react-native-carousel 倒计时https://github.com/buhe/react-native-countdown 设备信息react-native-device-infohttps://github.com/rebeccahughes/react-native-device-info 文件上传react-native-fileuploadhttps://github.com/PhilippKrone/react-native-fileupload 图标https://github.com/corymsmith/react-native-icons https://github.com/oblador/react-native-vector-icons 图片选择器react-native-image-pickerhttps://github.com/react-community/react-native-image-picker iOS KeyChain管理react-native-keychainhttps://github.com/oblador/react-native-keychain 滚轮选择器react-native-pickerhttps://github.com/beefe/react-native-picker Android 滚轮选择器react-native-picker-Androidhttps://github.com/beefe/react-native-picker-android 可刷新列表react-native-refreshable-listviewhttps://github.com/jsdf/react-native-refreshable-listview 可滚动标签react-native-scrollable-tab-viewhttps://github.com/skv-headless/react-native-scrollable-tab-view 侧栏react-native-side-menuhttps://github.com/react-native-community/react-native-side-menu 轮播react-native-swiperhttps://github.com/leecade/react-native-swiper 音视频播放react-native-videohttps://github.com/react-native-community/react-native-video 分页浏览react-native-viewpagerhttps://github.com/race604/react-native-viewpager 可滑动的底部或上部导航栏框架react-native-scrollable-tab-viewhttps://github.com/skv-headless/react-native-scrollable-tab-view 底部或上部导航框架(不可滑动)react-native-tab-navigatorhttps://github.com/happypancake/react-native-tab-navigator CheckBoxreact-native-check-boxhttps://github.com/crazycodeboy/react-native-check-box 启动白屏问题react-native-splash-screenhttps://github.com/crazycodeboy/react-native-splash-screen 简易路由跳转框架react-native-simple-routerhttps://github.com/react-native-simple-router-community/react-native-simple-router 持久化存储react-native-storagehttps://github.com/sunnylqm/react-native-storage 分类ListViewreact-native-sortable-listviewhttps://github.com/deanmcpherson/react-native-sortable-listview 将 HTML 目录作为本地视图的控件，其风格可以定制react-native-htmlviewhttps://github.com/jsdf/react-native-htmlview Toastreact-native-easy-toasthttps://github.com/crazycodeboy/react-native-easy-toast material组件库（各种漂亮的小组件）https://github.com/xinthink/react-native-material-kitbase 组件库（各种封装不错的小组件）http://nativebase.io/docs/v0.4.6/components#anatomy https://github.com/GeekyAnts/NativeBase 按钮https://github.com/mastermoo/react-native-action-button https://github.com/ide/react-native-button 输入框表单验证https://github.com/gcanti/tcomb-form-native https://github.com/FaridSafi/react-native-gifted-form https://github.com/bartonhammond/snowflake 炫酷效果的 TextInputhttps://github.com/halilb/react-native-textinput-effects https://github.com/zbtang/React-Native-TextInputLayout 聊天https://github.com/FaridSafi/react-native-gifted-chat 地图https://github.com/lelandrichardson/react-native-maps 动画https://github.com/oblador/react-native-animatable 加载动画https://github.com/maxs15/react-native-spinkit 抽屉效果https://github.com/root-two/react-native-drawer 侧滑按钮https://github.com/dancormier/react-native-swipeout https://github.com/jemise111/react-native-swipe-list-view 图表https://github.com/tomauty/react-native-chart 下拉放大https://github.com/lelandrichardson/react-native-parallax-view 可滑动的日历组件https://github.com/cqm1994617/react-native-myCalendar 语言转化和一些常用格式转换https://github.com/joshswan/react-native-globalize 单选多选ListViewhttps://github.com/hinet/react-native-checkboxlist 选择按钮https://github.com/sconxu/react-native-checkbox 二维码https://github.com/ideacreation/react-native-barcodescanner 制作本地库https://github.com/frostney/react-native-create-library 影音相关https://github.com/MisterAlex95/react-native-record-sound 安卓录音https://github.com/bosung90/react-native-audio-android 提示消息的Barhttps://github.com/KBLNY/react-native-message-bar iOS原生TableViewhttps://github.com/aksonov/react-native-tableview 点击弹出视图https://github.com/jeanregisser/react-native-popover https://github.com/instea/react-native-popup-menu 3D Touchhttps://github.com/madriska/react-native-quick-actions 双平台兼容的ActionSheethttps://github.com/beefe/react-native-actionsheet 照片墙https://github.com/ldn0x7dc/react-native-gallery 键盘遮挡问题https://github.com/wix/react-native-keyboard-aware-scrollview https://github.com/reactnativecn/react-native-inputscrollview 本地存储https://github.com/sunnylqm/react-native-storage 星星https://github.com/djchie/react-native-star-rating 国际化https://github.com/joshswan/react-native-globalize 扫描二维码https://github.com/lazaronixon/react-native-qrcode-reader 通讯录https://github.com/rt2zz/react-native-contacts 加密https://www.npmjs.com/package/crypto-js 缓存管理https://github.com/reactnativecn/react-native-http-cache ListView的优化https://github.com/sghiassy/react-native-sglistview 图片和base64互转https://github.com/xfumihiro/react-native-image-to-base64 安卓 iOS 白屏解决https://github.com/mehcode/rn-splash-screen Text跑马灯效果https://github.com/remobile/react-native-marquee-label 清除按钮的输入框https://github.com/beefe/react-native-textinput webView-bridge相关https://github.com/alinz/react-native-webview-bridge 判断横竖屏https://github.com/yamill/react-native-orientation PDFhttps://github.com/cnjon/react-native-pdf-view 获取设备信息https://github.com/rebeccahughes/react-native-device-info 手势放大缩小移动https://github.com/kiddkai/react-native-gestures https://github.com/johanneslumpe/react-native-gesture-recognizers 下拉-上拉-刷新https://github.com/FaridSafi/react-native-gifted-listview https://github.com/jsdf/react-native-refreshable-listview https://github.com/greatbsky/react-native-pull/wiki 下拉选择https://github.com/alinz/react-native-dropdown 图片查看https://github.com/oblador/react-native-lightbox 照片选择https://github.com/marcshilling/react-native-image-picker https://github.com/ivpusic/react-native-image-crop-picker 图片加载进度条https://github.com/oblador/react-native-image-progress 轮播视图https://github.com/race604/react-native-viewpager https://github.com/FuYaoDe/react-native-app-intro https://github.com/appintheair/react-native-looped-carousel https://github.com/leecade/react-native-swiper 模态视图https://github.com/maxs15/react-native-modalbox https://github.com/brentvatne/react-native-modal https://github.com/bodyflex/react-native-simple-modal 毛玻璃效果https://github.com/react-native-fellowship/react-native-blur 头像库https://github.com/oblador/react-native-vector-icons 滑动选项卡https://github.com/skv-headless/react-native-scrollable-tab-view 文件上传https://github.com/aroth/react-native-uploader动画https://github.com/oblador/react-native-animatable 图标https://github.com/oblador/react-native-vector-icons 图片选择器（可多选）https://github.com/ivpusic/react-native-image-crop-picker 滚轮选择器https://github.com/beefe/react-native-picker 下拉刷新listviewhttps://github.com/jsdf/react-native-refreshable-listview 可滚动Tabhttps://github.com/skv-headless/react-native-scrollable-tab-view 侧栏https://github.com/react-native-community/react-native-side-menu 图片轮播https://github.com/leecade/react-native-swiper CheckBoxhttps://github.com/crazycodeboy/react-native-check-box Toasthttps://github.com/crazycodeboy/react-native-easy-toast 各种漂亮的小组件https://github.com/xinthink/react-native-material-kit base组件库https://github.com/GeekyAnts/NativeBase 按钮https://github.com/mastermoo/react-native-action-button 炫酷效果的 TextInputhttps://github.com/halilb/react-native-textinput-effects https://github.com/zbtang/React-Native-TextInputLayout 聊天https://github.com/FaridSafi/react-native-gifted-chat 百度地图https://github.com/lovebing/react-native-baidu-map http://www.jianshu.com/p/eceb7e66fa5e 加载动画https://github.com/maxs15/react-native-spinkit 侧滑按钮https://github.com/dancormier/react-native-swipeout https://github.com/jemise111/react-native-swipe-list-view 图表https://github.com/wuxudong/react-native-charts-wrapper 下拉放大https://github.com/lelandrichardson/react-native-parallax-view 可滑动的日历组件https://github.com/cqm1994617/react-native-myCalendar 提示消息的Barhttps://github.com/KBLNY/react-native-message-bar 点击弹出视图https://github.com/jeanregisser/react-native-popover 3D Touchhttps://github.com/madriska/react-native-quick-actions 双平台兼容的ActionSheethttps://github.com/beefe/react-native-actionsheet 图片加载进度条https://github.com/oblador/react-native-image-progress 模态视图https://github.com/maxs15/react-native-modalbox https://github.com/bodyflex/react-native-simple-modal 毛玻璃效果https://github.com/react-native-community/react-native-blur 按钮特效https://github.com/dwicao/react-native-circle-button 折叠动画https://github.com/jmurzy/react-native-foldview 方块滚动轮播图https://github.com/archriss/react-native-snap-carousel 下拉选项组件https://github.com/sohobloo/react-native-modal-dropdown 提示气泡toasthttps://github.com/magicismight/react-native-root-toast From表单https://github.com/FaridSafi/react-native-gifted-form 线性渐变颜色https://link.jianshu.com/?t=https://github.com/brentvatne/react-native-linear-gradient app 引导页https://github.com/fuyaode/react-native-app-intro 手势解锁密码https://link.jianshu.com/?t=https://github.com/spikef/react-native-gesture-password 瀑布流列表https://github.com/xudafeng/autoresponsive-react-native 折叠列表https://github.com/naoufal/react-native-accordion 通讯录https://github.com/i6mi6/react-native-alphabetlistview 多级菜单https://github.com/vczero/react-native-tab-menu tip提示框https://github.com/chirag04/react-native-tooltip pdf文件上传https://link.jianshu.com/?t=https://github.com/wonday/react-native-pdf https://github.com/christopherdro/react-native-html-to-pdf 上传doc文档https://github.com/philipphecht/react-native-doc-viewer 列表滑动删除https://github.com/jemise111/react-native-swipe-list-view IM聊天界面https://github.com/Ice-MT/react-native-imUI","link":"/blog/2019/05/25/React-Native/React-Native常用三方组件库大全/"},{"title":"React-Native页面优化实践","text":"生产环境下日志输出禁用接入babel-plugin-transform-remove-console 1npm install babel-plugin-transform-remove-console --save-dev 配置.babelrc 1234567891011121314151617181920212223242526272829303132333435363738394041// 生产环境下配置去掉console输出 { ... &quot;plugins&quot;: [ ... ], &quot;env&quot;: {&quot;production&quot;: { &quot;plugins&quot;: [[&quot;transform-remove-console&quot;, {&quot;exclude&quot;: [&quot;error&quot;]}]] } } } 采用setNativeProps在RN中，如果需要频繁刷新view，建议使用setNativeProps，避免使用setState导致的频繁render。 类似顶部tab的透明度渐变，就适用这种情况 官方原文建议 在（不得不）频繁刷新而又遇到了性能瓶颈的时候。直接操作组件并不是应该经常使用的工具。一般来说只是用来创建连续的动画，同时避免渲染组件结构和同步太多视图变化所带来的大量开销。setNativeProps是一个“简单粗暴”的方法，它直接在底层（DOM、UIView等）而不是React组件中记录state，这样会使代码逻辑难以理清。所以在使用这个方法之前，请尽量先尝试用setState和shouldComponentUpdate方法来解决问题。 使用PureComponent或shouldComponentUpdate PureComponent 当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM的生成和比对过程，达到提升性能的目的。 具体原理是 在shouldComponentUpdate回调中，对oldState和newState 及oldProps和newProps进行浅比较，如不同，才return true，进而回调render。 重写shouldComponentUpdate 代码块 123456789shouldComponentUpdate() { return this.state.update; } 控制在需要的时候才去刷新，根据需求或者业务去控制。 Android硬件加速通过启用View的renderToHardwareTextureAndroid属性为true，可以开启View的硬件加速。（决定这个视图是否要把它自己（以及所有的子视图）渲染到一个 GPU 上的硬件纹理中。） 在 Android上，这对于只修改不透明度、旋转、位移、或缩放的动画和交互十分有用：在这些情况下，视图不必每次都重新绘制，显示列表也不需要重新执行。纹理可以被重用于不同的参数。负面作用是这会大量消耗显存，所以当交互/动画结束后应该把此属性设置回false。 shouldRasterizeIOS 在iOS上有个 shouldRasterizeIOS属性，可以设置该view在被渲染到屏幕之前，先绘制到一个位图上，这个我理解和Android中的双缓冲区比较想像。 这个属性对于不会修改组件和子视图尺寸的动画和交互十分有用。举例来说，当我们移动一个静态视图的位置的时候，预渲染允许渲染器重用一个缓存了静态视图的位图，并快速合成。 长列表加载使用用复用性更强的FlatList或SectionList FlatList或SectionList优化： Item采用PureComponent或重写shouldComponentUpdate getItemLayout如果行高是固定的，可以使用getItemLayout，避免动态测量内容尺寸的开销。 首屏进入时间优化 减少bundle包大小 图片压缩； 图片上传到图片服务器，再引用； mrn团队的拆包策略（目前有bug） 懒加载 JS在执行import时有时很需要时间，首屏不需要展示的组件可以懒加载 代码块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import React, { Component } from &apos;react&apos;; import { TouchableOpacity, View, Text } from &apos;react-native&apos;; // 先把这个组件赋值为null let VeryExpensive = null; export default class Optimized extends Component { state = { needsExpensive: false }; didPress = () = { if (VeryExpensive == null) { // 真正需要这个组件的时候才加载 VeryExpensive = require(&apos;./VeryExpensive&apos;).default; } this.setState(() = ({ needsExpensive: true, })); }; render() { return ( &lt;View style={{ marginTop: 20 }} &lt;TouchableOpacity onPress={this.didPress} &lt;TextLoad&lt;/Text &lt;/TouchableOpacity // 根据需要判断是否渲染该组件 {this.state.needsExpensive ? &lt;VeryExpensive / : null} &lt;/View ); } }","link":"/blog/2019/05/25/React-Native/React-Native页面优化实践/"},{"title":"Reat-Native拓展","text":"腾讯微信小程序注：手机QQ未来也预期会开放一套类似的开放平台 React Native 没有公开的文档在说明，但据打听和一些资料显示手机QQ和手机QQ浏览器都不同程度使用了 ReactNative，QQ浏览器是在首页的feed流使用了RN；其中手机QQ团队应该还在自研一套动态化技术方案（柏拉图），未来会开放。 百度轻应用百度在 2013 年百度世界大会上宣布推出“轻应用”（Light App），百度提供了配套基础设施将移动网站快速转化成轻应用。轻应用本质上是WebApp，类似微信的公众平台，用户体验受当年手机性能的极大制约，以至于后来日渐式微。 React Native → HtmlNative 贴吧微粉2016年曾经全量采用 React Native，在去年爆发 Facebook 协议事件之后，百度内部出现了大量替代 React Native的轮子，重写了部分涉及协议冲突的组件。目前手机百度采用 HtmlNative 方案，定制了 Webkit 的增强版。 京东-JDReact京东采用 React Native 的定制方案 JDReact，对 React Native的核心库做了裁剪和二次开发，搭建了后台功能支撑平台，同时结合京东的业务特点封装了包括 UI 在内的公共组件库，实现了三端融合，目前已经推广到了20多个业务。 携程-Ctrip React Native携程采用 React Native 的定制方案 CRN（Ctrip React Native），从2016年4月份开始，携程开始小范围使用 ReactNative，实现了站内信和机票低价订阅，随后开始大规模在各个 BU 推广，有超过15 个业务模块在使用，涉及页面在50个以上，据称已经达到了 85%的双端代码复用率。 去哪儿-Qunar React Native去哪儿采用 React Native 的定制方案 QRN（Qunar ReactNative），抹平了平台差异，降低了开发成本，广泛应用于机票、酒店等核心业务，据称已经达到了 95% 的双端代码复用率。 艺龙-Enjoy React Native艺龙采用 React Native 的定制方案 ERN，基于 web → Native 的思路，将纯 Html 标签转换为 Native组件，从而抹平了平台差异，降低开发成本。","link":"/blog/2019/05/25/React-Native/Reat-Native拓展/"},{"title":"TypeScript-跟-ReactNative-开发的关系","text":"你用 TypeScript 语法写的 .ts .tsx 等后缀的程序是不能直接运行的，而是会被 tsconfig.json 配置中的 “target”:“es6”, 这项配置转换为 es6 语法的 .js 文件。 TypeScript 中的 import 只会加载 .ts .tsx 后缀的文件，而 Javascript 中的 import 只能加载 .js等后缀的文件， 所以，当 ReactNative 启动时，首先加载入口文件，如 index.android.js ,代码如下： 12345678910 import{ AppRegistry } from&apos;react-native&apos;; importIndexNavigatorfrom&apos;./application/src/controller/navigator/IndexNavigator&apos;; AppRegistry.registerComponent(&apos;mogudan&apos;, () = IndexNavigator); 其中 import IndexNavigator from … 这一行加载的不是 IndexNavigator.ts 而是编译后生成的IndexNavigator.js 文件，下面对比两个文件的差异： IndexNavigator.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * Created by ZHOUZ on 2016-08-26. */ import* as React from&apos;react&apos;; import{Navigator} from&apos;react-native&apos;; importIndexPage from&apos;../page/IndexPage&apos; exportdefaultclassIndexNavigatorextendsReact.Component&lt;any,any { render() { let defaultName =&apos;IndexPage3311113&apos;; let defaultComponent = IndexPage; return( &lt;Navigator initialRoute={{ name: defaultName, component:defaultComponent }} configureScene={(route) =Navigator.SceneConfigs.VerticalDownSwipeJump } renderScene={(route: any, navigator) = { let Component =[route.component;](http://route.component%3B/) return&lt;Component {...route.params} navigator={navigator}/ }} / ); } } IndexNavigator.js 为自动编译后生成的es6语法的 javascript 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&quot;use strict&quot;; var__assign = (this&amp;&amp;this.__assign) ||Object.assign ||function(t){ for(vars, i =1, n =arguments.length; i &lt; n; i++) { s =arguments[i]; for(varpins)if(Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]; } returnt; }; /** * Created by ZHOUZ on 2016-08-26. */ constReact =require(&apos;react&apos;); constreact_native_1 =require(&apos;react-native&apos;); constIndexPage_1 =require(&apos;../page/IndexPage&apos;); classIndexNavigator extends[React.Component](http://react.component/){ render() { letdefaultName =&apos;IndexPage3311113&apos;; letdefaultComponent = IndexPage_1.default; return(React.createElement(react_native_1.Navigator, {initialRoute: {name: defaultName, component: defaultComponent }, configureScene: (route) =react_native_1.Navigator.SceneConfigs.VerticalDownSwipeJump, renderScene:(route, navigator) = { letComponent =[route.component;](http://route.component%3B/) returnReact.createElement(Component, __assign({}, route.params,{navigator: navigator})); }})); } } Object.defineProperty(exports,&quot;__esModule&quot;, { value:true}); exports.default = IndexNavigator;","link":"/blog/2019/05/25/React-Native/TypeScript-跟-ReactNative-开发的关系/"},{"title":"Weex&ReactNative对比","text":"weex开源有一段时间了，其实去年刚听说weex这个项目的时候，我就对它很感兴趣，很大程度上是因为我自己对vue的喜爱。我从13年左右开始接触vue，14年开始熟悉这个轻量的框架，并慢慢的推荐给了身边的朋友，当我得知手淘的weex是基于vue的时候，就有了想了解一下的冲动。在weex开源之前，我刚好有几个月的时间一直在致力于ReactNative的优化改造，加上自己之前使用ReactJS的一些经验，对于ReactNative项目也算有了一些自己的见解。趁着weex开源了，赶在前几天，我花了两三天的时间把weexandroid的源码完整的看了一遍，前端js代码也粗略看了一下，结合自己对ReactNative源码的一些了解，正好在这里对两者做一个尽量中立的比对。 首先，我们要承认，weex的确是站在ReactNative的肩膀上的，核心思想上两者并没有大的区别，直观的看上去，我认为有三个主要的区别： JS引擎weex使用V8， ReactNative使用JSCore JS开发框架weex基于vue.js(2W+ star)。小巧轻量的前端开发框架，组件化，数据绑定，2.0引入virtual dom。 ReactNative使用React(4W+ star)。革命性的前端开发框架，组件化，数据绑定，virtual dom。 Android版本要求ReactNative使用了Choreographer，因此必须在API16以上才可以使用。 weex使用handler来代替Choreographer，可以在API14以上使用。 weex出来的初衷也是为了解决ReactNative使用过程中遇到的一些问题，当然具体决定使用那个框架，我觉得需要从一下几个方面来做对比 学习成本1. 环境配置： ReactNative需要按照文档安装配置很多依赖的工具，相对比较麻烦。 weex安装cli之后就可以使用 2. vue vs react react模板JSX学习使用有一定的成本 vue更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css 3. 布局 两者实现了flexbox的相同子集（都使用了FaceBook的代码解析），基本没有区别 易用性1. sdk使用 ReactNative需要解决mvn依赖的问题，因此必须自己修改源码，打包发布 weex可以直接在mvn项目中使用 2 调试 都可以在chrome中调试JS代码 weex支持在chrome中预览页面dom节点，ReactNative不支持 3 页面开发 weex提供了一个playground，可以方便的预览正在开发的页面 ReactNative开发一个页面，需要建立一个native工程，然后编译运行 4 即时预览 weex和ReactNative都有提供hot reload功能，可以边更改代码，边在手机上看到效果 5 打包 ReactNative官方只能将ReactNative基础js库和业务js一起打成一个js bundle，没有提供分包的功能，需要制作分包打包工具 weex默认打的js bundle只包含业务js代码，体积小很多，基础js库包含在weex sdk中 6 部署 斑马目前同时支持weex和ReactNative页面，但是中心已经转向weex 另外斑马提供了可以拖拽搭建weex活动页面的功能 7 扩展性 组件的扩展上，weex和ReactNative具有一样的能力 三方库的接入上，weex对网络，图片，统计等常见的用户可能想自己定制的功能，提供了相应的适配接口，可以由用户方便的定制，ReactNative需要自己修改源码 8 集团库接入 weex有默认的mtop接入实现，UT接入实现 windvane也提供了对weex页面的支持，可以复用app中的web容器 9 跨平台 ReactNative支持Android iOS两个平台，需要自己扩展去支持web，windows和node-webkit的支持正在开发中 weex可以支持Android iOS web三个平台 10 Moudle方法调用线程 weex 可以通过注解标注是否在UI线程执行 ReactNative在native_modules线程执行 11 异步 weex只支持callback ReactNative提供了Promise的支持 性能1 分包加载 ReactNative需要自己实现，从而优化JS加载执行时间 weex默认提供分包实现 2 官方支持 ReactNative官方关注的重心目前并不在性能上 weex持续关注性能优化 3 大块view渲染 ReactNative默认没有优化机制，长view渲染性能会比较差 weex提供了node和tree两种渲染模式，优化长view的渲染 4 ListView Android ReactNative目前采用scrollView使用，有一些性能问题 weex使用recyclerview实现，性能稍好 社区ReactNative 3w+ star，issue，pull request， contributor多，社区活跃，围绕react产生了许多开发框架 weex开源较晚，目前只有4k+ start，contributor以阿里人为主，较少，issue和pull request也比较少，社区目前规模比较小 工具链1 debug tool 都有提供在chrome中调试的支持 2 打包工具 ReactNative需要自己改造 weex默认提供的足够满足使用需求 3 webpack，gulp，脚手架工程 weex有相应的插件，方便开发，部署使用 ReactNative有，但是很久未更新，需要自己维护 通过上面的一些对比，就我个人来说，我还是比较倾向于使用weex，我比较熟悉vue是一方面，另外性能和发布这一块也是我比较关注的点。使用ReactNative确实也可以做到不错，但是最终我发现，自己其实是在做weex团队已经做的事情。与其这样，为什么我不选择weex，去帮助weex解决一些其他问题，给自己留更多时间去做业务开发呢？另外从业务开发的角度，我也觉得weex的门槛相对比较低，更适合业务开发同学上手，简单就是不简单。 http://dev.bingocc.com/buiweex/docs/ http://weex.apache.org/cn/guide/","link":"/blog/2019/05/25/React-Native/Weex&ReactNative对比/"},{"title":"requestAnimationFrame帧动画","text":"前言动画是移动应用中的一个相当重要的组成部分，一个用户体验良好的应用通常都具有流畅、有意义的动画。类似原生平台，ReactNative也为我们提供了丰富的动画API：requestAnimationFrame、LayoutAnimation、Animated。 requestAnimationFrame:帧动画，是最容易实现的一种动画，通过不断改变组件的state值，从而在视觉上产生一种动画的效果，类似于gif动画的方式。 LayoutAnimation:布局动画，当布局发生改变时的动画模块，允许在全局范围内创建和更新动画，这些动画会在下一次渲染或布局周期运行，实现单个动画非常简洁，体验和性能良好。 Animated:用于创建更精细的交互控制的动画，可进行多个动画的组合动画，具备极高的性能，是功能最强大的动画API。 本节我们先介绍requestAnimationFrame。 requestAnimationFrame帧动画的实现requestAnimationFrame实现帧动画的原理非常粗暴简洁，即通过修改state值来不断得改变视图上的样式，从而在视觉上产生一种动画的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287import React, { Component } from&apos;react&apos;; import { AppRegistry, StyleSheet, Text, View, TouchableOpacity, Platform, } from&apos;react-native&apos;; exportdefaultclassFrameAnimationDemo extends Component { constructor(props){ super(props); this.state = { width:200, height:20, }; } _onPress() { //每按一次增加近30宽高 varcount =0; while(++count&lt;30){ requestAnimationFrame(()={ this.setState({ width:this.state.width +1, height:this.state.height +1 }); }) } } render() { return( &lt;Viewstyle={styles.container}&gt;&lt;Viewstyle={[styles.content,{width:this.state.width,height:this.state.height}]}&gt; &lt;Textstyle={[{textAlign:&apos;center&apos;}]}&gt;Hello World!&lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacitystyle={styles.content}onPress={this._onPress.bind(this)}&gt; &lt;Viewstyle={styles.button}&gt; &lt;Textstyle={styles.buttonText}Press me!&gt;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); } } const styles = StyleSheet.create({ container: { marginTop:25, flex: 1, }, content: { backgroundColor: &apos;rgba(200, 230, 255, 0.8)&apos;, marginBottom:10, justifyContent:&quot;center&quot;, alignSelf:&quot;center&quot;, }, button: Platform.select({ ios: {}, android: { elevation: 4, // Material design blue from https://material.google.com/style/color.html#color-color-palette backgroundColor: &apos;#2196F3&apos;, borderRadius: 2, width:100, height:30, }, justifyContent:&quot;center&quot;, alignSelf:&quot;center&quot;, }), buttonText: { alignSelf:&quot;center&quot;, } }); 从效果上看动画有种一顿一顿的感觉。这是由于通过修改state值，导致频繁地销毁、重绘视图，内存开销大，从而使得动画卡顿明显。另外对于帧动画而言，如果帧数较少，动画的效果会比较生硬，帧数过多又会引发性能问题。 优化如果帧动画的方式更符合当前对动画的控制方式，我们可以对上述方法做一点优化，在requestAnimationFrame中采用setNativeProps直接修改组件的属性并触发局部刷新，不会导致重绘组件，因此在性能上优于直接修改state的方法。 修改_onPress方法，将对this.setState的直接修改改为对”HelloWorld”按钮的属性修改this.refs.view1.setNativeProps。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849_onPress() { varcount =0; while(++count&lt;30){ requestAnimationFrame(()={ this.refs.view1.setNativeProps({ style: { width:this.state.width++, height:this.state.height++ } }); }); } } this.refs.view1指向的是”Hello World”文字的父视图。 12345678910&lt;View ref=&quot;view1&quot;style={[styles.content, {width:this.state.width,height:this.state.height}]}&gt; &lt;Textstyle={[{textAlign:&apos;center&apos;}]}&gt;Hello World!&lt;/Text&gt; &lt;/View&gt; 通过对比可以看出流畅顺滑多了。 每个动画API都有其适应和不适应的场景，如果要实现“弹性动画”，“缓入缓出”等效果，使用requestAnimationFrame还是比较难的，需要辅助各种函数。下一节将介绍另一种动画API——LayoutAnimation。 GitHub地址","link":"/blog/2019/05/25/React-Native/requestAnimationFrame帧动画/"},{"title":"控制组件显示与否的问题小结","text":"问题说明在开发React Native过程中，我们常常会根据一个变量的值是否为空来控制组件的显示与否。 一个简单的做法是{ someVariable &amp;&amp; some text } 今天就因为写了这样的代码踩到了一个坑，导致App Crash了。 Error内容：RawText “” must be wrapped in an explicitcomponent. 分析了一波，发现是数据问题导致的。当下面的代码中someVariable的值为空字符串’’的时候，就会出现这种Error。 { someVariable &amp;&amp; some text } 测试结果为了分析这个问题，针对someVariable为空的情况做了一些测试，结果如下： case 1.{ ‘’ &amp;&amp; some text }=&gt;有Error，App会Crash case 2.{ 0 &amp;&amp; some text }=&gt;有Error，App会Crash case 3.{ null &amp;&amp; some text }=&gt; 没有Error,组件不会显示 case 4.{ undefined &amp;&amp; some text }=&gt; 没有Error,组件不会显示 case 5.{ NaN &amp;&amp; some text }=&gt;有Error，App会Crash case 6.{ [] &amp;&amp; some text }=&gt; 没有Error,组件会显示 case 7.{ {} &amp;&amp; some text }=&gt; 没有Error,组件会显示 原因分析为什么会出现以上结果呢？ 为了分析这个问题首先需要明白expr1 &amp;&amp; expr2的含义。 这个表达式是说当expr1为false的时候，会返回expr1，否则会返回expr2。 那么’’|0|null|undefined|NaN|[]|{}这些值到底是true还是false呢，我们可以在ChromeConsole上面通过两个非操作!!来测试一下。 从上面结果可以看到，’’|0|null|undefined|NaN的值是false，[]|{}的值为true。 好了，通过以上分析我们可以得到case 1 ~ case 6的结果如下： case 1.{ ‘’ &amp;&amp; some text }=&gt;{ ‘’ } case 2.{ 0 &amp;&amp; some text }=&gt;{ 0 } case 3.{ null &amp;&amp; some text }=&gt;{ null } case 4.{ undefined &amp;&amp; some text }=&gt;{ undefined } case 5.{ NaN &amp;&amp; some text }=&gt;{ NaN } case 6.{ [] &amp;&amp; some text }=&gt;{ some text } case 7.{ {} &amp;&amp; some text }=&gt;{ some text } 在React Native中{ ‘’ }|{ 0 }|{ NaN }会被当做文本字符串，必须要包含在组件中，所以case 1、case2、case 5会导致App Crash；case 3、case 4不会报错，也不会在页面上显示任何东西；case 5、case 6会在页面上显示sometext文本。 解决方案为了规避App Crash的风险，有两个简单的方案来实现【根据变量的值是否为空来控制组件的显示与否】： 1.当变量类型为Object或Array时，可以使用lodash的isEmpty方法 { !_.isEmpty(someVariable) &amp;&amp; some text } 2.当变量为其他类型时，使用两个非操作 { !!someVariable &amp;&amp; some text }","link":"/blog/2019/05/25/React-Native/控制组件显示与否的问题小结/"},{"title":"把代码混淆过的游戏反混淆回来","text":"最近一直在找如何在MAC上混淆Android的DLL，至今没能找到合适的，有大神知道记得告诉我喔。今天群里有人说了一个混淆代码和返混淆代码的工具de4dot，不查不知道一查吓一跳。这玩意可以把别人混淆过的代码反混淆回来。 这个工程是开源的https://github.com/0xd4d/de4dot 找一台Windows电脑，下载后在VS上面打开它，另外它不能直接编译，需要在引入一个库文件。为了方便大家我把能正常编译的工程提供出来。 下载地址：http://pan.baidu.com/s/1ntjw3mL 如下图所示，打开工程后在VS里面快捷键F6，编译完成后会生成出来de4dot.exe。那么我们返混淆就是通过这个exe来将unity生成的dll返混淆回来。 经过混淆的代码反编译后。 反混淆以后，如下图所示，属性名子就出来了。但是方法名就回不来了，都是按数字一次加上去，不过这些总比方括号好看多了。而且我看了一下内容，有些方法内容奇葩的地方也都解的至少能看。 在Windows里面的cmd里面输入 de4dot.exe test.dll -p un 另外你随便下载一个用Unity做的安卓游戏，然后把apk解开把里面的Assembly-CSharp.dll找出来，它的代码都在里面。如果它的代码没有做混淆工作，那么可以直接反编译出来。 如下图所示，返混淆会在原始dll的目录下生成一个后缀-cleaned.dll的文件。然后用反编译工具打开它即可。 de4dot看起来应该是非常强大，他支持返混淆这么多工具。。我就不一个一个试了，希望阅读本文的你帮我做一下测试，看看是不是所有混效果的Unity游戏都可以解开。 Agile.NET (aka CliSecure) Babel.NET CodeFort CodeVeil CodeWall CryptoObfuscator DeepSea Obfuscator Dotfuscator .NET Reactor Eazfuscator.NET Goliath.NET ILProtector MaxtoCode MPRESS Rummage Skater.NET SmartAssembly Spices.Net Xenocode de4dot不仅仅可以返混淆，它也可以自身去混淆。。大家可以看看它的gitHub上的介绍，哎 又是一个必须在Windwos上完成的操作。。今天把研究成果发出来，希望大家多多测试一下，看看能不能把所有混淆过的Unity游戏返混淆回来。 另外有什么最近进展大家一定要告诉我呀。。嘿嘿嘿嘿。 雨松MOMO提醒您：亲，如果您觉得本文不错，快快将这篇文章分享出去吧 。另外请点击网站顶部彩色广告或者捐赠支持本站发展，谢谢！ 作者：雨松MOMO","link":"/blog/2019/05/17/CSharp/把代码混淆过的游戏反混淆回来/"},{"title":"C#字符串连接的效率问题","text":"C#字符串连接常用的四种方式：StringBuilder、+、string.Format、List。 1.+的方式12string sql = &quot;update tableName set int1=&quot; + int1.ToString() + &quot;,int2=&quot; +int2.ToString() + &quot;,int3=&quot; + int3.ToString() + &quot; where id=&quot; + id.ToString(); 编译器会优化为： 123string sql = string.Concat(new string[] { &quot;update tableName set int1=&quot;,int1.ToString(), &quot;,int2=&quot;, int2.ToString(), &quot;,int3=&quot;, int3.ToString(), &quot; whereid=&quot;, id.ToString() }); 下面是string.Concat的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public static string Concat(params string[] values){ int totalLength = 0; if (values == null) { throw new ArgumentNullException(&quot;values&quot;); } string[] strArray = new string[values.Length]; for (int i = 0; i &lt; values.Length; i++) { string str = values[i]; strArray[i] = (str == null) ? Empty : str; totalLength += strArray[i].Length; if (totalLength &lt; 0) { throw new OutOfMemoryException(); } } return ConcatArray(strArray, totalLength);}private static string ConcatArray(string[] values, int totalLength){ string dest = FastAllocateString(totalLength); int destPos = 0; for (int i = 0; i &lt; values.Length; i++) { FillStringChecked(dest, destPos, values[i]); destPos += values[i].Length; } return dest;}private static unsafe void FillStringChecked(string dest, int destPos,string src){ int length = src.Length; if (length(dest.Length - destPos)) { throw new IndexOutOfRangeException(); } fixed (char* chRef = &amp;dest.m_firstChar) { fixed (char* chRef2 = &amp;src.m_firstChar) { wstrcpy(chRef + destPos, chRef2, length); } }} 先计算目标字符串的长度，然后申请相应的空间，最后逐一复制，时间复杂度为o(n)，常数为1。固定数量的字符串连接效率最高的是+。但是字符串的连+不要拆成多条语句，比如： 123string sql = &quot;update tableName set int1=&quot;;sql += int1.ToString();sql += ... 这样的代码，不会被优化为string.Concat，就变成了性能杀手，因为第i个字符串需要复制n-i次，时间复杂度就成了o(n^2)。 2.StringBuilder的方式如果字符串的数量不固定，就用StringBuilder，一般情况下它使用2n的空间来保证o(n)的整体时间复杂度，常数项接近于2。 因为这个算法的实用与高效，.net类库里面有很多动态集合都采用这种牺牲空间换取时间的方式，一般来说效果还是不错的。 3.string.Format的方式它的底层是StringBuilder，所以其效率与StringBuiler相似。 # 4.List它可以转换为string[]后使用string.Concat或string.Join，很多时候效率比StringBuiler更高效。 List与StringBuilder采用的是同样的动态集合算法，时间复杂度也是O(n)，与StringBuilder不同的是：List的n是字符串的数量，复制的是字符串的引用；StringBuilder的n是字符串的长度，复制的数据。不同的特性决定的它们各自的适应环境，当子串比较大时建议使用List，因为复制引用比复制数据划算。而当子串比较小，比如平均长度小于8，特别是一个一个的字符，建议使用StringBuilder。 总结：1&gt;固定数量的字符串连接+的效率是最高的； 2&gt;当字符串的数量不固定，并且子串的长度小于8，用StringBuiler的效率高些。 3&gt;当字符串的数量不固定，并且子串的长度大于8，用List的效率高些。","link":"/blog/2019/05/17/CSharp/CSharp字符串连接的效率问题/"},{"title":"文件I-O优化技巧","text":"一般来说，所有工程都会有对文件进行读写的操作。如果你不仅是要存储少量字节（例如JSON文件），就有必要考虑性能问题了。因为这种情况下很容易写出低效率的文件读写代码，而且编译器和Unity都无法帮助你优化。今天这篇文章将分享文件读写代码中一些常见的误区，希望对大家有所帮助。 .NETAPI提供了很多完善的写入文件系统相关的类。Stream抽象类和其子类FileStream，还有File类，带有静态函数Open以及很方便的读写函数如BinaryReader和BinaryWriter。C#语言本身提供了using语法可以方便地关闭文件流、文件读写对象实例和文件句柄。这类代码使用便利，安全系数高，容易实现： 基本来说，文件操作可以归纳为以下五个步骤： 打开文件：File.Open 读取字节：stream.Read 写入字节：stream.Write 查询位置： stream.Position 或 stream.Seek 关闭文件：stream.Dispose 或 stream.Close 如果反编译FileStream类，你会发现stream.Position和stream.Seek其实没有什么区别，仅仅是API叫法上的不同。还有，stream.Dispose和stream.Close也基本上没什么区别，都能关掉文件。 得益于streams，readers，writers的便利性，想要测试它们的性能也很方便。进行读写操作只需调用一个函数即可，但这些读写操作函数的性能消耗可大不相同。接下来我针对这些不同的读写方式写了一个测试程序，下面是程序将要做的工作： 写入20MB，每次写入4KB的数据块 写入20MB，每次写入1字节 读取20MB，每次读取4KB的数据块 读取20MB，每次读取1字节 数次查找流的某个位置，次数与数据块的读写次数相同 数次打开某个文件，次数与数据块的读写次数相同 测试脚本如下： 新建Unity工程，在Assets目录下新建TestScript.cs脚本并复制以上代码。然后在默认的空场景中将TestScript附加到Camera游戏对象上，最后编译。注意编译平台使用64位，在非Development模式下编译，画质设置为最快，分辨率设为最低（640x480）。测试环境如下： 2.3 Ghz Intel Core i7-3615QM Mac OS X 10.11.2 Apple SSD SM256E, HFS+ format Unity 5.3.0f4, Mac OS X Standalone, x86_64, non-development 640×480, Fastest, Windowed 测试结果如下： 真是有着天壤之别，因此我单独提取出了最快的三个数据，得到了第二张图表。 可以看出，以数据块的方式进行读写操作的效率非常之高。虽然你可能不会一个一个字节地去写，但却有可能以4字节（整数）或类似大小为数据块单位进行写入操作。所以尽可能以较大的数据块为单位进行操作，这将提高38倍的写入效率，205倍的读取效率！ 流查找（不论设置Position或调用Seek）不会进行字节读写，但这种操作是有代价的，虽然没有其它类型的操作那样多，它需要相当于读取4KB数据块三分之一的资源。所以最好避免这种查找操作，尽量线性读写文件，这样才能在各层面最大限度地发挥缓存的优势。 最后，打开或关闭文件同样不需要读取任何字节，但需要的时间会很长。事实证明，非常之长！打开和关闭文件需要的时间是以字节块写入整个文件所需时间的6.5倍，是字节块方式读取整个文件所需时间的40倍。考虑到读写操作的重要性，以及打开和关闭文件是操作系统的唯一需求，所以，除非特别需要，不要打开关闭文件。而且操作大文件要比操作多个小文件更好。 以上包括了关于I/O性能的一些建议，如有疑问，欢迎来下方评论区留言。 本文来源于：jacksondunstan.com 原作者：Jackson Dunstan","link":"/blog/2019/05/17/CSharp/文件I-O优化技巧/"},{"title":"推荐React-Native-开源移动-UI-组件","text":"React Native 是近期 Facebook 基于 MIT 协议开源的原生移动应用开发框架，已经用于 Facebook 的生产环境。ReactNative 可以使用最近非常流行的React.js库来开发 iOS和 Android 原生 APP。 iOS 表单处理控件 tcomb-form-nativetcomb-form-native是 React Native强大的表单处理控件，支持 JSON 模式，可插拔的外观和感觉。在线演示：&lt;http://react.rocks/example/tcomb-form-native&gt;。 摄像机视图 react-native-camerareact-native-camera是 ReactNative 的摄像头 viewport。这个模块应用于开发的早期阶段，它支持摄像头的转换和基本图片捕捉。 使用示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118var React = require(&apos;react-native&apos;);var { AppRegistry, StyleSheet, Text, View,} = React;var Camera = require(&apos;react-native-camera&apos;);var cameraApp = React.createClass({ render: function() { return ( &lt;View &lt;TouchableHighlight onPress={this._switchCamera}&gt; &lt;View&gt; &lt;Camera&gt; ref=&quot;cam&quot; aspect=&quot;Stretch&quot; orientation=&quot;PortraitUpsideDown&quot; style={{height: 200, width: 200}} /&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); }, _switchCamera: function() { this.refs.cam.switch(); }});AppRegistry.registerComponent(&apos;cameraApp&apos;, () = cameraApp); react-native-videoreact-native-video是Video标签控件。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Within your render function, assuming you have a file called // &quot;background.mp4&quot; in your project &lt;Video source={&quot;background&quot;} style={styles.backgroundVideo} repeat={true} /&gt; // Later on in your styles.. var styles = Stylesheet.create({ backgroundVideo: { resizeMode: &apos;cover&apos;, // stretch and contain also supported position: &apos;absolute&apos;, top: 0, left: 0, bottom: 0, right: 0, }, }); 导航控件 react-native-navbarreact-native-navbar是用于 ReactNative 上简单的定制化导航栏。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var NavigationBar = require(&apos;react-native-navbar&apos;); var ExampleProject = React.createClass({ renderScene: function(route, navigator) { var Component = route.component; var navBar = route.navigationBar; if (navBar) { navBar = React.addons.cloneWithProps(navBar, {navigator: navigator, route: route }); } return (&lt;View style={styles.navigator} {navBar}&lt;Component navigator={navigator} route={route} / &lt;/View ); }, render: function() {return (&lt;Navigator style={styles.navigator} renderScene={this.renderScene} initialRoute={{ component: InitialView, navigationBar: &lt;NavigationBar title=&quot;Initial View&quot;/ }} / ); } }); React Native 轮播控件 react-native-carouselreact-native-carousel是一个简单的React Native 轮播控件。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243var Carousel = require(&apos;react-native-carousel&apos;);var ExampleProject =React.createClass({ render() { return ( &lt;Carousel width={375} indicatorColor=&quot;#ffffff&quot;inactiveIndicatorColor=&quot;#999999&quot;&gt; &lt;MyFirstPage /&gt; &lt;MySecondPage /&gt; &lt;MyThirdPage /&gt; &lt;/Carousel&gt; ); } }); 下拉刷新组件 react-native-refreshable-listview[react-native-refreshable-listview](http://www.oschina.net/p/react-native-refreshable-listview)是下拉刷新 ListView，当数据重载的时候显示加载提示。 Modal 组件 react-native-modalreact-native-modal是 ReactNative 的 &lt;Modal 组件。 文本解析控件 react-native-htmltextreact-native-htmltext可以用HTML 像 markup 一样在 ReactNative 里创建出相应效果的样式文本。ReactNative 为那些样式文本提供一个文本元素，用于取代NSAttributedString，你可以创建嵌套的文本： 12345678910111213&lt;Text style={{fontWeight: &apos;bold&apos;}}&gt; I am bold &lt;Text style={{color: &apos;red&apos;}}&gt; and red &lt;/Text&gt; &lt;/Text&gt; react-native-htmlviewreact-native-htmlview是一个将HTML 目录作为本地视图的控件，其风格可以定制。 LinearGradient 组件 react-native-linear-gradient[react-native-linear-gradient](http://www.oschina.net/p/react-native-linear-gradient)是一个 React Native 的 LinearGradient 组件。 双向循环播放 react-native-looped-carousel[react-native-looped-carousel](http://www.oschina.net/p/react-native-looped-carousel)是基于 React Native 的双向循环播放控件。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&apos;use strict&apos;;var React = require(&apos;react-native&apos;);var Carousel = require(&apos;react-native-looped-carousel&apos;);var Dimensions = require(&apos;Dimensions&apos;);var{width, height} = Dimensions.get(&apos;window&apos;);var { AppRegistry, StyleSheet, Text, View } = React;var carouselTest = React.createClass({ render: function() {return ( &lt;Carousel delay={500}&gt; &lt;Viewstyle={{backgroundColor:&apos;#BADA55&apos;,width:width,height:height}}/&gt; &lt;View style={{backgroundColor:&apos;red&apos;,width:width,height:height}}/&gt; &lt;View style={{backgroundColor:&apos;blue&apos;,width:width,height:height}}/&gt; &lt;/Carousel&gt; ); } }); AppRegistry.registerComponent(&apos;carouselTest&apos;, () = carouselTest); TeasetReact Native UI 组件库 https://github.com/rilyu/teaset/blob/master/docs/cn/README.md 如果你知道其他 React Native 插件，在评论与大家分享一下吧～","link":"/blog/2019/05/25/React-Native/推荐React-Native-开源移动-UI-组件/"},{"title":"通过C#使用Advanced-CSharp-Messenger","text":"Advanced CSharp Messenger 属于C#事件的一种。维基百科中由详细的说明&lt;http://wiki.unity3d.com/index.php?title=Advanced_CSharp_Messenger上周的一天刚巧有朋友问到我这一块的知识，那么我研究出来将它贴在博客中，帮助了他也帮助我自己！哇咔咔。 Advanced CSharp Messenger的特点可以将游戏对象做为参数发送。到底Advanced CSharpMessenger有什么用呢？先创建一个立方体对象，然后把Script脚本绑定在这个对象中。脚本中有一个方法叫DoSomething()。写一段简单的代码，通常我们在调用方法的时候需要这样来写。 C# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Script script; void Awake() { GameObject cube = GameObject.Find(&quot;Cube&quot;); script = cube.GetComponent&lt;Script(); } void Update() { if(Input.GetMouseButtonDown(0)) { script.DoSomething(); } } 代码比较简单，我就不注释了。原理就是先获取游戏对象，接着获取脚本组件对象，最后通过脚本组件对象去调用对应脚本中的方法，这样的调用方法我们称之为直接调用。 这个例子中我只调用了一个对象的方法，如果说有成千上万个对象，那么这样调用是不是感觉自己的代码非常的丑？因为你需要一个一个的获取对象然后获取脚本组件然后在调用方法。。。。。（想想都恐怖！！） 下面我们在用Advanced CSharp Messenger来实现事件的调用。按照维基百科中首先把Message.cs和Callback.cs拷贝在你的工程中。 CallBack.cs C# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333public delegate void Callback(); public delegate void Callback&lt;T(T arg1); public delegate void Callback&lt;T, U(T arg1, U arg2); public delegate void Callback&lt;T, U, V(T arg1, U arg2, V arg3);**Message.cs**C# /* * Advanced C# messenger by Ilya Suzdalnitski. V1.0 * * Based on Rod Hyde&apos;s &quot;CSharpMessenger&quot; and Magnus Wolffelt&apos;s&quot;CSharpMessenger Extended&quot;. * * Features: * Prevents a MissingReferenceException because of a reference to a destroyedmessage handler. * Option to log all messages * Extensive error detection, preventing silent bugs * * Usage examples: 1\\. Messenger.AddListener&lt;GameObject(&quot;prop collected&quot;, PropCollected); Messenger.Broadcast&lt;GameObject(&quot;prop collected&quot;, prop); 2\\. Messenger.AddListener&lt;float(&quot;speed changed&quot;, SpeedChanged); Messenger.Broadcast&lt;float(&quot;speed changed&quot;, 0.5f); * * Messenger cleans up its evenTable automatically upon loading of a newlevel. * * Don&apos;t forget that the messages that should survive the cleanup, should bemarked with Messenger.MarkAsPermanent(string) * */ //#define LOG_ALL_MESSAGES //#define LOG_ADD_LISTENER //#define LOG_BROADCAST_MESSAGE #define REQUIRE_LISTENER using System; using System.Collections.Generic; using UnityEngine; static internal class Messenger { #region Internal variables //Disable the unused variable warning #pragma warning disable 0414 //Ensures that the MessengerHelper will be created automatically upon startof the game. static private MessengerHelper messengerHelper = ( newGameObject(&quot;MessengerHelper&quot;) ).AddComponent&lt; MessengerHelper (); #pragma warning restore 0414 static public Dictionary&lt;string, Delegate eventTable = newDictionary&lt;string, Delegate(); //Message handlers that should never be removed, regardless of callingCleanup static public List&lt; string permanentMessages = new List&lt; string (); #endregion #region Helper methods //Marks a certain message as permanent. static public void MarkAsPermanent(string eventType) { #if LOG_ALL_MESSAGES Debug.Log(&quot;Messenger MarkAsPermanent \\t\\&quot;&quot; + eventType + &quot;\\&quot;&quot;); #endif permanentMessages.Add( eventType ); } static public void Cleanup() { #if LOG_ALL_MESSAGES Debug.Log(&quot;MESSENGER Cleanup. Make sure that none of necessary listeners areremoved.&quot;); #endif List&lt; string messagesToRemove = new List&lt;string(); foreach (KeyValuePair&lt;string, Delegate pair in eventTable) { bool wasFound = false; foreach (string message in permanentMessages) { if (pair.Key == message) { wasFound = true; break; } } if (!wasFound) messagesToRemove.Add( pair.Key ); } foreach (string message in messagesToRemove) { eventTable.Remove( message ); } } static public void PrintEventTable() { Debug.Log(&quot;\\t\\t\\t=== MESSENGER PrintEventTable ===&quot;); foreach (KeyValuePair&lt;string, Delegate pair in eventTable) { Debug.Log(&quot;\\t\\t\\t&quot; + pair.Key + &quot;\\t\\t&quot; + pair.Value); } Debug.Log(&quot;\\n&quot;); } #endregion #region Message logging and exception throwing static public void OnListenerAdding(string eventType, DelegatelistenerBeingAdded) { #if LOG_ALL_MESSAGES || LOG_ADD_LISTENER Debug.Log(&quot;MESSENGER OnListenerAdding \\t\\&quot;&quot; + eventType + &quot;\\&quot;\\t{&quot; +listenerBeingAdded.Target + &quot; - &quot; + listenerBeingAdded.Method + &quot;}&quot;); #endif if (!eventTable.ContainsKey(eventType)) { eventTable.Add(eventType, null ); } Delegate d = eventTable[eventType]; if (d != null &amp;&amp; d.GetType() != listenerBeingAdded.GetType()) { throw new ListenerException(string.Format(&quot;Attempting to addlistener with inconsistent signature for event type {0}. Current listenershave type {1} and listener being added has type {2}&quot;, eventType,d.GetType().Name, listenerBeingAdded.GetType().Name)); } } static public void OnListenerRemoving(string eventType, DelegatelistenerBeingRemoved) { #if LOG_ALL_MESSAGES Debug.Log(&quot;MESSENGER OnListenerRemoving \\t\\&quot;&quot; + eventType + &quot;\\&quot;\\t{&quot; +listenerBeingRemoved.Target + &quot; - &quot; + listenerBeingRemoved.Method + &quot;}&quot;); #endif if (eventTable.ContainsKey(eventType)) { Delegate d = eventTable[eventType]; if (d == null) { throw new ListenerException(string.Format(&quot;Attempting toremove listener with for event type \\&quot;{0}\\&quot; but current listener is null.&quot;,eventType)); } else if (d.GetType() != listenerBeingRemoved.GetType()) { throw new ListenerException(string.Format(&quot;Attempting toremove listener with inconsistent signature for event type {0}. Currentlisteners have type {1} and listener being removed has type {2}&quot;, eventType,d.GetType().Name, listenerBeingRemoved.GetType().Name)); } } else { throw new ListenerException(string.Format(&quot;Attempting to removelistener for type \\&quot;{0}\\&quot; but Messenger doesn&apos;t know about this event type.&quot;,eventType)); } } static public void OnListenerRemoved(string eventType) { if (eventTable[eventType] == null) { eventTable.Remove(eventType); } } static public void OnBroadcasting(string eventType) { #if REQUIRE_LISTENER if (!eventTable.ContainsKey(eventType)) { throw new BroadcastException(string.Format(&quot;Broadcasting message\\&quot;{0}\\&quot; but no listener found. Try marking the message withMessenger.MarkAsPermanent.&quot;, eventType)); } #endif } static public BroadcastExceptionCreateBroadcastSignatureException(string eventType) { return new BroadcastException(string.Format(&quot;Broadcasting message\\&quot;{0}\\&quot; but listeners have a different signature than the broadcaster.&quot;,eventType)); } public class BroadcastException : Exception { public BroadcastException(string msg) : base(msg) { } } public class ListenerException : Exception { public ListenerException(string msg) : base(msg) { } } #endregion #region AddListener //No parameters static public void AddListener(string eventType, Callback handler) { OnListenerAdding(eventType, handler); eventTable[eventType] = (Callback)eventTable[eventType] + handler; } //Single parameter static public void AddListener&lt;T(string eventType, Callback&lt;T handler) { OnListenerAdding(eventType, handler); eventTable[eventType] = (Callback&lt;T)eventTable[eventType] +handler; } //Two parameters static public void AddListener&lt;T, U(string eventType, Callback&lt;T, Uhandler) { OnListenerAdding(eventType, handler); eventTable[eventType] = (Callback&lt;T, U)eventTable[eventType] +handler; } //Three parameters static public void AddListener&lt;T, U, V(string eventType, Callback&lt;T, U, Vhandler) { OnListenerAdding(eventType, handler); eventTable[eventType] = (Callback&lt;T, U, V)eventTable[eventType] +handler; } #endregion #region RemoveListener //No parameters static public void RemoveListener(string eventType, Callback handler) { OnListenerRemoving(eventType, handler); eventTable[eventType] = (Callback)eventTable[eventType] - handler; OnListenerRemoved(eventType); } //Single parameter static public void RemoveListener&lt;T(string eventType, Callback&lt;T handler){ OnListenerRemoving(eventType, handler); eventTable[eventType] = (Callback&lt;T)eventTable[eventType] -handler; OnListenerRemoved(eventType); } //Two parameters static public void RemoveListener&lt;T, U(string eventType, Callback&lt;T, Uhandler) { OnListenerRemoving(eventType, handler); eventTable[eventType] = (Callback&lt;T, U)eventTable[eventType] -handler; OnListenerRemoved(eventType); } //Three parameters static public void RemoveListener&lt;T, U, V(string eventType, Callback&lt;T, U,V handler) { OnListenerRemoving(eventType, handler); eventTable[eventType] = (Callback&lt;T, U, V)eventTable[eventType] -handler; OnListenerRemoved(eventType); } #endregion #region Broadcast //No parameters static public void Broadcast(string eventType) { #if LOG_ALL_MESSAGES || LOG_BROADCAST_MESSAGE Debug.Log(&quot;MESSENGER\\t&quot; + System.DateTime.Now.ToString(&quot;hh:mm:ss.fff&quot;) +&quot;\\t\\t\\tInvoking \\t\\&quot;&quot; + eventType + &quot;\\&quot;&quot;); #endif OnBroadcasting(eventType); Delegate d; if (eventTable.TryGetValue(eventType, out d)) { Callback callback = d as Callback; if (callback != null) { callback(); } else { throw CreateBroadcastSignatureException(eventType); } } } //Single parameter static public void Broadcast&lt;T(string eventType, T arg1) { #if LOG_ALL_MESSAGES || LOG_BROADCAST_MESSAGE Debug.Log(&quot;MESSENGER\\t&quot; + System.DateTime.Now.ToString(&quot;hh:mm:ss.fff&quot;) +&quot;\\t\\t\\tInvoking \\t\\&quot;&quot; + eventType + &quot;\\&quot;&quot;); #endif OnBroadcasting(eventType); Delegate d; if (eventTable.TryGetValue(eventType, out d)) { Callback&lt;T callback = d as Callback&lt;T; if (callback != null) { callback(arg1); } else { throw CreateBroadcastSignatureException(eventType); } } } //Two parameters static public void Broadcast&lt;T, U(string eventType, T arg1, U arg2) { #if LOG_ALL_MESSAGES || LOG_BROADCAST_MESSAGE Debug.Log(&quot;MESSENGER\\t&quot; + System.DateTime.Now.ToString(&quot;hh:mm:ss.fff&quot;) +&quot;\\t\\t\\tInvoking \\t\\&quot;&quot; + eventType + &quot;\\&quot;&quot;); #endif OnBroadcasting(eventType); Delegate d; if (eventTable.TryGetValue(eventType, out d)) { Callback&lt;T, U callback = d as Callback&lt;T, U; if (callback != null) { callback(arg1, arg2); } else { throw CreateBroadcastSignatureException(eventType); } } } //Three parameters static public void Broadcast&lt;T, U, V(string eventType, T arg1, U arg2,V arg3) { #if LOG_ALL_MESSAGES || LOG_BROADCAST_MESSAGE Debug.Log(&quot;MESSENGER\\t&quot; + System.DateTime.Now.ToString(&quot;hh:mm:ss.fff&quot;) +&quot;\\t\\t\\tInvoking \\t\\&quot;&quot; + eventType + &quot;\\&quot;&quot;); #endif OnBroadcasting(eventType); Delegate d; if (eventTable.TryGetValue(eventType, out d)) { Callback&lt;T, U, V callback = d as Callback&lt;T, U, V; if (callback != null) { callback(arg1, arg2, arg3); } else { throw CreateBroadcastSignatureException(eventType); } } } #endregion } //This manager will ensure that the messenger&apos;s eventTable will be cleanedup upon loading of a new level. public sealed class MessengerHelper : MonoBehaviour { void Awake () { DontDestroyOnLoad(gameObject); } //Clean up eventTable every time a new level loads. public void OnDisable() { Messenger.Cleanup(); } } 然后就可以开始使用了，Messager.Broadcast()这样就好比我们发送了一条广播。 C# 12345678910111213141516171819202122232425void Update() { if(Input.GetMouseButtonDown(0)) { Messenger.Broadcast(&quot;Send&quot;); } } 在需要这条广播的类中来接受它，同样是刚刚说的Script类。接受广播的标志是Messager.AddListener()参数1表示广播的名称，参数2表示广播所调用的方法。 C# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine; using System.Collections; public class Script : MonoBehaviour { void Awake() { Messenger.AddListener( &quot;Send&quot;, DoSomething ); } public void DoSomething() { Debug.Log(&quot;DoSomething&quot;); } } 这样一来，只要发送名称为”Send”的方法，就可以在别的类中接收它了。 我们在说说如何通过广播来传递参数,这也是那天那个哥们主要问我的问题。（其实是维基百科上写的不是特别特别的清楚，那哥们误解了）在Callback中可以看出参数最多可以是三个，参数的类型是任意类型，也就是说我们不仅能传递int float bool 还能传递gameObject类型。 如下所示，发送广播的时候传递了两个参数，参数1是一个游戏对象，参数2是一个int数值。 C# 1234567891011121314151617181920212223242526272829void Update() { if(Input.GetMouseButtonDown(0)) { GameObject cube = GameObject.Find(&quot;Cube&quot;); Messenger.Broadcast&lt;GameObject,int(&quot;Send&quot;,cube,1980); } } 然后是接受的地方 参数用 &lt;存在一起。游戏对象也可以完美的传递。 C# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using UnityEngine; using System.Collections; public class Script : MonoBehaviour { void Awake() { Messenger.AddListener&lt;GameObject,int( &quot;Send&quot;, DoSomething ); } public void DoSomething(GameObject obj,int i) { Debug.Log(&quot;name &quot; + obj.name + &quot; id =&quot; + i); } } 如果传递一个参数 两个参数 &lt;T,T&gt; 三个参数 &lt;T,T,T&gt; 怎么样使用起来还是挺简单的吧？ 我觉得项目中最好不要大量的使用代理事件这类的方法（根据需求而定），虽然可以让你的代码非常的简洁，但是它的效率不高大概比直接调用慢5-倍左右吧，就好比美好的东西一定都有瑕疵一样。还记得Unity自身也提供了一种发送消息的方法吗？，用过的都知道效率也非常低下，虽然我们看不到它具体实现的源码是如何实现的，但是我觉得原理可能也是这样的。欢迎和大家一起讨论与学习。","link":"/blog/2019/05/17/CSharp/通过CSharp使用Advanced-CSharp-Messenger/"},{"title":"5分钟使用Unity制作AR应用","text":"今天这篇课程将为大家介绍使用Unity结合VuforiaSDK制作AR应用的过程，非常简单且容易上手，适合Unity初学者。最后效果是制作出向上跳跃的Unity酱。 注意：本文教程使用Unity 5.3.4制作，Unity编辑器及Android设备测试通过。 第一步 注册Vuforia首先需要到Vuforia官网进行注册，注册成功后跳转至License Manager页面。 然后点击“Add LicenseKey”按钮创建许可证，创建过程中需要输入应用名称、设备及许可证类型。这里应用名称任意填写，设备选择Mobile，许可证类型使用免费版即可。 点击下一步并同意条款后再点击“Confirm”按钮确认注册应用。成功注册后点击应用会显示License Key，后面会用到。 第二步 下载SDK并导入Unity在Vuforia官网的下载页面找到Download forUnity下载供Unity使用的SDK，本文使用最新版5.5.9。下载完成后双击打开文件，点击“Import”按钮将下载的SDK导入Unity项目。 第三步 添加并设置ARCamera新建场景并将Prefabs文件夹下的ARCamera预设体拖拽至场景，如下： 将Vuforia网页上的License Key信息复制到Vuforia Behaviour脚本的App License Key字段，如下： 第四步 添加识别标记首先挑一张分辨率高且比较有特点（尽量少有重复）的图。 然后打开Vuforia网页的Target Manager网页点击“AddDatabase”按钮，随意填写名称并选择类型为“Device”。点击新创建的Database名称，会出现Add Target界面，设置如下： 将Width设为1并随意命名后点击“Add”按钮。回到列表页会发现Database中多了个5星级的识别标记。 点击页面上的“Download Dataset(All)”按钮，选择开发平台为Unity Editor后下载该资源。 将下载的资源导入Unity项目，然后选中层级视图中的ARCamera，勾选Database Load Behaviour脚本下的“Load XXDatabase”与“Active”。 将Prefabs文件夹下的ImageTarget预设体拖拽至场景，然后点击Image TargetBehaviour脚本下的“Type”下拉列表，将类型设为“Predefined”，分别在“Database”和“ImageTarget”下拉列表中选择之前创建的Database和识别标记。此时场景示意图如下： 第五步 添加目标物体接下来将UnityChan的模型作为目标物体添加为ImageTarget的子对象，可以按照自己的喜好调整UnityChan的位置及旋转角度或添加动画等。UnityChan的模型资源可在AssetStore中免费下载，添加UnityChan后的场景如下： 到此就大功告成了，接下来打包运行，最终效果如下：","link":"/blog/2019/05/17/Unity/5分钟使用Unity制作AR应用/"},{"title":"Canvas-Scaler","text":"话说坑在何方？想当年年少轻狂时，层做了个类似下图的玩意： 勃主大笑三声，把screen的大小拖动了一下，然后它就变成了这个样子： 这是一件相当窝巢的事情，勃主苦练锚点三十年，终究还是没有搞定，知道师父他老人家蛋蛋的提点了一句“看看Canvas Scaler”。。。。。。 上图，勃主当时的scaler设定是这样的： 嗯，问题就在这里了，UI扩展模型——固定像素大小！！！！ 好吧，淡淡的改成了下面这样： 问题解决了，ui怎么捏都不会变形了。。。 到这里，好奇心颇重的勃主撩起三脚猫的English打开了官方API：[官方API的老巢](file:///D:/Program%20Files%20%28x86%29/Unity/Editor/Data/Documentation/html/en/Manual/script-CanvasScaler.html) 对于Canvas Scaler的描述是这样的“The Canvas Scaler component is used for controllingthe overall scale and pixel density of UI elements in the Canvas. This scalingaffects everything under the Canvas, including font sizes and imageborders.”（画布定标器组件是用于控制UI元素的整体规模和像素密度在画布上。这个扩展影响在画布上的一切,包括字体大小和图像边界。）我知道，谁都受不了这该死的鸡翻，所以我还得重新翻过：CanvasScaler是用来控制Canvas上的UI元素整体规模和像素的组件，这个扩展影响Canvas上的一切，包括字体大小和图像边界。 Canvas Scaler的ui scale mode有三种值（constan pixel size、scale with screensize和constant physical size）,接下来我就来介（翻）绍（译）一下这三种情况下的各参数代表的含义 1.Constant Pixel Size 不变像素大小 参数： Scale Factor–大小比例； Reference Pixels Per Unit – ,每单位代表像素量 2.Scale With Screen Size根据屏幕大小定标 -Reference Resolution(参考分辨率) The resolution the UI layout is designed for. if the screen resolution islarger, the UI will be scaled up, and if it’s smaller, the UI will be scaleddown. 参照这个UI布局所依据的分辨率，如果屏幕分辨率更大，那么UI会变大，如果屏幕分辨率更小，那么UI会变小。 -Screen Match Mode(屏幕匹配模式) Match Width or Height 参考宽或者高或者两者来规划画布 Expand 横纵两个方向扩大画布使画布不小于参考 Shrink 裁切画布使画布不大于参考 -Reference Pixels Per Unit 每单位的参考像素 当选择Match Width or Height时会有Match滑块，用来决定width和height的影响比例 3.Constant Physical Size 不变的物理尺寸 Physical Unit可以设置物理单位 Fallback Screen DPI屏幕分辨率不明是采用的分辨率 Default Sprite DPI 精灵每英寸的默认像素 Reference Pixels Per Unit 4.当Canvas的Render Mode属性为world space时 Canvas Scaler的ui Scale Mode为world不可改变","link":"/blog/2019/05/17/Unity/Canvas-Scaler/"},{"title":"Android全自动打包生成apk","text":"Unity自动打包Android其实要比IOS容易得多，因为Android不用先生成java工程，然后在构建.apk包，我先说说Android打包的步骤。 1.把sdk拷贝至Plugins/Android下。 如下图所示，如果你做过Android源生开发，我相信下面的东西你不会陌生。可是如果你没做过Android原生开发，我还是详细说明以下。 AndroidManifest：这是Android程序必不可少的文件，这里记录着应用程序的启动Activity。Activity就是Android的一个界面，一般应用程序会有很多Acitivty，来回切换界面。但是游戏就不太一样了，因为游戏只需要一个Activity一个View就可以了。（扯远了） AndroidManifest：里面还记录着应用程序的权限，Service啊什么的，，有兴趣的同学可以谷歌搜一搜。 每次打包的时候Unity会用它默认的AndroidManifest，它默认的AndroidManifest在unity.app/Contents/PlaybackEngines/AndroidPlayer下面。当你在进行打包apk的时候unity会拷贝该路径下的所有参数。 在ProjectSetting里面勾选一些权限的时候，Unity会自动帮你修改AndroidManifest里面的权限，但是如果某个权限不能在Unity工程里面修改，那么就需要自己手动替换。如下图所示，我们把AndroidManifest放在Plugins/Android下面，这样Unity在进行打包的时候就不会用它默认的，而是用我自己新写的打包。。这样就方便灵活很多了。。 bin:下面就记录着sdk用到的第三方jar res：下面就是安卓的一些图片，资源啊什么。 你可以随便解开一个android的APK看看它的目录结构就明白了。。 这样在打包的时候unity就会自动把Plugins/Android下面的所有资源打包在你的APK里面了。但是如果你做渠道包的时候，每个包用的是不同的sdk，所以你需要在打包不同渠道的时候把相关的文件拷贝在Plugins/Android下面。 如下图所示，我在根目录下创建一个文件夹名子叫91，当我自动化打包的时候自动把91文件夹下面的资源先拷贝在Plugins/Android下面，然后在自动打包。。打完包以后再把Plugins/Andoird文件夹清空即可。。 Ok上脚本。。代码和上一篇文章的第一步差不多，我就不多余注释，，执行下面shell脚本将自动打开unity，然后执行ProjectBuild.BuidForAndroid方法。。project-$1 就是传入的参数。。 12345678910111213141516171819202122232425#!/bin/sh#参数判断if [ $# != 1 ];thenecho &quot;需要一个参数。 参数是游戏包的名子&quot;exitfi#UNITY程序的路径#UNITY_PATH=/Applications/Unity/Unity.app/Contents/MacOS/Unity#游戏程序路径#PROJECT_PATH=/Users/MOMO/commond#在Unity中构建apk#$UNITY_PATH -projectPath $PROJECT_PATH -executeMethodProjectBuild.BuildForAndroid project-$1 -quitecho &quot;Apk生成完毕&quot; 在关闭unity的情况下运行。在命令行里面执行这一条脚本， 参数一个参数 91。 1234567891011121314151617181920212223242526272829303132333435363738using System.Collections;using System.IO;using UnityEditor;using UnityEngine;using System.Collections.Generic;using System;class ProjectBuild : Editor{ //在这里找出你当前工程所有的场景文件，假设你只想把部分的scene文件打包 那么这里可以写你的条件判断 总之返回一个字符串数组。 static string[] GetBuildScenes() { List&lt;string&gt; names = new List&lt;string&gt;(); foreach (EditorBuildSettingsScene e in EditorBuildSettings.scenes) { if (e == null) continue; if (e.enabled) names.Add(e.path); } return names.ToArray(); } static void BuildForAndroid() { Function.DeleteFolder(Application.dataPath + &quot;/Plugins/Android&quot;); if (Function.projectName == &quot;91&quot;) { Function.CopyDirectory(Application.dataPath + &quot;/91&quot;, Application.dataPath + &quot;/Plugins/Android&quot;); PlayerSettings.SetScriptingDefineSymbolsForGroup(BuildTargetGroup.Android, &quot;USE_SHARE&quot;); } string path = Application.dataPath + &quot;/&quot; + Function.projectName + &quot;.apk&quot;; BuildPipeline.BuildPlayer(GetBuildScenes(), path, BuildTarget.Android, BuildOptions.None); }} 程序会执行BuildForAndroid的方法，这里我把shell传入的参数取出来。根据传入的不同参数来初始化打包的一些设置。。 最终BuildPlayr就开始构建apk，第二个参数就是打包出apk保存的路径。 在打包之前你可以处理一些 游戏包名， 游戏icon等等一些平台之间的特殊性 ，也可以设置一些 预定义标签，。 12345678910111213141516171819202122232425262728using UnityEngine;#if UNITY_EDITOR using UnityEditor; using UnityEditor.Callbacks; using UnityEditor.XCodeEditor; using System.Xml;#endifusing System.IO;public static class XCodePostProcess{#if UNITY_EDITOR [PostProcessBuild (100)] public static void OnPostProcessBuild (BuildTarget target, stringpathToBuiltProject) { if (target == BuildTarget.Android) { Function.DeleteFolder(Application.dataPath+&quot;/Plugins/Android&quot;); if(Function.projectName== &quot;91&quot;) { //当我们在打91包的时候 这里面做一些 操作。 } } }#endif} **** 在回到XUPortr里面，当Android打包完毕后，这里我们清空Plugins/Android文件夹。。或者你也可以做一些操作。。 Function.cs 用到的一个工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566using UnityEngine;using System.Collections;using System.IO;public class Function{ //得到项目的名称 public static string projectName { get { //在这里分析shell传入的参数， 还记得上面我们说的哪个 project-$1 这个参数吗？ //这里遍历所有参数，找到 project开头的参数， 然后把-符号 后面的字符串返回， //这个字符串就是 91 了。。 foreach (string arg in System.Environment.GetCommandLineArgs()) { if (arg.StartsWith(&quot;project&quot;)) { return arg.Split(&quot;-&quot;[0])[1]; } } return &quot;test&quot;; } } public static void DeleteFolder(string dir) { foreach (string d in Directory.GetFileSystemEntries(dir)) { if (File.Exists(d)) { FileInfo fi = new FileInfo(d); if (fi.Attributes.ToString().IndexOf(&quot;ReadOnly&quot;) != -1) fi.Attributes = FileAttributes.Normal; File.Delete(d); } else { DirectoryInfo d1 = new DirectoryInfo(d); if (d1.GetFiles().Length != 0) { DeleteFolder(d1.FullName);////递归删除子文件夹 } Directory.Delete(d); } } } public static void CopyDirectory(string sourcePath, string destinationPath) { DirectoryInfo info = new DirectoryInfo(sourcePath); Directory.CreateDirectory(destinationPath); foreach (FileSystemInfo fsi in info.GetFileSystemInfos()) { string destName = Path.Combine(destinationPath, fsi.Name); if (fsi is System.IO.FileInfo) File.Copy(fsi.FullName, destName); else { Directory.CreateDirectory(destName); CopyDirectory(fsi.FullName, destName); } } }} 如下图所示，脚本运行完毕，你打包的APK就静静的放在了这里，怎么样？简单吧？嘿嘿。。 注意事项： 1、因为你的工程可能比较大，如果IOS和Android同时打包的话切个平台都要半个多小时，我建议的svn在本地check out 两个工程，一个切在ios一个切在Android 打包的时候分开打。 2.执行shell脚本的时候请关闭保存unity工程。 3.Android 因为不受证书的限制，我上传的工程建议你下载下来看看，肯定可以直接打出来包。。 4.我建议打包的机器使用mac。 因为windows不能打包IOS 而MAC可以同时 打包 IOS 和 Android 工程下载地址：http://pan.baidu.com/s/1o6OATcu","link":"/blog/2019/05/17/Unity/Android全自动打包生成apk/"},{"title":"Canvas","text":"每个UI元素都必须处于一个Canvas的子级中； 一个场景中可以存在多个Canvas； render mode 渲染模式 Render Mode-Screen Overlay 画布总会铺满整个屏幕，总是渲染在所有元素的最上层 ，画布的RectTransform的大小有屏幕决定； Pixel Perfect选项会让UI边缘锐利； Render Mode-Camera 在没有指定摄像机的时候，和SreenOverlay效果完全一样。指定了摄像机以后，画布会自动调整到相机可视范围内，比Canvas更靠近相机的3Dobject会被渲染在前面，比Canvas远离相机的3dObject会被遮挡 画布全权交由这个摄像机来渲染，多个相机的渲染次序，相机类型等都会对该画布的元素有影响。此模式下画布的RectTransform完全受到相机的ViewPortRect影响； Pixel Perfect和Screen Overlay模式下的作用一样； Plane Distance 决定Canvas与渲染相机的距离； 该模式可能有如下场景应用： 1.如果渲染Canvas的相机是透视的，可以调整Canvas内某些元素的旋转角度，产生透视和深度效果； 2.可以通过不同相机的sorting layer和渲染的图层来实线UI上方的粒子特效等。Render Mode-World Space 画布的Rect Transform完全自由，不受任何约束，可以自行设置大小、位置； 可以放置于物体的子级，常用作气泡、对话框等； EventCamera 该选项决定该UI接受哪个相机的事件，如果该项为None，则默认接受主相机的事件。如果指定某个相机，则只接受该相机的事件。","link":"/blog/2019/05/17/Unity/Canvas/"},{"title":"Prefab里面的Prefab关联问题","text":"最近造了个轮子可以批量替换prefab里的prefab，欢迎大家测试～&lt;https://bitbucket.org/xuanyusong/prefab-replace&gt; 最近在做UI部分中遇到了这样的问题，就是Prefab里面预制了Prefab。可是在Unity里面一旦Prefab预制了Prefab那么内部的Prefab就失去关联。导致与如果要改内部的Prefab需要把所有引用的地方全部改一遍。今天在逛国外网站看到了一个老外的思路，原文在这里&lt;http://framebunker.com/blog/poor-mans-nested-prefabs/&gt; 下面直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126using UnityEngine;#if UNITY_EDITOR using UnityEditor; using UnityEditor.Callbacks;#endifusing System.Collections.Generic;[ExecuteInEditMode]public class PrefabInstance : MonoBehaviour{ public GameObject prefab;#if UNITY_EDITOR // Struct of all components. Used for edit-time visualization and gizmo drawing public struct Thingy { public Mesh mesh; public Matrix4x4 matrix; public List&lt;Material materials; } [System.NonSerializedAttribute] public List&lt;Thingy things = newList&lt;Thingy (); void OnValidate () { things.Clear(); if (enabled) Rebuild (prefab, Matrix4x4.identity); } void OnEnable () { things.Clear(); if (enabled) Rebuild (prefab, Matrix4x4.identity); } void Rebuild (GameObject source, Matrix4x4 inMatrix) { if (!source) return; Matrix4x4 baseMat = inMatrix * Matrix4x4.TRS (-source.transform.position,Quaternion.identity, Vector3.one); foreach (MeshRenderer mr in source.GetComponentsInChildren(typeof(Renderer), true)) { things.Add(new Thingy () { mesh = mr.GetComponent&lt;MeshFilter().sharedMesh, matrix = baseMat * mr.transform.localToWorldMatrix, materials = new List&lt;Material (mr.sharedMaterials) }); } foreach (PrefabInstance pi in source.GetComponentsInChildren(typeof(PrefabInstance), true)) { if (pi.enabled &amp;&amp; pi.gameObject.activeSelf) Rebuild (pi.prefab, baseMat * pi.transform.localToWorldMatrix); } } // Editor-time-only update: Draw the meshes so we can see the objects in thescene view void Update () { if (EditorApplication.isPlaying) return; Matrix4x4 mat = transform.localToWorldMatrix; foreach (Thingy t in things) for (int i = 0; i &lt; t.materials.Count; i++) Graphics.DrawMesh (t.mesh, mat * t.matrix, t.materials[i], gameObject.layer,null, i); } // Picking logic: Since we don&apos;t have gizmos.drawmesh, draw a bounding cubearound each thingy void OnDrawGizmos () { DrawGizmos (new Color (0,0,0,0)); } void OnDrawGizmosSelected () { DrawGizmos (new Color (0,0,1,.2f)); } void DrawGizmos (Color col) { if (EditorApplication.isPlaying) return; Gizmos.color = col; Matrix4x4 mat = transform.localToWorldMatrix; foreach (Thingy t in things) { Gizmos.matrix = mat * t.matrix; Gizmos.DrawCube(t.mesh.bounds.center, t.mesh.bounds.size); } } // Baking stuff: Copy in all the referenced objects into the scene on playor build [PostProcessScene(-2)] public static void OnPostprocessScene() { foreach (PrefabInstance pi in UnityEngine.Object.FindObjectsOfType (typeof(PrefabInstance))) BakeInstance (pi); } public static void BakeInstance (PrefabInstance pi) { if(!pi.prefab || !pi.enabled) return; pi.enabled = false; GameObject go = PrefabUtility.InstantiatePrefab(pi.prefab) as GameObject; Quaternion rot = go.transform.localRotation; Vector3 scale = go.transform.localScale; go.transform.parent = pi.transform; go.transform.localPosition = Vector3.zero; go.transform.localScale = scale; go.transform.localRotation = rot; pi.prefab = null; foreach (PrefabInstance childPi ingo.GetComponentsInChildren&lt;PrefabInstance()) BakeInstance (childPi); }#endif} 用法比较简单，比如我有两个Prefab，inside嵌入在Big里面。如下图所示，把PrefabInstance脚本挂在Big上，然后把inside拖入下方。 OK 无论怎么修改inside这个Prefab，当实例化Big的时候都能得到最新修改的Inside这个Prefab。 持续思考： 界面预览问题，就是我在布界面的时候，我需要把子集Prefab界面控件拖进来预览效果。如果用上述思路UI的Prefab就必须通过脚本自动生成。一份是预览用的也就是不需要脚本的，一份是只带脚本运行时动态生成的。在处理自动生成UIPrefab的时候可以利用tag比如像这种需要内嵌的Prefab标记一个特殊的tag，在Editor下完成Prefab的导出。另外布界面的时候不需要绑定脚本，而上述脚本的绑定也应该由Editor导出Prefab的时候完成。 总之一切布界面的时候只操作Prefab不操作脚本。 最近造了个轮子可以批量替换prefab里的prefab，欢迎大家测试～&lt;https://bitbucket.org/xuanyusong/prefab-replace&gt; 如果有更好的方法欢迎各位朋友在下面给我留言，谢谢。 本文固定链接: https://www.xuanyusong.com/archives/3042 转载请注明: 雨松MOMO2014年07月31日 于 雨松MOMO程序研究院 发表","link":"/blog/2019/05/17/Unity/Prefab里面的Prefab关联问题/"},{"title":"CanvasGroup","text":"Canvas Group可以用来控制一组不需要个别控制的UI元素的某些方面，CanvasGroup的属性会影响他所有children的GameObject 其中有四个选项： -Alpha：这个选项很多组件都有，用处也是一样的，在美术中，这个叫做Alpha通道的东东是用来控制透明度的，他的值从0到1.0是完全透明，1是完全不透明； -Interactable确认该组件是否接受输入，当他被设置为false时，交互功能将被禁用； -Block Raycasts是否让该组件像collider一样接受射线检测？你需要在依赖于Canvas的图形射线检测者上唤醒射线检测方法。这个不会作用于Physics.Raycast; -Ignore Parent Groups(忽略父级团)是否响应父级group的方法 Canvas Group的经典使用： -在窗口的GameObject上添加一个CanvasGroup，通过控制它的Alpha值来淡入或淡出整个窗口； -通过给父级GameObject添加一个CanvasGroup并设置它的Interactable值为false来制作一整套没有交互（灰色）的控制； -通过将元素或元素的一个父级添加CanvasGroup并设置BlockRaycasts值为false来制作一个或多个不阻止鼠标事件的UI元素 应用：（重要的地方写大字） 结合后面两点或者1,3点，都可以实现很牛叉的功能 比如说游戏里某些情况某个按钮（或者其他UI）是不能点的，而另外一些情况可以点，这样就可以通过动态改变这个组件的BlocksRaycasts值以及Interactable来实现 再比如说游戏里点击某个按钮要让这个按钮不可点并逐渐消失掉，当然啦，也可以让别的东西消失啦，这就可以通过改变alpha值来实现 恩，CanvasGroup这个组件已经被我玩坏啦。 至此，canvas的四个组件（Canvas、Canvas Render、Canvas Scaler、CanvasGroup）都学完了，勃主的装逼之路越走越远了哈！ 抽空再补上例子。。。","link":"/blog/2019/05/17/Unity/CanvasGroup/"},{"title":"Unity5开发Oculus项目入门范例","text":"今天为大家介绍使用Unity 5开发Oculus项目的入门范例Oculus SampleFramework，该范例由Oculus制作，是为VR开发者和设计师提供的实验性示例集合。 其中包含了一系列的解决VR典型问题的示例场景，有第一人称视角的运动机制和基于注视的交互界面。每个范例都提供了在应用内调整参数的控制面板，这些参数包括传送过程中从透明到消失的时长，界面控制元素的延迟或瞄准器的Z深度等。该控制面板本身就很好的展示了VR中的控制器，可以直接将其用于自己的VR项目。 项目中的每个场景都展示了一个与VR开发相关的概念。整个范例是一个Unity 5 的项目。可以在Windows平台上执行，并且可以在Gear VRConcepts商城免费下载。这个应用可以让使用者在不打开Unity编辑器的情况下深入到场景中理解一些VR开发的概念。每个VR场景中都包含一份文档，所以可以深入到VR场景中直接学习。 如果想要深入探索并实现示例内的VR操作界面没有提供的功能，建议在Unity中打开并编辑该项目。 示例的主要作用是提供一套探索VR设计概念的工具，并非推荐大家都这么做。每个示例都包含了可供测试的游戏机制，其中有些设置会让玩家产生不适感，这是我们设计VR时需要避免的。这些功能的主要用途就是让开发者体验到什么是可行的，什么是不可行的。 示例场景简介整个示例框架包含了很多场景。最好的学习方法就是进入场景中尝试。我们先作为测试人员来看看这几个场景。 十字准星 这个示例展示了基于注视位置的十字准星或者瞄准器，并探讨了一些必须注意的相关因素。在非VR游戏中，十字准星是否位于视野中心是无关紧要的，但VR开发者则必须要确定十字准星显示位置所代表的深度信息。十字准星的位置如果太近，观察者就会不舒服。如果太远，当准星看起来比场景中位于它下面的物体还远时，又会让玩家产生深度上的错觉。 解决该问题的方法之一，是沿着玩家的视角进行光线投射，并将十字准星定位在视线接触到的第一个物体上。这样就能保证十字准星处在一个合适位置的同时不与场景中的深度信息冲突。你可以在示例中尝试上述方法或一些其它的解决方法，还可以在运行时手动控制十字准星的深度。 这个示例也展示了一些其它概念，例如导弹是如何投射的。如果将十字准星对准导弹，并且该准星与玩家保持固定的距离，就必须决定导弹是沿着从枪口出发的一条轨迹穿过十字准星，还是沿着玩家视觉中心与准星连线的平行线穿过十字准星。后者是非VR游戏的常用做法，这种方法很直观。这个示例可以让你更直接的感受并理解这种区别。 运动 这个示例场景可以体验到第一人称视角的实时移动控制，从而可以更好理解相关设计上的权衡。第一人称视角的移动控制设计需要非常小心，因为这种移动很容易造成不适感。 这个场景可以调整的变量有： 移动速度 旋转速度 玩家朝向是否由视觉方向控制 旋转的步长（持续旋转或者使用固定步骤指定步长的旋转） 当执行“每一步”旋转时的动画速度（非瞬间完成） 瞬移 瞬移是VR中常用的移动方式，因为这样可以避免第一人称视角控制运动引起的不适感。这个示例场景实现了简单的瞬移机制。 这个示例中展示的一个巧妙设计是玩家在瞬移后视角位置的旋转方式。这种模式中，瞬移后视角的方向是由玩家控制的，这个方向可以在瞬移前就设定好。上面的截图展示的就是这个操作，一个发光的虚拟人物出现在了瞬移的终点，展示了瞬移后玩家的朝向且可以由玩家来控制。在瞬移结束后，玩家面对的方向与之前设定的虚拟人的朝向是一致的。 这看起来很直观，但可能存在玩家需要旋转头部才能看到瞬移终点的情况。这时玩家在瞬移完成后朝向与模型保持一致同时头部旋转呢？还是将最终朝向与旋转头部后的自然前方保持一致呢？ 这个示例展示了以上两种方式，至于哪一种更直观则取决于另一些因素。示例可以帮助你很直观的理解这两种模式的区别，并探索出个性化的解决方案。 UI（用户界面） 场景“Pointers” （指示点）和“Pointers – GazeClick”（指示点－凝视点击）展示了利用指示点来实现VR中的UI交互。两个场景均展示了基于凝视的交互机制，包含了与物理对象和平面UI的交互。 场景“Pointers” （指示点）和“Pointers – Gaze Click”（指示点－凝视点击）很相似，只是“Pointers – GazeClick”（指示点－凝视点击）并不需要手柄或者触摸板。在这个场景中，凝视一个UI元素时会在凝视光标附近产生一个圆形的进度条，进度条会很快填充满（如上图所示）。当环形进度条填充完毕，就会执行相应UI所负责的动作。 其它示例场景篇幅有限无法一一介绍每个场景，各场景都包含对应的文档，我们可以在VR应用内查看这些文档。其它场景包括： Keyboard：VR键盘的简单实现。 Mirror：展示了模型头部按照玩家头部动作进行运动，以实现场景中的镜像效果。 Stairs：探索楼梯效果在第一人称视角下体验的舒适度。 Surface Detail：探索不同着色技术所描绘出的不同表面细节，可以更好的理解它们在VR中的效果。 Tracking Volume：展示一些方法，在用户离跟踪边界范围太近时给予提示。 结论这些示例只能作为理解和探索VR中一些常用设计的出发点。事实上，这些示例只是不断发展的VR交互中最浅显的部分。希望各位开发者能觉得这个出发点对你将来的新设计思路有一定帮助。","link":"/blog/2019/05/17/Unity/Unity5开发Oculus项目入门范例/"},{"title":"Unity中Avatar换装实现","text":"资源准备1.每一套装备模型必须使用同一套骨骼，并单独将骨骼数据保存成一个Prefab。红色部分为武器挂节点（也可以把武器做成一个SkinnedMesh，不采用挂接点的形式），骨骼数据在Unity中的展示形式就是Transform。 2.将模型拆分成多个部分，将每一个部分单独保存成Prefab，武器也单独保存为一个Prefab。 每一个Prefab都含有自身的SkinnedMeshRenderer。 实现过程1.创建骨骼GameObject，所有装备的蒙皮数据会最终合成到这个Prefab中。 2.创建装备GameObject，用于搜集其中蒙皮数据以生成新的SkinnedMeshRenderer到骨骼Prefab中。 3.public void CombineObject(GameObject skeleton, SkinnedMeshRenderer[] meshes,bool combine = false)传入骨骼的GameObject和蒙皮数据。 4.搜集装备蒙皮数据中的有效信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Collect information from meshes for (int i = 0; i &lt; meshes.Length; i ++) { SkinnedMeshRenderer smr = meshes[i]; materials.AddRange(smr.materials); // Collect materials // Collect meshes for (int sub = 0; sub &lt; smr.sharedMesh.subMeshCount; sub++) { CombineInstance ci = new CombineInstance(); ci.mesh = smr.sharedMesh; ci.subMeshIndex = sub; combineInstances.Add(ci); } // Collect bones for (int j = 0 ; j &lt; smr.bones.Length; j ++) { int tBase = 0; for (tBase = 0; tBase &lt; transforms.Count; tBase ++) { if (smr.bones[j].name.Equals(transforms[tBase].name)) { bones.Add(transforms[tBase]); break; } } } 5.为骨骼GameObject生成新的SkinnedMeshRenderer。 123456789101112131415161718// Create a new SkinnedMeshRendererSkinnedMeshRenderer oldSKinned = skeleton.GetComponent&lt;SkinnedMeshRenderer&gt;(); if (oldSKinned != null) { GameObject.DestroyImmediate(oldSKinned); } SkinnedMeshRenderer r = skeleton.AddComponent &lt; SkinnedMeshRenderer();r.sharedMesh = new Mesh();r.sharedMesh.CombineMeshes(combineInstances.ToArray(), false, false);//Combine meshes r.bones = bones.ToArray();// Use new bones 6.挂接武器。 12345678910Transform[] transforms = Instance.GetComponentsInChildren&lt;Transform(); foreach (Transform joint in transforms) { if (joint.name == &quot;weapon_hand_r&quot;) {// find the joint (need the support of art designer) WeaponInstance.transform.parent = joint.gameObject.transform; break; } } 其中WeaponInstance为武器实例GameObject，Instance为骨骼实例GameObject。 合成后的效果 如何优化 合成之后的模型拥有4个独立材质，加上独立的对象武器，也就是会产生5个Draw Call；如果将在骨骼中的这4个材质合并成一个，那么就能将DrawCall减少到2个。 其中实现过程如下： 优化CombineObject方法，其中Combine为bool类型，用于标识是否合并材质。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// merge materials if (combine) { newMaterial = new Material (Shader.Find (&quot;Mobile/Diffuse&quot;)); oldUV = new List&lt;Vector2[](); // merge the texture List&lt;Texture2D Textures = new List&lt;Texture2D(); for (int i = 0; i &lt; materials.Count; i++) { Textures.Add(materials[i].GetTexture(COMBINE_DIFFUSE_TEXTURE) asTexture2D); } newDiffuseTex = new Texture2D(COMBINE_TEXTURE_MAX, COMBINE_TEXTURE_MAX,TextureFormat.RGBA32, true); Rect[] uvs = newDiffuseTex.PackTextures(Textures.ToArray(), 0); newMaterial.mainTexture = newDiffuseTex; // reset uv Vector2[] uva, uvb; for (int j = 0; j &lt; combineInstances.Count; j++) { uva = (Vector2[])(combineInstances[j].mesh.uv); uvb = new Vector2[uva.Length]; for (int k = 0; k &lt; uva.Length; k++) { uvb[k] = new Vector2((uva[k].x * uvs[j].width) + uvs[j].x,(uva[k].y * uvs[j].height) + uvs[j].y); } oldUV.Add(combineInstances[j].mesh.uv); combineInstances[j].mesh.uv = uvb; } } 生成新的SkinnedMeshRenderer时略有区别： 最终效果如下： 可以看出，新的SkinnedMeshRenderer只有一个材质，Draw Call自然也就降低了。 示例工程 GitHub：https://github.com/zouchunyi/UnityAvater 感兴趣的朋友可以下载。工程中代码大家可以直接使用，但是美术资源不得用于任何商业用途。","link":"/blog/2019/05/17/Unity/Unity中Avatar换装实现/"},{"title":"Unity中的Daydream开发与实例","text":"本文将由Unity大中华区技术经理马瑞，为大家分享在Unity中进行Daydream平台的开发与实例。 2016年9月，我们发布了原生支持Daydream平台的Unity技术预览版。本文将帮助您了解开发Daydream应用所需的设备和软件并介绍安装过程，以便您可以立即开始创建Daydream平台的游戏，最后提供几个优秀的案例，为您带来更好的游戏设计思路。 入门创建Daydream游戏之前，我们需要做开发前的软硬件准备，包括Daydream设备和Unity的Google VR技术预览版。 Daydream设备 Daydream设备包括一个DaydreamView头盔、控制器和支持Daydream的手机。真机测试游戏需要以上所有设备。如果您仅希望在Unity编辑器的运行模式下测试游戏，则任何类型的Android手机均可。我们会在下文关于编辑器中的VR模拟器一节中继续讨论这个问题。 Daydream View套装包括虚拟现实头盔和控制器。该套装可在线购买。Cardboard和Daydream的最大区别是：Daydream头盔由布料制造，质量更好，并配备了NFC芯片。 支持Daydream的手机 目前有五类手机可用： Pixel (Pixel, Pixel XL) Moto Z (Moto Z, Moto Z Droid, Moto Z Force Droid) 支持Daydream的手机正在不断增加。有关详细信息，您可以查看Google官方网站。如果您没有此列表中的任何手机，也可以使用Daydream开发套件与Nexus6P手机，但Nexus 6P的散热性能不及支持Daydream的手机。 Unity的Google VR技术预览版 创建Daydream的Build需要使用Unity的Google VR技术预览版。您可以在Unity官网下载，OSX和Windows版本都有。它包含基于Unity 5.4.2版本的自定义编辑器和Android Player。 Google VR SDKGoogle VR SDK是开发Daydream所必需的。SDK提供原生集成的Google VR，还包含一些其它功能，详情见下文。 SDK内容 原生集成的功能： 头部跟踪 并排立体渲染 检测用户与系统的交互 针对特定头戴设备的自动立体渲染配置 VR头盔镜头的失真校正 对齐标记 － 当您将手机插入到头盔中时，帮助您将手机屏幕与镜头对齐 自动陀螺仪运动检测 附加功能： Daydream控制器支持 空间音频渲染 一个简单取景器(reticle)预制件和基于凝视的用户交互相关脚本 在Unity编辑器的运行模式下进行VR模拟，您可以使用鼠标和Alt / Ctrl键平移或旋转VR摄像头 “Headset Demo”场景 － 演示一个简单的Cardboard游戏 “Controller Demo”场景 － 演示与Daydream控制器的集成 显示FPS的预制件 安装指南 下载GoogleVR SDK以及支持Daydream的Unity预览版。打开Unity，建立一个新的3D项目，然后将SDK导入项目。 在Player Settings下的Android选项卡下，单击”Virtual RealitySupport”并选择Daydream平台。在Minimum API Level选择Android 7.0 Nougat或更新的版本。 经过以上的步骤，您的Daydream开发环境基本就搭建完毕了。 两个演示场景 控制器演示：ControllerDemo.asset 本场景展示了Daydream控制器的简单使用。 在Unity编辑器中，您可以使用Android手机与控制器仿真来模拟Daydream控制器。 头盔演示：DemoScene.asset 本场景展示了简单的Cardboard或Daydream头盔行为。可以通过按下“Alt”键并移动鼠标在Unity编辑器中移动摄像机，您也可以通过按下“Ctrl”键并移动鼠标来旋转摄像机。 控制器 Cardboad和Daydream的主要区别是Daydream有一个控制器，控制器使用户体验更类似于HTC Vive或者Oculus Rift。 _ _ 仿真的控制器 控制器由三个区域组成： TouchPad - 检测触摸区域上是否有手指，并检查手指的位置。 TouchPad也可以点击。 App按钮 - TouchPad下方的按钮。 Home按钮 - 为Android系统保留的按钮。 可以通过场景中的GvrController类来获得有关控制器的输入和状态的信息。此类通过访问此单例的静态属性来提供连接状态、方向、陀螺仪读数、加速度、触摸板和按钮状态。 编辑器中的VR模拟器 因为Daydream平台是最近才发布的，所以您可能无法及时获得必需的硬件，在Unity编辑器的运行模式下测试游戏也是个不错的选择。在这种情况下，VR模拟器非常有用。谷歌提供一个APP，可以安装在所有类型的Android手机，它会模仿真实的Daydream控制器的行为。 使用控制器仿真可能有一点不便，就是不能触摸真的控制器。谷歌提供了解决方案： 可以下载并打印一个屏幕覆盖层，包括letter,A4和SVG三种格式。打印好后将相应按键的位置挖洞，并放在手机上面，就可以获得更真实的体验。 开发实例最好的学习方法就是查看示例。 Google VR的GitHub代码库包含4个非常有用的示例，可帮助您全面了解如何使用新的Google VR： Daydream Labs Controller Playground 这是一个结合了15个小游戏的大合集，该项目供了许多不错的例子，告诉用户如何充分利用控制器与VR头盔。介绍一些VR游戏中控制器常用的使用方法。 源码下载地址： https://github.com/googlevr/gvr-unity-sdk/tree/master/Samples/DaydreamLabsControllerPlayground Cardboard Design Lab 如果您是VR初学者，那么可以从该示例开始。 在整个项目中，您将学习从设计VR的基础到创建沉浸式环境等VR设计相关内容。 源码下载地址： https://github.com/googlevr/gvr-unity-sdk/tree/master/Samples/CardboardDesignLab Castle Defense 这是一个简单的VR手游示例。 源码下载地址： https://github.com/googlevr/gvr-unity-sdk/tree/master/Samples/CastleDefense Spatial Audio 这个项目将帮助您了解在VR项目中实现真实音频效果的最佳做法。它用到了Google VR的音频渲染功能。 源码下载地址： https://github.com/googlevr/gvr-unity-sdk/tree/master/Samples/CastleDefense","link":"/blog/2019/05/17/Unity/Unity中的Daydream开发与实例/"},{"title":"Unity中的单元测试和错误追踪","text":"本文将由Unity大中华区企业支持经理高川，为大家分享Unity自带的单元测试及性能报告工具。 在游戏开发过程中，Bug的出现是无法避免的。解决Bug的重要前提是及时发现Bug，准确定位Bug。Unity提供了两个优秀的工具来帮助大家完成“杀虫”工作。 Unity Editor Test Runner在开发过程中，一个Bug被发现的越早，其修复的可能性越高，而修复成本则越低。为了尽早发现问题，避免Bug积累重叠，单元测试就显得尤为重要。 单元测试可以针对特定功能模块进行持续的检测，帮助开发人员尽早发现问题，及时修正。在Unity编辑器中集成了单元测试模块。该模块源自著名的开源工程NUnit，与Unity引擎结合后，可以方便的完成日常开发中的单元测试功能。下面来介绍一下如何使用这个功能。 首先要建立测试用例。测试用例的脚本需要放到Editor 目录下： 在测试用例脚本中引入名字空间NUnit.Framework： 测试用例函数需要一个[Test]属性来标识： 测试用例函数中通过Assert类下面的一系列函数，进行断言测试： 一个测试用例中可以有多个断言，只有所有断言都通过检测，才会认为一个测试用例通过了检测。 写好全部测试用例后，打开Unity Editor的Windows-&gt;Editor Tests Runner，在EditorTests窗口中我们可以看到测试工具按钮和刚刚写的一系列测试用例： 上面一栏中包含按钮：Run All，Run Selected和Run Failed - Run All：运行全部测试用例 - Run Selected：运行当前选择的测试用例 - Rerun Failed：重新运行全部失败的测试用例 右侧的四个图标则分别表示： 成功的测试用例数 - 失败的测试用例数 - 被忽略的测试用例数 - 尚未运行过的测试用例数 下方的树状结构表示具体测试用例当前的状态。 同时Editor Tests提供headless的运行模式，可以很好的与CI&amp;CD等自动化流水线配合。 Game Performance ReportingUnity提供的另外一个工具是Game PerformanceReporting（GPR）性能报告。这是一个用来做运行时错误追踪的系统。目前市面上也有很多运行时错误追踪系统，但很多在和Unity引擎结合使用中效果并不理想。主要表现在，追踪到的代码可读性差，错误追踪不准确，定位错误等等。结果造成了开发者看到很多错误报告上来，然而并不能解决的尴尬局面。做为Unity原生解决方案，GamePerformance Reporting性能报告系统完美解决了这个问题。下面来简单介绍一下这个系统。 首先改系统整合简单。Game PerformanceReporting性能报告继承了Unity一贯的使用简单的风格，在Unity5.4之前的Unity版本（目前仅支持Unity5.x系统），开发者需要去Unity官网下载一个UnityPackage并导入工程。然后在游戏启动时的某个脚本上加上一句代码： CrashReporting.Init(““); 其中Project ID是在Unity官网上生成的唯一ID。 在Unity5.4版本中，Game PerformanceReporting系统直接被整合到了编辑器中。开发者只需要在Services窗口中将Performance Reporting的开关打开即可： 当游戏在运行时（测试期或者上线后）出现异常的时候，通过登录Unity开发者页面的Unity Online Services 就可以查看到异常的信息。 堆栈部分，在信息后台是可以看到清晰的异常定位的。这样可以快速的帮助开发者定位到问题所在： 同时Game Performance Reporting提供异常的基本数据统计，包括异常出现的设备，异常出现的时间点，影响到的客户数量以及影响到的版本等等： 通过以上两个工具，在开发期和运行时，开发者都可以很好的管理游戏的Bug数量，评估工程的质量，及时发现和修改问题，从而提供更好的游戏体验给广大玩家。","link":"/blog/2019/05/17/Unity/Unity中的单元测试和错误追踪/"},{"title":"Unity中的时间控制","text":"关卡创建本文会探讨如何在Unity中使用时间控制进行关卡创建。在探讨之前，可以观看视频了解拥有时间控制玩法的解谜游戏《Lintrix》： 因为与《Lintrix》拥有同样的时间控制玩法的游戏并不多见，因此本文以《Lintrix》为例，说明如何在Unity中实现该功能，以及它可以有哪些应用。我们将以Unity引擎为例，并使用Unity相关的术语，但其概念也适用于其他引擎。 时间控制对创建关卡的意义为什么要用时间控制来辅助创建关卡呢？这样设计的主要契机是：第一，《Lintrix》团队有成员在创建动画编辑器方面具有丰富经验；第二，Unity有一个时间轴，可以查看场景在任何时刻的表现。 我们希望状态和属性，比如Unity对象的Transforms，可依赖于时间，并且能够跳转到特定时刻，因为如果这样的话，正常进行游戏的时候，所有对象都将拥有相应的状态。 就游戏本身而言，因为《Lintrix》是确定性的游戏，所以可以很好地利用时间轴来实现时间控制。《Lintrix》场景的许多对象都在游戏进行时移动，并且它们彼此之间的相对位置非常重要，像时间轴这样的工具可以帮助关卡设计者更容易理解该关卡在游戏中的样子，以便在编辑器中进行创建。另外在大多数情况下，我们也很容易编辑某个时刻的关卡，从而让所有的对象在某个具体时间点定位或旋转，并且当时间设置为零或开始移动时，对象会自动重新计算其位置。 我们提供了快捷键以便于对时间进行前进和后退操作。之后，关卡创建不仅是摆放物体后运行，更多的是向前或向后跳跃，以及重新定位对象，所以这些物体在关卡的任意时刻都要保持在其预先设计的位置。 这在《Lintrix》游戏中非常有用：一方面，希望玩家能够连接晶体来消灭所有的敌人；另一方面，又不希望这些连接会覆盖其他晶体或者彼此重叠。 如何避免对象碰撞实际上，在开发《Lintrix》游戏的过程中，重叠是个大问题，因为当场景中大多数对象移动时，很难防止它们过早碰撞。 大部分时间会出现类似这种糟糕的效果： 为了理解物体如何移动，我们添加了移动轨迹。它让敌人在晶体之间移动而不碰撞的问题更加容易避免。 它也可用于可视化晶体运动。 我们在创建关卡时使用时间控制进行“计时”。 这里的计时表示调整关卡某些部分的运动，使得在关卡运行时物体早点或晚点出现。 有时甚至希望来回移动所有的动作。例如，在关卡开始时可以预留给玩家一些时间，以便他们能够预估将会发生的景象。 使用时间轴可以轻松地将时间移至负值，并将此新时间设为零表示开始。 因为在编辑器模式下更新时间的脚本被添加到控制时间的对象，如果想要启用或禁用对象上更改时间的效果，只需启用或禁用此脚本，并使它们响应或忽略时间的更改。 实现方法下面我们一起来看看如何在Unity中实现该功能。 创建接口 首先创建一个非常简单的接口，让所有需要随时间变化的脚本都实现这个接口： 1234public interface ITimeChanging{ void AddTime(float dt);} 定义时间操控实体 这个时间操控实体可以为一组实现了ITimeChanging接口的对象调用这些方法。 实体接口如下： 123456public class TimeManager{ float Time { get; set; } IEnumerable&lt;ITimeChanging&gt; TimeDependants { get; set; } void SetTimeBruteForce(float time);} 在编辑器模式中，有一个可以让用户直接在运行模式下控制时间的脚本。如下图所示，你可以看到关卡控制器通过它的Update()来增加时间。 示例项目下载链接： https://github.com/alexander91/timelineExample 为时间控制添加物体响应 我们设置了一个时间轴管理器，允许跳转到不同的时刻。以及几个带有线性运动（LineMovement）脚本的立方体，LineMovement脚本继承自ITimeChaning，并监听TimeManager中的时间改变（AddTime），可以在监视器面板设置这个立方体以给定速度朝预定方向移动，代码如下： 1234567891011121314public class LineMovement : MonoBehaviour, ITimeChanging{ [SerializeField] Vector3 direction = Vector3.up; [SerializeField] float speed = 0.2f; public void AddTime(float dt) { transform.position += dt * speed * direction.normalized; }} 综上所述，编辑器自定义时间控制工具非常适用于确定性的游戏，这将让整个工作流程分外轻松。 另外，如果游戏中的动作很简单，也可以很容易在编辑器中提供各种选项。 时间倒退之前我们探讨了Unity中时间控制在关卡创建方面的应用，今天我们将以解谜游戏《Lintrix》为例，继续为大家分享在开发游戏的过程中，如何在Unity中实现时间倒退功能，并且对游戏设计与机制进行深入的探讨，希望能对大家有帮助。 时间倒退功能的必要性在开发并试玩游戏的过程中，我们认识到玩家往往会忘记在关卡中犯过的错误，所以需要在游戏中做大量的记录。事实上，一些游戏关卡的设计目的就是为了从各个方向分散玩家的注意力，让玩家在某个时刻忽视某个方向来的敌人，最终导致游戏失败。当然，游戏中也有很多选择可以用来帮助玩家回想起发生过的事情，例如展示遇到过敌人的轨迹，或者在玩家之前的游戏过程中角色死亡次数比较多的地方设置警示点。 但有人担心这样做会让屏幕变得混乱，或者让玩家容易重复之前的行为而不去思考新的方式，降低了游戏的趣味性。为了解决这个问题，我们发现利用时间轴复用功能进行提示似乎是个不错的选择。因为每次游戏失败之后，在玩家点击“重新开始”按钮后，以相反的方向显示之前的游戏经历，如下图所示： 从失败那一刻开始，呈现最有可能导致失败的片段 但若要有一个完美的解决方案，应该还要知道之前发生了什么事情，记录下来作为回放。 实现方法事实上，反向回放要做的工作几乎都在上一篇为关卡设置时间轴时就完成了。而下面将要讲述的方法，虽然可能这不是最优的解决方案，但是这种做法十分简单。 虽然用之前已经实现的后退操作就能完成敌人和水晶的运动。但是关卡中的其它事件是由玩家或者玩家动作触发的。对于这种情况，需要为TimeManager添加新的接口： 12345678910public delegate void ReversingTimeActionDelegate();public class TimeManager{ class ReversingActionWithTime { public float Time { get; set; } public ReversingTimeActionDelegate ActionToCarryOut { get; set; } } public void RememberAction(ReversingTimeActionDelegate action) } 我们引入了ReversingActionWithTime这个类来记录动作的时间以及一个函数，它可以执行反向动作，这个逻辑与编程中的命令模式相似，但它是通过与时间绑定而不是点击ctrl+Z或其他类似的组合键来触发执行的。当关卡运行且动作发生时，只需要把RememberAction反向函数添加到这一时刻，如果想让时间倒退就可以调用这个函数。 例如当有敌人碰到屏障且消失时，就添加这个函数。在之后点击重新开始后，就可以回放到这一时间点了。这个函数会自动用于再次激活敌人的TimeManager调用，使敌人出现在屏幕上： 1234567891011121314public class Enemy{ void onCollisionWithBarrier() { timeManager.RememberAction(Activate); Deactivate(); } void Activate() { // 进行激活相关的操作 } //.. 剩下的实现} 在时间倒退模式中，我们并不关心碰撞，因为这些碰撞已经在游戏正常运行的时候发生了。只需要倒退游戏状态以更快的速度跳过一些帧即可，这里不需要太强大的设备，因为倒退可以按照正常速度的20倍进行，并且关卡倒退完成就相当于重置所有对象的位置。 但是在某些情况下，也需要将一些变量的值存储在函数中。例如下图中黄色的搬运者敌人，一种在被消灭后会产生细小敌人的角色，它的确切运动需要记录下来，是因为生成的小敌人的运动轨迹会有1秒或2秒的随机延迟。 视觉反馈为了让玩家更好地注意到时间倒退的发生，要添加一些视觉反馈功能。玩家非常喜欢游戏中时间倒退的部分，特别是引入像移动水晶或搬运者这些高端的东西的时候。时间倒退不仅是一个视觉体验，而且还能让玩家再回顾一次如何败给之前的敌人。这可以给玩家在游戏开始前留一些缓冲时间，可以减少一些挫败感。 当玩家成功地通关之后，我们大概都会做相似的事情。比如把界面切换到游戏地图，而不仅仅是打开下一关卡，播放不同类型的动画并且有专门的地方让玩家查看进度。 例如在上图中，我们把红色的敌人高亮了，因为这是玩家需要看到的最重要的东西，同时，这样还会得到一个很好的视觉效果。我们还添加了时间倒退小图标，虽然最开始我们尝试过类似VHS的时间倒退效果，但这不符合我们的视觉风格。这个简单的效果只需使用灰度就能实现，但要让值大于0.7的红色像素保持不变。 另外，如果想要将这个效果应用到相机而非单独的物体中，我们可以将着色器赋给某个材质，并将下面脚本绑定到相机中： 123456789101112using UnityEngine;public class BasicPostEffect : MonoBehaviour{ [SerializeField] Material mat; void OnRenderImage(RenderTexture src, RenderTexture dst) { Graphics.Blit(src, dst, mat); }} 接着，将新材质赋给相机对应的字段。有趣的事情是添加了这个效果之后，玩家最终可以直观的知道发生了什么事情，并且不再点击屏幕创建屏障了。同样有趣的是，有部分玩家观察到有一个倒退回放只会在十次重新开始后出现，但对这个回放丝毫没有印象。 基于上述的讨论，我们还添加了双击屏幕任何地方就能跳过倒退回放的功能，双击屏幕也算是玩家想跳过的时候最常见的反应了。 延伸思考这篇教程还可以举一反三，尝试一些其它用法。例如在游戏中，玩家失败后就及时提供指示信息，然后倒退一点时间并让玩家再次挑战。在我们看来，这比让整个关卡重新开始，或在玩家要行动的时候停下来提示的做法要好。还可以倒退回玩家连续多次失败的关节点。 总结希望您能轻松上手这个功能，实现时间倒退的效果。在下一篇文章中，我们会关注利用了时间轴的游戏设计，了解如何解决一些常见的问题并提升游戏质量。","link":"/blog/2019/05/17/Unity/Unity中的时间控制/"},{"title":"Unity基础","text":"第三方插件及使用 BestHttp : 功能主要有连接池 缓存 超时 代理 重定向 gzip 大文件上传下载 断点续传 socket已经封装了一个类HttpUtils 文档[https://docs.google.com/document/d/181l8SggPrVF1qRoPMEwobN_1Fn7NXOu-VtfjE6wvokg/edit?pref=2&amp;pli=1#](https://docs.google.com/document/d/181l8SggPrVF1qRoPMEwobN_1Fn7NXOu-VtfjE6wvokg/edit?pref=2&amp;pli=1) pro版提供源码https://www.assetstore.unity3d.com/en/#!/content/10872 1.9.8版本下载&lt;http://www.seedpeer.eu/details/10707104/Unity-Asset---Best-HTTP-Pro-Edition-v1.9.8%5BAKD%5D%5BCTRC%5D.html&gt; LitJson : 支持ORM对象关系映射 对象和json互转 和gson一样 官网http://lbv.github.io/litjson/ PoolManager : 对象缓存池用法参考http://blog.csdn.net/henren555/article/details/42100881http://www.xuanyusong.com/archives/2974 工程文件的作用Assembly-CSharp-vs.csproj 和 Assembly-CSharp.csproj ：Visual Studio（带有-vs后缀）和MonoDevelop为C#脚本生成的项目文件。 Assembly-UnityScript-vs.unityproj 和 Assembly-UnityScript.unityproj：相同的项目文件，只不过是为JavaScript脚本。 testproject.sln 和 testproject-csharp.sln：IDE的解决方案文件，第一个包括所有的C#、JavaScript和Boo脚本；而第二个只包括C#脚本，被设计用来在VisualStudio中打开，因为VS不知道如何处理JavaScript和Boo项目。 testproject.userprefs 和 testproject-csharp.userprefs：MonoDevelop用来存储当前打开文件、断点、观测等的配置文件。 Assets：存储所有游戏资源的文件夹，包括脚本、纹理、声音、编辑器定制等。当然是项目中最重要的文件夹。 ProjectSettings：在这个文件夹中Unity存储所有的项目设置，如物理、标签、角色设置等。或者说，所有你从 Edit → Project的菜单中设置的都在这个文件夹中。 Library：被导入资源的本地缓存，当使用外部版本控制系统时应当被完全忽略。 obj 和 Temp：存储构建时产生的临时文件的文件夹，第一个用于MonoDevelop，第二个用于Unity。 看完了以上的内容就可以知道，我们只需要将Assets和ProjectSettings两个文件夹纳入版本控制即可。但在编写.gitignore文件前，还需要以下几个步骤，将设置以文本形式存储以利于版本控制： 在 Edit-&gt;Project Settings-&gt;Editor-&gt;Version Control Mode 中选择 Visible Meta files。 表示以meta文件来记录资源版本。 默认为Disabled，这样在无Library目录情况下会出现各种问题（后面会讲到Library不会提到版本库）。 在 Edit-&gt;Project Settings-&gt;Editor-&gt;Asset Serialization Mode 中选择 Force Text。 表示以纯文本形式保存unity文件。 Mixed和Force Binary都是二进制，不利于版本管理。 将Assets、ProjectSettings目录传到SVN、GIT或其它版本库 别人CheckOut这两目录后，第一次在Unity Editor中OpenProject…后会自动生成Library目录，所以Library无需纳入版本管理 特殊文件夹及作用http://www.xuanyusong.com/archives/3229 渲染顺序和层级关系http://blog.csdn.net/kingsea168/article/details/50252733 1.Unity3d中的渲染顺序如下： 不同的Camera的Depth 相同Camera下的不同SortingLayer 相同SortingLayer下的不同Z轴/Order in Layer 2.改变控件之间的层级关系 (1)同一canvas下： 改变控件transform的SiblingIndex, 123transform.GetSiblingIndex();transform.SetSiblingIndex(int index); //index值越大，越后渲染，层级越大，越显示在前面 (2)不同Canvas下： 设置Canvas下的Sort Order //Sort Order值越大，越后渲染，层级越大，越显示在前面 属性面板定制化http://blog.sina.com.cn/s/blog_5b6cb9500101857b.html http://www.360doc.com/content/15/1205/14/25502502_518083734.shtml","link":"/blog/2019/05/17/Unity/Unity基础/"},{"title":"Unity层级细节（LOD）的使用","text":"层次细节（LOD），它是根据物体在游戏画面中所占视图的百分比来调用不同复杂度的模型的。简单而言，就是当一个物体距离摄像机比较远的时候使用低模，当物体距离摄像机比较近的时候使用高模。这是一种优化游戏渲染效率的常用方法，缺点是占用大量内存。使用这个技术，一般是在解决运行时流畅度的问题，采用的是空间换时间的方式。 下面我们分步骤来构造一个最简单的LOD模型示例：步骤1：准备3组模型，高精度模型，中精度模型，和低精度模型，并按照复杂程度自高向低的为模型命名，如“模型名称LODO0”、“模型名称LOD1”等，最后的数字序号越低，表示复杂程度越高。如图所示： 步骤2：定义一个空对象，添加LODGroup组件，如图所示： 步骤三：分别将刚刚准备好的三种不同精度的模型，拖拽到空对象的LODGroup组件的各个级别上。首先给LOD组件的“LOD 0”（LOD 0表示摄像机最近距离显示）添加对应的模型。（LOD 0 对应高精度模型，然后拖拽到Add上面即可）如图所示： 步骤四：在LOD组件添加模型的过程中会弹出如图所示的提示信息，表明要把添加的模型作为LODGroup组件所属对象的子物体，单击”Yes,Reparent”按钮即可。 步骤五：为使构造的LOD游戏对象显示得更加自然，需要把LOD下的三个子物体进行”对齐“处理。（将其相对于父物体的坐标置为0）如图所示： 步骤六：在Scenes视图中，拖动摄像机分别近距离与远距离观察模型的变化。 注：Project Settings中与LOD组件相关参数 LOD Bias和Maximum LOD Level - 执行unity编辑器菜单：Edit &gt; Project Settings &gt; Quality，会打开Quality Setting窗口，找到Other下的参数，如图所示： Maximum LODLevel：是最大LOD级别，表示游戏中使用的最高LOD级别。在该级别以上的模型不会被使用，并且在编译时忽略。（这将节省存储空间和内存空间）。 Bias LOD：LOD偏离，LOD级别基于物体在屏幕上的大小。当物体大小在两个LOD级别之间，可以选择使用低细节模型或高细节模型。数值取值范围为0-1，数值越接近0，越偏向于选择低细节模型。大白话描述即是：如果该值小那么，摄像机离物体距离稍微有些变化，不同细节物体即会切换，该值大，那么摄像机需要与物体有很大的距离才会切换。","link":"/blog/2019/05/17/Unity/Unity层级细节（LOD）的使用/"},{"title":"Unity显示内嵌网页的研究","text":"最近由于有需要在Unity程序运行在iOS或Android手机上显示内嵌网页。所以遍从网上搜集了一下相关的资料。整理如下： UnityWebCore 从搜索中先看到了这个，下载下来了以后发现这个的原理好像是通过调用浏览器内核，然后将网页渲染到mesh的方式完成的。但遗憾的是只支持windows桌面版本。但还是发出来大家如果有需要可以下载 下载地址： http://pan.baidu.com/s/1nt3FVkd unity-webview 这个是在github上找到的。是一个keijiro的日本人编写。 https://github.com/keijiro/unity-webview-integration 就是根据手机平台在手机上调用相应的WebView组件显示，比如IOS上就是调用UIWebView。同时自己定义了与JavaScript交互的格式，可以在unity的c#代码中相应javascript的调用。需要的朋友可以试试。需要在ios和android上才能看到效果。 根据keijiro编写的项目，在github上你还可以搜索到其他人fork后修改的项目，应该是进行了一些封装和修改，但都是基于keijiro的。 https://github.com/Kogarasi/Unity-Webview https://github.com/gree/unity-webview UniWebView 这个是一个中国人编写的组件，也是根据手机平台调用相应的WebView上组件来显示，也可以支持和javascript的交互。工程很完善。在macos以及手机的系统上直接可以看到运行效果，并且效果很不错。推荐使用的，但是我就不能提供下载地址了。因为这个插件是收费的。为了支持作者还请大家自行购买。 另外还有pc上的插件Awesomium http://www.awesomium.com/ http://labs.awesomium.com/unity3d-integration-tutorial-part-1/ http://www.ceeger.com/forum/read.php?tid=13526&amp;page=1 腾讯浏览内核 http://x5.tencent.com/tbs/ 百度 VR 浏览器com.baidu.vrbrowser 基于Google VR SDK for Unity开发 libaudioplugingvrunity.solibgvrunity.so md5 与 GoogleVR 中的文件一致 Java C# 均未混淆 网页使用EasyWebviewTexture 目前EasyWebviewTexture已经停止购买/下载 Java层使用 ijkPlayer;Unity层使用EasyMovieTexture 浏览器内核使用crosswalk [三星 Gear VR 浏览器com.sec.android.app.svrbrowser](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E4%B8%89%E6%98%9F-gear-vr-%E6%B5%8F%E8%A7%88%E5%99%A8-comsecandroidappsvrbrowser) [基于 Unity 开发](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E4%B8%89%E6%98%9F-gear-vr-%E6%B5%8F%E8%A7%88%E5%99%A8-comsecandroidappsvrbrowser) [Java C# 均未混淆](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E4%B8%89%E6%98%9F-gear-vr-%E6%B5%8F%E8%A7%88%E5%99%A8-comsecandroidappsvrbrowser) [网页使用 ](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E4%B8%89%E6%98%9F-gear-vr-%E6%B5%8F%E8%A7%88%E5%99%A8-comsecandroidappsvrbrowser)EasyWebviewTexture 浏览器内核使用Chromium [大朋 VR 浏览器](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E5%A4%A7%E6%9C%8B-vr-%E6%B5%8F%E8%A7%88%E5%99%A8) [普通原生浏览器， 开启了强制横屏](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E5%A4%A7%E6%9C%8B-vr-%E6%B5%8F%E8%A7%88%E5%99%A8) [下载 ](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#%E5%A4%A7%E6%9C%8B-vr-%E6%B5%8F%E8%A7%88%E5%99%A8)[com.android.browser](http://git.devops.letv.com/liuwencai/DeepoonVR-App/blob/master/com.android.browser.apk);需要先卸载系统的浏览器 [ 关于crosswalk](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#easywebviewtexture) [基于chrome内核解析网页 可以兼容android4.0以下的系统**](http://git.devops.letv.com/LvrBrowser/VR-Browser-Decompile#easywebviewtexture)https://crosswalk-project.org/** Android4.4版本以下webView是基于webkit，4.4以上是基于chromium。国内浏览器都是基于chromium，除了遨游是基于webkit，而safari也是基于webkit。chromium其实也是基于webkit。 浏览器引擎分类 浏览器的内核引擎，基本上是四分天下： Trident: IE 以Trident 作为内核引擎; Gecko: Firefox 是基于 Gecko 开发; WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器 opera浏览器 基于 Webkit 开发。 Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini 注：2013年2月Opera宣布转向WebKit引擎 注：2013年4月Opera宣布放弃WEBKIT，跟随GOOGLE的新开发的blink引擎","link":"/blog/2019/05/17/Unity/Unity显示内嵌网页的研究/"},{"title":"Unity新UI系统概述Auto-Layout","text":"Rect Transform拥有的布局系统对于各种类型的布局是足够灵活的，并且它也可以让你自由放置元素。但是，有时候更多结构化的东西是需要的。 自动布局系统提供了在嵌套布局组（如水平组、竖直组或者格子组）中放置元素的方法。它还允许元素根据包含的内容量自动调整大小。例如，一个按钮可以根据文本的内容自动缩放大小。 自动布局系统是一个构造在基本Rect Transform布局系统之上的系统。它可以选择性的对一些或全部元素使用。 理解布局元素自动布局系统是基 layout elements （布局元素）和 layout controllers（布局控制器）的。布局元素是一个含有RectTransform组件和其它可选组件的游戏对象。Thelayout element has certainknowledge about which size it shouldhave.布局元素不能直接设置自己的大小，但是其它作为布局控制器的组件可以使用它们提供的信息用来为它们计算尺寸。 一个布局元素用下列属性来定义自身： Minimun width（最小宽度） Minimum height（最小高度） Preferred width（首选宽度） Preferred height（首选高度） Flexible width（灵活宽度） Flexible height（灵活高度） 使用布局元素提供信息的布局控制器的例子是 Content Size Fitter 和各种 Layout Group组件。在布局组中如何按大小来布局元素的基本原则如下： 最开始只分配最小尺寸； 如果有足够的空间，分配首选尺寸； 如果有额外的空间，分配灵活尺寸； 含有RectTransform组件的任何游戏对象都可以作为布局元素使用。默认它们的最小、首选和灵活尺寸都是0。某些组件添加到游戏对象上后会改变这些布局属性值。 Image和Text组件就是两个会提供布局元素属性值的例子。它们会改变首选宽度和高度以匹配精灵或者文本内容。 Layout Element组件如果你想覆盖最小、首选或者灵活尺寸，你可以通过为游戏对象添加一个Layout Element组件来完成。 Layout Element组件可以让你覆盖一个或多个布局属性值。勾选对应控件，然后指定你需要覆盖的数值。 请参看Layout Element参考文档获取更多的信息。 理解布局控制器布局控制器一些是用来控制一个或多个布局元素尺寸和位置的组件，它也含有Rect Trasnform组件。一个布局控制器可能控制它的 own layoutelement （自己所在的同一个对象）或者控制 child layout elements 。 Content Size Fitter（内容尺寸适应器）Content Size Fitter用于控制自身布局元素的尺寸。查看自动布局系统执行方式的最简单方法就是增加一个Content SizeFitter组件到含有Text组件的游戏对象上。 如果你将Horizontal Fit或Vertical Fit设置为Preferred Size，RectTransform组件就会自动调整它的宽或高以适应文本呢内容。 请参看Content Size Fitter相关参考文档。 Aspect Ratio Fitter（纵横比适应器）Aspcet Ratio Fitter用于控制自身布局元素的尺寸。 它可以让高度适应宽度，反之亦然，也可以让元素放在父对象的内部或者包裹父对象。Aspcet Ratio Fitter不会考虑最小尺寸和首选尺寸等布局信息。 请参看Aspect Ratio Fitter相关参考文档。 Layout Group（布局组）Layout Group是用来控制子布局元素的大小和位置的控制器。例如，水平的布局组将它的子对象相邻的放置，而格子布局组将它的子对象放在格子里。 布局组不能控制自己的大小。但可以作为一个布局元素被其它控制器控制或者手动设置。 不管布局组如何分配尺寸，大多数时候它都是试图用每一个子布局元素设置的minimum,preferred和flexible尺寸来分配适当数量的空间。布局组也可以任意嵌套。 请参看Horizontal Layout Group, Vertical Layout Group和Gird LayoutGroup相关的参考文档。 驱动Rect Transform属性因为自动布局系统中的布局控制器会自动控制那些不能通过观察窗口或者场景窗口同时进行手动编辑的UI元素的尺寸和位置。而且这些被改变的值在下一次布局计算时会将被重新设置。 为了解决这个问题，Rect Transform有一个 driven properties（被驱动属性）的概念。比如，将HorizontalFit属性设置到Minimum或者Preferred的Content Size Fitter组件会驱动同对象上RectTransform组件的宽度。这个宽度值变为只读并且在Rect Transform的顶端会出现一个小的信息框告知一个或多个属性值被content SizeFitter驱动。 RectTransform属性被驱动除了避免手动编辑之外还有其它原因。仅仅是通过改变分辨率或者游戏窗口大小就会引起布局的改变。这反过来会改变布局元素的尺寸和位置，也就会改变被驱动属性的值。但是并不希望仅仅因为改变了游戏窗口的大小就会造成场景被标记为未被保存状态。为了避免这个问题，被驱动属性的值不会和场景一起保存并且他们的改变也不会引起场景数据的改变。 自动布局系统伴随着会使用一些内建的组件，但是它也可能用自定义的方式创建出新的组件来控制布局。这是通过能被自动布局系统的特殊组件接口来实现的。 如果执行了 ILayoutElement 接口，组件就会被自动布局系统当作一个布局元素来对待。 如果执行了 ILayoutGroup 接口，组件就会驱动子对象的RectTransform。 如果执行了 ILayoutSelfController 接口，组件就去驱动自身的Rect Transform。 自动布局系统会按下面的步骤计算并执行布局： 1.通过调用ILayoutElement组件上的CalculateLayoutInputHorizontal接口计算最小，首选和灵活的宽度。这是按从自下而上的顺序，即子对象比父对象先执行，这样的话，父对象才能拿到子对象的数据以便进行自身的计算； 2.布局元素的有效宽度被ILayoutController组件上的SetLaytouHorizontal接口计算并设置。这是自上而下进行的，即子对象在父对象之后计算，因为子对象的分配需要根据父对象完整的可用宽度来决定。这一步之后，布局元素的RectTransform会拥有新的宽度； 3. 计算高度的最小，首选和灵活值，计算方法和第1步类似，只是接口为CalculateLaytouInputVertical； 4. 计算高度的有效值，计算方法和第2步类似，只是接口为SetLaytouVertical。 触发布局的重建当组件上的一个属性改变后，会导致当前的布局不再有效，就需要做一个布局的重计算。者会被这个调用触发： LayoutRebuilder.MarkLayoutForRebuild(transformas RectTransform)； 这个重建不会立即发生，而是等到这帧的末尾，也就是渲染之前。不立即执行的理由是因为它会导致在同一帧内地进行多次潜在的布局重建，这会导致性能下降。 RectTransform刷新不及时的解决办法： http://www.tuicool.com/articles/AnQv2yB http://www.xuanyusong.com/archives/4234 会触发重建的时机为： 会改变布局的属性设置器(setters)； 这些回调函数种： OnEnable OnDisable OnRectRansformDimensionsChange OnValidate（只有编辑器状态需要，运行时不用） OnDidApplyAnimationProperties unity的LayoutGroup分为三种， Horizontal Layout Group（水平布局）Vertical LayoutGroup（垂直布局）Grid Layout Group （网格布局）以前NGUI没有这东西都是自己写工具实现的。为什么我们要布局？我举个例子，布局的时候可以两个cell 和三个cell都居中显示。如下图所示。。 尤其在奖励窗口，因为获取道具的数量是不固定的，所以需要根据不同数量的道具来居中对齐。如下图所示，Padding 就是偏移，因为我的cell 是95X95，为了居中所以这里设置成 right = -95 top = -95。 Spacing 表示 cell之间的距离。 Child Alignment 表示对齐方式。 Child Force Expand 表示 自适应 宽 和高 在看看cell，注意Layout Group节点下面的所有cell节点都是不能修改RectTransform的。因为cell可能下面会放很多图片，这样我们会用个空的gameObject来当父节点。但是这个gameObject的width 和height 是最小单位，那么Layout Group就不知道怎么来算居中了。如下图所示 这个时候就轮到LayoutElement登场了，用它来设置一个cell的最大或者最小宽度。 如果运行时实例化后的gameObject 直接放在 Layout Group下面即可。Layout Group会自动计算布局，真的是非常方便。 123456789for(int i =0 ;i &lt;10;i++){ GameObject go = (GameObject)Instantiate(Resources.Load&lt;GameObject&gt;(“item”)); go.transform.parent = transform; go.transform.localScale = Vector3.one; } 还有个问题就是隐藏，比如把其中的一个cell setActive = false ，为了不计算隐藏的cell 所以要先把 IngonreLaytout =true 再 setActivity = false 这一切都可以在代码里面来设置。 代码这样即可。 gameObject.GetComponent().ignoreLayout = true; gameObject.SetActive(false); 在unity3D4.6中加入了新的Transform 系统”Rect Transform”。新的Rect Transform对应的是以前旧版本的“Transform 2D”。在这里不过多的介绍Rect Transform，今后我会在之后的文章中讲解到新的Rect Transform。 用过Rect Transform的人都知道，RectTransform中rect的Widh/Health并不能Set，于是这样就导致了Widh/Health不能动态的修改。这里我给大家提供一个方法，通过添加AspectRatio Fitter/Content Size Fitter组件，来实现Widh/Health的动态变化。 Aspect Ratio FitterAspect Mode以什么样的模式去调整矩形的纵横比。 None不使用适合的纵横比。 Width Controls Height让Height随着width自动调节 Height Controls Width让width随着Height自动调节 Fit In Parent宽度，高度，位置和锚点被自动调整，以使该矩形拟合父物体的矩形内，同时保持高宽比。该可以是不包括在本RECT父矩形里面的一些空间。 Envelope Parent宽度，高度，位置和锚被自动调整，以使该矩形覆盖父的整个区域，同时保持高宽比。此矩形可能进一步延伸出，使他比父物体正确。 Aspect Ratio宽高比来执行。这是宽度除以身高。 Content Size FitterHorizontal Fit用什么样的方法来控制宽度 None不使用任何基于布局元素的宽度。 Minimum使用基于布局元素的最小宽度的宽度。 Preferred使用基于布局元件的优选宽度的宽度。 Vertical Fit用什么样的方法来控制高度 None不使用任何基于布局元素的高度。 Minimum使用基于布局元素的最小高度的高度。 Preferred使用基于布局元件的优选高度的高度。 我个人比较习惯用Content SizeFitter，只要管理好子物体的元素布局与大小就可以很好的控制Widh/Health。当然，在使用过程中，根据具体情况来选择适合的方法来实现动态的调整Widh/Health。","link":"/blog/2019/05/17/Unity/Unity新UI系统概述Auto-Layout/"},{"title":"Unity项目设计与管理","text":"不论是对于Unity初学者还是极有经验的开发者来说，项目设计与管理都是迟早需要接触并掌握的知识点。本文将由Unity技术支持工程师田彪，为大家详细全面地介绍Unity项目设计与管理的系统知识。全文分为五大块，今天先为大家介绍上篇策划及美术部分的内容。 在制作游戏时，游戏内容各型各色，但使用Unity设计游戏项目通常大致包括以下几部分： 项目简述 策划文案 美术资源 程序逻辑 性能优化 我们会详细介绍游戏制作过程中的每一步工作，便于Unity开发者以及潜在的开发者对Unity游戏开发有更深的认识，帮助开发者在开发过程中少走弯路。 项目简述想要制作成功的游戏，前期调研工作必不可少，作为开发者，需要了解玩家的喜好，聆听玩家的声音。在游戏完全推向玩家那一刻，该游戏就不再属于项目组，而属于该游戏的受众。游戏项目在启动具体内容开发时，需要确立以下几点： 项目方向市场上存在各种类型的游戏，为了避免游戏过于同质化，项目组的相关负责人需要确定，该项目是定位于何种类型，是RPG还是FPS又或者是Sport类。 时间计划任何项目组制作的游戏最终都需要推向市场，只有得到玩家的支持，游戏才能走得更远。项目启动初期，必定会存在游戏开发的大致时间计划，是8个月还是1年，又或者是18个月? 人员配置游戏项目开发必定存在经费预算，预算包括研发预算和推广预算两部分，项目组的人员配置通常取决于游戏复杂度和项目经费预算。在游戏总体内容固定前提下，人员数量与开发时间大致成反比，但是如果组内人员管理不善，也会存在不协调。所以在项目人员总数确定的情况下，还需明确项目组内具体分配，策划，美术，程序各多少人。 游戏大纲游戏大纲可以让所有项目组开发成员在没有接触游戏前能对将要开发的游戏有一个大致认识，同时也能激发项目组成员的想象力，对游戏内容提出更好的建议。 游戏大纲是目前手游开发过程中被大多项目组忽略的重要一步。 策划文案“兵马未动，粮草先行~~”，优秀的策划文案是项目良好的开端。文案的内容相同，而排版不同，其效果必定也不同。设计文档应该逻辑清晰，排版干净，简单易懂，最好是图文并茂。比如可以是这样的 也可以是这样的(&gt;_&lt;) 美术资源美术是游戏的脸，玩家对游戏的第一印象是美术风格，美术直接决定了玩家是否会在游戏中停留超过十分钟。美术人员在制作相关美术资源时，具体涉及到以下几个部分。 标准 - Standard预先制定完整的美术标准后，在整个项目开发中，美术资源反复修改的频率降低了，美术人员所做的无用工作定然也大大降低。美术资源的标准规范大致涵盖以下几点： 材质数量 模型三角面 纹理尺寸 粒子数量 动画帧频 标准 - Standard模型 - Model当美术人员把模型文件导入Unity编辑器时，若导入设置的各选项设置合理，对游戏性能有着良性影响，导入时需要注意以下事项。 若勾选上图中”Read/Write Enabled”将会使该模型在内存中存在一份拷贝，用于在脚本中对模型进行修改。若该模型不会在脚本中进行修改，则不勾选。 Optimize Mesh 必须勾选，便于引擎底层对Mesh进行优化处理。 Normals &amp; Tangents 中的Normals选项若设置为非Import项，可以降低Memory，并减少ipa/apk包体容量。 着色器 - ShaderUnity引擎在导入Shader到编辑器时，不会对Shader进行编译，而是在开发者发布到具体平台时再编译Shader。在Shader的查看面板可以查询具体信息，如下所示： 如果当前Shader为固定管线模式，点击上图中的Show generated code 按钮，可以查看对应的Vertex/fragment模式代码。 点击上图中的Compile and show code可以生成对应的汇编代码或者GLSL代码。 在工程文件夹的Library/ShaderCache文件下，可以查看所有的Shader缓存文件。 Shader性能分心工具 — AMD GPU ShaderAnalyzer / PVRShaderEditor。 贴图 - TextureUnity支持目前主流的各种图片格式，包括PSD，TGA，PNG，GIF，BMP，JPG，TIFF，PICT等。引擎在导入图片时，会生成引擎自身所使用的贴图数据，在图片导入设置中，需要合理设置各选项。 若勾选上图中”Read/Write Enabled”将会使该贴图在内存中存在一份拷贝，用于在脚本中对其进行修改。若该贴图不会在脚本中进行修改，则不勾选。 若图片尺寸不是2的指数，其所占用内存的大小略大于原始尺寸，并且GPU对其进行读取的速度也有可能会略微偏慢。 若勾选Generate Mip Maps，改贴图所占用内存会变大33%，但对整体性能有很大提升。 在编辑器的Scene窗口下，选择Mipmaps可查看各贴图是否存在精度过剩，若有贴图精度过剩，可通过缩减对应贴图尺寸以节省空间。 光照 - LightingUnity 5使用了全新的光照系统，更优的光照算法，有助于美术人员制作优美的场景，但是使用光照时，除了考虑到场景精美度时，还需要考虑到玩家设备的兼容性。 移动平台推荐使用Baked或 Mixed，避免使用RealTime模式的关照。 Render Mode 不推荐使用Important。 使用Baked模式时，在菜单Window-&gt;Lighting的Object标签页，可通过设置Scale InLightmap的值，以变更lightmap中有多少像素值用于该GameObject的光照计算。 动画 - Animation/AnimatorUnity目前支持Animation和Animator两种动画播放形式。Animation是老式动画系统，Animator作为新的动画系统，有其特有的优势。在使用Animator时，理解如下信息，有助于更好的使用的Animator。 勾选Apply Root Motion表示动画可以更改根节点的位置，如果不勾选，则根节点的位置信息无法通过动画更改，即便在动画帧里有关于根节点的位置信息。 State 表示具体的动画状态信息，若要实现状态切换，通过Transition完成。 Blend Tree 用于多个动画的平滑混合，并且可设置每个动画各自的权重值。 在菜单Window-&gt;Animator窗口中可执行具体操作。 音效 - Audio声音是游戏中不可或缺的部分，好的音乐效果对提升游戏品质有着重大意义，Unity支持主流的各种音乐格式，包括mp3，ogg，wav，aif等。但是，如果音乐格式设置不当，也会降低游戏性能。 基于Vorbis编码的音乐文件（比如ogg）解压后占用10倍于其磁盘大小的内存。 PCM音质高但是压缩率很低。 Mp3格式音乐在iOS设备上有硬件解码器。 Load Type 中的Decompress On Load 选项不推荐用于大文件。大文件推荐使用 Compressed In Memory选项。 Load In Background 如果勾选表示该音频文件将在后台加载，而不会造成主线程阻塞。 之前为大家介绍了项目设计与管理的策划与美术篇，今天这篇文章将继续为大家分享程序与优化相关的内容。 程序逻辑游戏不单是美术资源的展现，存在着频繁的玩家交互行为，所有交互均通过程序脚本实现。在编写程序时，不仅要实现功能，同时也应该考虑到功能的扩展，以及当前功能实现方式对游戏中其他逻辑模块的影响。其主要涉及以下几方面: 逻辑架构在设计程序框架时，建议模块化设计各功能，保持各模块的独立性和封装性，同时单个模块满足“即插即用”。比如，整个游戏逻辑可分为；场景模块，角色模块，UI模块，网络通信模块，战斗模块等。 模块化设计不仅游戏逻辑树简单易懂，便于代码审查，而且也有益于项目后期做性能优化以及Bug检查。比如，调试Bug时，如果禁用某一个模块，游戏正常运行，并且Bug不再出现，则Bug由该模块引擎的概率很高。同理，在做优化处理是，如果禁用某一个模块，发现CPU负载下降很多，则该模块造成性能瓶颈的概率也很高。 脚本应用Unity的脚本使用托管机制，如果某脚本需要挂载到场景GameObject上，则该脚本需要继承于MonoBehaviour。在菜单Edit-&gt;Project Settings -&gt; ScriptExecution下，可更改各类脚本的执行顺序。同时，MonoBehaviour的执行并非使用系统反射机制，而是基于队列存储形式。 Unity引擎本身是由C++代码编写实现，但是游戏开发者编写的代码通常为C#，所以从底层引擎的C++代码到逻辑层的C#之间定然存在托管开销。如果你在UnityProfiler里发现诸如”Overhead”之类的字眼，其中便包括代码的托管开销部分（但不仅限于代码托管开销）。 为了减少代码托管开销，在设计具体脚本时可以做一些优化处理。比如，有一个类ClassA，继承于MonoBehaviour，在其Update函数里会执行具体逻辑。若该类有30个实例同时存在，则会存在30次托管开销，遇到此类情况，建议删除ClassA中的Update函数，转而由自定义的UpdateEx函数替代。同时，额外编写一个ClassAManager类，其缓存一个ClassA的数组或者队列，每次Update时遍历该队列，执行每个实例的UpdateEx函数。 Asset管理Unity中的Asset序列化支持二进制、文本模式、混合模式三种，具体可以在菜单Editor Settings –&gt; Asset Serialization下进行设置，文本模式采用YAML格式，增加可读性。其中每一个资源文件都可以生成一个对应的meta文件。 在制作场景时，建议把场景中的具体GameObject制作成Prefab，而不是直接使用FBX格式，这样便于引擎底层做资源管理。 Unity引擎中各种美术资源都可以编译成AssetBundle，包括纹理，模型，Prefab，AnimationClip，AudioClip等。同时，AssetBundle支持压缩与非压缩格式，开发者可根据项目实际情况进行设置。 动态更新通常动态更新包括美术资源与脚本的更新，美术资源建议使用AssetBundle，脚本更新在Android平台上可使用dll反射实现（仅限Anadroid平台），或者通过其它第三方非官方模式。 性能优化性能优化，是每个游戏项目不可或缺的部分，而且没有一劳永逸的办法，只能一点一滴的实现。在此，我们主要介绍性能优化中必须处理的模块；包括图形，物理，程序，文件等，以及一些用于性能优化的工具。 图形优化 - Graphics要实现图形优化，首先需要熟悉图形学整个渲染管线流程，在此对其作简要介绍： 应用程序 (Application) -&gt; 几何体 (Geometry) -&gt; 光栅化 (Rasterizer)。 其中，几何体阶段具体包括：模型变换(Model &amp; View Transform) -&gt; 顶点着色(Vertex Shading) -&gt;投影变换(Projection) -&gt; 裁切(Clipping) -&gt; 屏幕映射(Screen Mapping)。 光栅化阶段包括： 三角设置(Triangle Setup) -&gt; 三角遍历(Triangle Traversal) -&gt; 像素作色(PixelShading) - &gt; 合并(Merging)。 进行图形优化时，首要步骤即为定位瓶颈在何处，CPU还是GPU？如果瓶颈在GPU，转而对CPU进行优化，是得不偿失的方法，犹如木桶原则，决定木桶能装多少水的是最短的那一块镶板。 如果渲染瓶颈发生在CPU，通常对CPU进行的图形相关优化主要涉及以下几点： 合并模型 （美术人员手动合并或者使用引擎的Batching技术） 在合并模型时，如果被合并的模型并未使用同一材质，那么该合并操作并不会提升性能。同理，如果被合并的模型使用了多重材质，而并不共用贴图，合并操作也不会提升性能。 减少材质的使用数量，尽量 材质共用 纹理拼接 ，把多张小尺寸纹理拼接到同一张大尺寸纹理中 避免使用多重渲染 ，比如反射，阴影，像素光照等 动画优化 ，包括减少骨骼数量，降低动画帧率等 CPU在图形渲染中所承载的计算量没有GPU那么高（前提是设备同时具备GPU和CPU），所以在进行图形优化时，更多是针对GPU端，其具体包括： 模型对象 调整模型三角面是优化美术资源的基本步骤，如果一个角色模型1500面能达到要求，那为何要使用1600面呢。 当场景中某些对象被标记为Static时，禁止在脚本中对其进行位置，朝向，缩放更改，也就是如果需要更改一个对象的Transform属性值，则改对象不应该被标记为Static。 在设计模型时，尽量减少UV映射缝隙和硬边的数量。 光照设计 在移动设备上，尽量使用light map代替实时光照，即便美术人员需要很炫的光照效果，也可以预先由美术人员调节好实时光照效果后再进行light map烘焙。 在某些特定情况下，美术人员可能需要一些特定对象呈现出酷炫的效果，建议使用Shader实现，而非采用增加额外的光源。 减少像素光的数量，不仅可以降低CPU负载，也可以减少GPU消耗。如果场景中某像素光照作用的两个模型对象距离相隔较远，建议不要对该模型对象进行合并操作。 Shader性能 Unity引擎为开发者提供了大量的内置Shader，基本满足开发者的项目需求。如果某些特殊效果需要自定义Shader，在编写Shader程序时，需要注意一些具体细节。 在Shader程序中减少使用或者不使用条件语句。GPU在硬件层面上与CPU有着极大差异，GPU以ALU（逻辑运算单元）著称，而CPU则存在着大量的控制器。 定义变量时，应考虑变量需要的精度位宽（Float为32位，half为16位，fixed为10位），比如定义的变量用于UV坐标，则类型通常选择half即可，如果选择float，则会造成带宽浪费以及计算消耗增加。 避免使用复杂的数学计算函数，比如sin，tan，pow，exp，log等，如果实在需要，建议单个Shader程序里该类复杂函数的使用次数不超过一次。 移动平台避免使用Alpha Test和Alpha Blend指令，如果不可避免，建议使用Alpha Blend，而非Alpha Test。 纹理压缩 压缩纹理不仅可以节省内存，同时也节省运算带宽。同时，建议3D模型贴图都应生成对应的Mipmaps，如果选择生成Mipmaps，则该纹理对应的内存大小相对原先会变大33%左右，但如果不选择生成Mipmaps，则在整体性能上会有很大损失。 LOD使用 Unity中关于LOD的使用有LOD Group和Camera.layerCullDistances两种方式。其中LODGroup主要用于大型模型对象，而Camera.layerCullDistances主要用于碎片化的模型对象。 物理优化 - PhysicsUnity引擎中物理计算更新在FixedUpdate中完成，根据具体的游戏项目，如果游戏物理更新频率不需要太高，可以在菜单Project Settings-&gt; Time 下更改Fixed TimeStep的值。 使用物理碰撞体时，在满足设计要求前提下，建议使用Sphere Collider 或者 Box Collider代替Mesh Collider。MeshCollider和wheel Collider其计算较为复杂，能避免使用则避免之。 被标记为Static的碰撞体，禁止对其移动位置。 如果对象不需要Rigidbody组件，一律删除。 在脚本中如果通过Physics.RaycastAll类似的接口获取固定对象，缓存所得到的对象，禁止通过程序中每帧调用该类接口去获取一个固定的对象。 程序优化 - Scripts程序优化的根本在于设计，在于程序员在编写程序时是否有细心思考。尽管Unity引擎本身由C++编写，但上层逻辑脚本基于Mono体系，内存管理使用GC机制。 GC机制在内存管理存在实时性欠缺，而Mono内存基于内存池，即Mono所申请内存不会得到释放（只有在内存池中内存不够使用时，Mono才会申请新的内存），只会返回内存池。 基于以上机制限制，应禁止频繁申请内存，尽量使用对象池管理对象，比如在Update函数里每帧都new一个数组或者队列，这样极有可能造成GC还未回收先前的内存，内存池中内存不足，又重复申请新的内存，最终Mono内存池越来越大，这是很多开发者都曾遇到的问题。 在Unity引擎层面，可以通过使用IL2CPP技术，使脚本运行速度更快，同时，也可以在Script CallOptimization中设置忽略异常处理。针对具体脚本中负载瓶颈的定位，建议多使用引擎的Profiler工具。 文件优化 - Files如果要降低整体文件大小，首先得知道整个项目中每类资源文件具体大小。在Unity完成相关编译后，选择Console -&gt; Open EditorLog选项，会得到如下图所示的信息: 其包括了具体各类资源的总大小，开发者可按照文件大小建立优化顺序。其中，具体在设计到脚本大小优化时，根据项目组具体情况，可以考虑选择.Net 2.0Subset，在iOS平台也可使用Stripping方法。 同时，建议把Resources文件夹下不曾使用的资源删除，需要使用的资源用AssetBundle代替。Resources文件夹下文件太多会严重影响程序的启动时间。 工具 - Tools在执行性能优化时，有很多工具可以方便开发者快速定位到具体问题，包括引擎自身携带工具以及第三方工具，比如: Profiler Memory Profiler Frame Debugger Test Runner Mac OS -&gt; Instruments Allocations, Time Profiler 最后，Unity的官方手册是Unity开发者执行性能优化的葵花宝典，在你素手无策时，不妨尝试如下步骤：","link":"/blog/2019/05/17/Unity/Unity项目设计与管理/"},{"title":"VR环境下的语音识别","text":"语音识别对于VR领域格外重要，因为它不仅能模拟AI与用户对话，还为用户提供了与任意应用进行沟通的更多选择。手动输入指令可能不太现实，并且应用如果拥有太多按钮或其它GUI元素，也会很快让用户手足无措。但只要能语音控制，那么在VR环境中就很容易开口去进行各种操作。 UnityLabs的虚拟现实（VR）授权平台CarteBlanche将发布一个名为U的个人助理系统，用户可以通过语音控制它，很便利地执行一些操作。UnityLabs研发团队一直在研究可以实现这种声控命令的语音识别与分析工具。 观看下面的视频了解Carte Blanche中的个人助理系统U： 本文第一部分将介绍语音识别的概念和理论。它将简单介绍其相关概念和参考，以帮助读者了解更多关于语音识别方面的信息。第二部分将简单介绍在Unity AssetStore的安装包以及公开的代码库，我们封装了几个语音转文本的解决方案，还有一些用于对比各API的文本翻译的示例场景。 如果想详细了解语音识别的概念和理论以及更多相关的研究，请进入Unity官方中文社区。下面简单为大家介绍语音识别与语义分析的原理，以及UnityLabs为大家提供的语音识别插件。 语音识别与语义分析的原理 语音识别，顾名思义就是通过程序将语音转换成文本 。而 语义分析是其下一步，即将转换出来的文本进一步分析，并确定文本想要表达的意思。即使是目前最好的语音识别和语义分析程序也远称不上完美。虽然人们能直截了当并毫不费力地处理这样的任务，但是当我们试图让程序去执行这两个步骤时，困难程度真的是难以想象。 目前基于统计学的语音识别最重要的部分就是声学建模（AcousticModeling）。这个过程中用于识别声音开始时不同的波形，或者是语音结束时的一些音节。对于声学模型而言，通过查看声波输出，并尝试找出最可能输入的音节是什么，从而分析出说话者究竟想表达什么。 如上图所示，这是声学模型中“x”的发音模型。椭圆表示我们正在尝试识别的音节。它们无法被直接观察到，但它们产生的概率波形（底部）是可以被完整观察到的。因此，波形自身是可以观察的，但必须及时从可观察的状态中分辨出音节。 假设语音已经被成功转换成了文本，现在程序需要分辨该文本究竟是什么“意思”，这时语义分析就可以登场了。人们日常生活中就无时不刻地在进行着语义分析。例如，在阅读这句话之前，你可能已经猜到接下来会是人们如何进行语义分析练习的例子。那是因为你能利用上一句（例如“人们日常生活中就无时不刻地在进行着语义分析”）作为上下文线索，从而很好地预测后续几句。因此，如果想要拥有非常逼真的VR体验，AI必须善于分析玩家的语句并给予正确的反馈。 语音转文本的工具Labs最初研究的语音识别涉及了对现有语音转文本解决方案的评估。我们开发了整合部分解决方案的Unity C#脚本插件并分享在Unity AssetStore。里面包含了示例场景，可以依次对比每个API转换的文本内容，同时允许用户从给定的列表中选定短语，并查看说出该短语后程序判定的准确程度。该代码也可以从Unity代码库中获得。 我们提供的插件是对比目前Unity中几大语音转文本解决方案的简便方法，也很容易将其整合至你的项目。如果想在Unity中尝试其他API，使用该插件也非常简单，只需新建类继承自Speech-To-Text的Service基类，然后即成到示例场景或小部件即可。除了单独的语音文本转换SDK，插件还包括多个辅助类与函数（记录管理器，音频文件的创建和转换等等），以便集成和比较更多的API。 各大语音文本都各有特色，如果有兴趣，可以查看关于 Windows dictation recognition, Google Cloud Speech,IBM Watson, 以及Wit.ai 四种语音识别解决方案的具体信息。 总结与未来规划语音识别很难精准的原因在于有太多的变量需要考虑。对于每一种要识别的语言都需要储存大量的数据，包括所有现存的单词（包括俚语及简写形式），这些单词相互如何结合，语调和口音也可能影响发音，所有人类语言的冗余和矛盾等等更多因素。 发布至Asset Store的自Speech-To-Text插件目前仅集成了几个语音文本转换解决方案，但这些足以用来比较现有语音识别工具的优缺点了。对Unity开发者而言，该插件只是起点，还可以根据具体需求来加入更多功能。 _ _ SimSensei，一款由南加州（USC）学院创新研究部（ICT）开发出来的模拟治疗程序 这项研究源于CarteBlanche项目最初集成AI机器人U来响应声控命令的计划。这涉及到语音文本的转换以及关键字识别。另一个有趣却艰难的挑战是创造出能与用户“对话”的机器人。人们在日常对话中经常包含类似于“嗯”或者是“啊”之类的语气词来表达感受。如果VR应用中的AI机器人不仅能够理解关键字，还能理解人类回话的各个部分，那它将让VR环境的沉浸感进入全新的层次。","link":"/blog/2019/05/17/Unity/VR环境下的语音识别/"},{"title":"unity小技巧","text":"大家使用Unity的经验都有多长呢？Unity编辑器中还有这样的隐藏功能你知道吗？本系列文章为大家介绍Unity使用小技巧，文末附上Unity大中华区EvangelistKelvin Lo录制的视频，希望对你有帮助。 技巧一如果编辑器意外崩溃了，但场景未保存，这时可以打开工程目录，找到/Temp/_Backupscenes/文件夹，可以看到有后缀名为.backup的文件，将该文件的后缀名改为.unity拖拽到项目视图，即可还原编辑器崩溃前的场景。 技巧二所有数值类型的字段，都支持在检视面板中直接输入简单的数值表达式。 技巧三好不容易才调好的坐标，结果发现是在运行模式下，如果退出运行模式就还原了怎么办？可以在检视面板右键点击组件名，在弹出界面中选择CopyComponent，然后退出运行模式后同样右键点击组件名，在弹出界面中选择Paste Component Values即可。 技巧四分别按键盘键Q、W、E、R、T可以依次切换界面上的小工具。除此之外，按数字键2或3还可以切换场景为2D模式或3D模式。 技巧五右键点击检视面板下方的预览窗口即可让预览窗口跳出来，然后自己选择合适的地方停靠，这样切换模型查看就不会影响到其它面板。想让预览窗口回到原位，只需右键点击窗口，在弹出菜单中选择CloseTab即可。 技巧六在层次视图的搜索框中输入完整的脚本或组件名称，即可找到所有绑定了该脚本或组件的对象。或者在搜索框中输入t:加上某个类别如light，即可找到使用同类组件的对象。 技巧七如果想在检视面板查看脚本的私有变量，只需点击Inspectore，在弹出菜单中选择Debug即可。 技巧八如果希望游戏运行第一帧暂停，可以先点击暂停按钮，然后点击播放按钮，这样程序就会在Update函数执行一次后暂停。 技巧九在使用Debug.Log函数时传递游戏对象给第二个参数，既可在点击控制面板的输出信息时自动定位到对应的游戏对象。 技巧十可以借助编辑器自带的标记功能为脚本分类，在检视面板中点击脚本图标下方的小三角，即可为脚本设置颜色或选择图标。 上周为大家分享了两篇Unity小技巧介绍文章，不少开发者反应平时都忽视了这些技巧，原来编辑器已经默默帮大家实现了很多的快捷操作，今天继续为大家介绍第三篇。 技巧一程序员们应该都知道，从项目视图点击右键创建的脚本会自动填充一些代码。其实这些自动填充的代码模板也是可以自定义的。 如果使用Mac，找到应用程序中的Unity.app，右键单击显示包内容，找到Resources&gt;ScriptTemplates文件夹，然后选择你要创建模板的脚本类型，复制一份自己命名并编辑后保存，然后退出编辑器之后重新打开，再在项目视图中右键单击创建，就会出现刚刚添加的脚本类型。打开新建的脚本就可以看到自定义的模板代码。 如果使用Windows，则在ProgramFiles(x86)或ProgramFiles目录下的Unity/Data/Resources/ScriptTemplates文件夹下进行同样的操作即可。 技巧二如果发现Unity打包安卓平台生成的apk体积过大，可以找到PlayerSettings中的安卓平台，默认情况下DeviceFilter设定为FAT(ARMv7+x86)，即同时打包32位和64位。如果只需发布到32位或64位平台则单独选择对应的一种即可。这样可以有效减小包体积。 技巧三在项目视图的搜索框中输入资源名称，可以找到项目中所有具有该关键字的资源。将搜索类型换成Asset Store，则可以找到AssetStore上所有拥有该关键字的资源，并按免费和付费分类。 技巧四如果希望物体可以紧贴地面，但倾斜角度不好调整，这时可以在物体上添加MeshCollider和Rigidbody组件，然后点击运行，借助Unity的物体引擎来计算位置。待物体坠落到地面后复制所有物体，停止运行后删除原先的物体再粘贴运行时复制的内容，并删除所有物体上的MeshCollider和Rigidbody组件即可。 技巧五如果需要拼合两个物体，可以自己分别在两个物体上创建立方体当作锚点，按住V键进入顶点选择模式，然后选择锚定立方体上需要拼合的两个顶点，即可将物体无缝拼接在一起。 如果需要旋转物体，可以按下Cmd/Ctrl键后用鼠标操作旋转，这样可以让物体每次固定旋转15度，最终转到正确位置。 技巧六在场景中按住右键可以以视点为中心查看整个场景。如果希望物体始终保持在焦点处，可以在层次面板双击该物体，然后按住Alt键后用鼠标查看周围场景，并且物体一直位于焦点。 技巧七如果脚本出现错误，Unity编辑器会因为检查到出错而无法进入运行模式，这时可以在项目视图中新建文件夹WebplayerTemplates，然后将出错的脚本拖入此文件夹下，所有位于该文件夹下的文件都会被识别为一般文件从而不会当作脚本被编译，这样就可以运行游戏了。 技巧八如果你的鼠标的中键是可以按下的，可以按住鼠标中键来平移整个场景。或者将鼠标移至物体上后点击中键按钮，编辑器会以平移的方式将物体中心移动鼠标位置。 技巧九当需要拖拽对象至检视面板时，常常会因为操作原因导致检视面板的内容已经改变了。这时可以点击检视面板右上方的锁图标，锁定检视面板，这样不论其它视图如何切换，检视面板都会显示固定内容。 技巧十如果编辑2D游戏的图片时总是不小心点选到背景，可以在Layer里边设置哪些层是锁定或不可见的，将背景层锁定后就不能点选到它了，这样在编辑时就不会出现误操作。但锁定图层后还是可以从层次面板上选中背景来进行调整，这样就不用每次反复锁定和解锁图层。 前面已经为大家分享了三篇Unity小技巧相关的文章，涉及到编辑器操作及脚本等多方面的内容，掌握这些小技巧能大大提高我们的开发效率。今天为大家介绍第四篇。 技巧一在float型的字段前添加范围属性声明如[Range(0, 10)]，即可在检视面板中使用滑动条来设置该字段的值。 技巧二对一组字段使用属性声明[Heaader(“XX”)]，可以在检视面板中将字段进行分组。 技巧三从Unity 5开始，新建场景默认会带有天空盒，可以利用Unity自带的天空盒材质来自定义天空盒颜色。 技巧四如果常常不小心进入播放模式后编辑场景内容，其实可以依次点击菜单项Edit &gt; Preferences &gt; Colors &gt;Playmode设置编辑器在进入播放模式后的颜色，与正常模式下明显区分开来。 技巧五将鼠标聚焦于编辑器内的某个窗口，按住Shift＋空格键，可以将该窗口最大化至编辑器范围或者还原为原先大小。 技巧六如果场景中某个物体与另一物体相对的位置、旋转及缩放均保持不变，那么在调整目标物体的方向时，可以先选中编辑器界面的小工具，按住Ctrl/Cmd＋Shift键，这样在操作其中一个物体时，另一个也会随之变化。 技巧七如果脚本中有变量名打错，需要批量修改，在Mac上可以按住Cmd＋R键，Windows上按住F2键，然后选中需要修改的变量名进行批量修改。 技巧八使用UI中的Mask组件时，需要指定一张图片作为遮罩对其子对象进行裁剪，取消勾选组件上的Show MaskGraphic则可以在保持裁剪效果的同时隐藏Mask本身的图片。 技巧九在设置所有颜色类型的属性时，可以将当前颜色值加入预设，该预设会保存在本地且可以在不同的工程间共用。 技巧十你知道矩形工具也可以用来操作3D物体吗？","link":"/blog/2019/05/17/Unity/unity小技巧/"},{"title":"unity生命周期","text":"继承MonoBehavior的生命周期 主要的生命周期： Reset : 用户第一次添加组件时或用户点击见组件面板上的Reset按钮时调用 OnAwake:当脚本实例被载入时Awake被调用，一般可以在这个地方将当前脚本禁用:this.enable=false，如果这样做了，则会直接跳转到OnDisable方法执行一次，然后其它的任何方法，都将不再被执行。如果当前脚本处于可用状态，则正常的执行顺序是继续向下执行OnEnable，当然我们可以在另外一个脚本中实现这个脚本组件的启动：this.enab=true; OnStart: Start仅在Update函数第一次被调用前调用。 OnUpdate：渲染一帧之前被调用。这里是大部分游戏行为代码被执行的地方，除了物理代码。 LateUpdate:是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。如果后面写了Reset，则会又回到Update OnGUI: 渲染和处理GUI事件时调用，当然，如果你使用了NGUI，这个生命周期的事情就不用考虑了。 FixedUpdate:这个函数在每个物理时间步被调用一次。这是处理基于物理游戏行为的地方。常用于移动模型等操作。不受帧率影响，默认0.02s，如果卡帧了Update就不会再执行，而FixedUpdate则继续执行。 Edit-&gt;preject setting -&gt;Time -&gt; (Inspector监测视图）Fixed Timestep 设置刷新时间 OnDisable:当对象变为不可用或非激活状态时此函数被调用。这个时候，脚本并不会被销毁，在这个状态下，可以重新回到OnEnable状态（enable=true）。 OnDestroy: 当MonoBehaviour将被销毁时，这个函数被调用。当前脚本的生命周期结束。 建议一般在Awake中做一些初始化，在Start中获取游戏对象 其他的生命周期： OnPreCull:在相机剔除场景之前调用此函数。相机可见的对象取决于剔除。OnPreCull 函数调用发生在剔除之前。 OnBecameVisible/OnBecameInvisible:在对象对于相机可见/不可见时调用此函数。 OnWillRenderObject:如果对象可见，则为每个相机调用一次此函数。 OnPreRender:在相机开始渲染场景之前调用此函数。 OnRenderObject:在完成所有常规场景渲染后调用此函数。此时，可使用 GL 类或 Graphics.DrawMeshNow 绘制自定义几何图形。 OnPostRender:在相机完成场景渲染后调用此函数。 OnRenderImage（仅限专业版）：在完成场景渲染后调用此函数，以便对屏幕图像进行后处理。 OnGUI:在每帧上多次调用此函数，以响应 GUI 事件。程序首先将处理 Layout 和 Repaint 事件，然后再处理每个输入事件的 Layout 和keyboard/鼠标事件。 OnDrawGizmos: 用于在场景视图中绘制小图示 (Gizmos)，以实现可视化目的。","link":"/blog/2019/05/17/Unity/unity生命周期/"},{"title":"unity避免代码被反编译","text":"我最近研究发现80%以上的Unity3D游戏都没有做代码混淆。而且我觉得反编译后的代码可阅读性更加好。今天把《锁链战记》的代码和资源都反编译出来了。 1.Unity编译后最终会将代码编译在dll里面，无论是ios还是Android解开包以后都可以拿到dll，路径在Data/Managed/Assembly-CSharp.dll 2.IOS其实不用做代码混淆，应该是苹果帮我们做了，反编译以后只能看到变量名，和方法名，但是具体的方法体内的代码是万全看不到的，不过安卓不行！！！ 3.所以如果要反编译某游戏的代码，一定要去找它的Android版本，然后解开包，拿出它的Assembly-CSharp.dl 4.在Windows上去下载.NET Reflector8这个反编译dll的软件，网上一大堆，但是一定要下载最新版本。目前我没找到可以在MAC上反编译dll的软件，如果那位大神知道请一定要告诉我噢。 5.mac 上反编译，请看我的另一篇文章 http://www.xuanyusong.com/archives/2675 使用步骤 把Assembly-CSharp直接拖进去。 所有的代码，类名，方法名，方法体，一清二楚。这代码，这缩进，嘿嘿。AssetbundleManager应该就是他们自己写的处理Assetbundle的下载管理类了。 如果有心的话你可以全局搜索一下”http”关键字 可能就能找到CDN或者Assetbundle的下载地址了。 如果避免自己的游戏被反编译 大家可以去搜索一下Codeguard这个插件，（网上可以找到破解版）它可以防止你的代码被反编译。它主要是改名，把你的方法名，方法体名子修改了，变量名修改了。虽然有点弱但是它的优点是比较方便，因为可以在打包的时候自动完成代码混淆的工作。不用自己去手工做混淆，我不知道有没有更好的自动混淆方法，如果那位大神知道请一定要告诉我。 另外，还有一个更高级的办法。直接找unity官方，它们有防止代码反编译的服务，绝对有效。还有一个方法 用Crypto Obfuscator for .Net这东西可以完美混淆Unity for Android的代码，也支持打包APK 时批处理脚本完成混淆部分。但是MAC 上不支持，看了一大堆混淆.net的方法，全部是基于windows上的。 有哪位大神知道怎么在mac上进行Andorid的混淆工作。。 作者：雨松MOMO","link":"/blog/2019/05/17/Unity/unity避免代码被反编译/"},{"title":"从Android读取Unity-assets下的图片并保存为Bitmap格式","text":"在unity工程下，建立文件夹“Plugins/Android/assets”，然后把需要的图片放在这个文件夹下，并取一个好用的名字 （”Logo.png”），这个名字在Android这边是需要用到的，unity的工作做完之后，在Android这边写代码： 1234567891011121314151617AssetManager asm = getAssets();InputStream inputStream =null; try { inputStream = asm.open(&quot;Logo.png&quot;); }catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace();}Drawable d =Drawable.createFromStream(inputStream,null);Bitmap B = ((BitmapDrawable) d).getBitmap(); 这样就完成了unity图片的读取与转化Bitmap。","link":"/blog/2019/05/17/Unity/从Android读取Unity-assets下的图片并保存为Bitmap格式/"},{"title":"使用Unity进行增强现实中的光照和阴影的渲染","text":"我们曾经为大家介绍过Unity中光照和阴影有关的内容，比如Unity实时阴影实现图解。近几年，增强现实应用开发者越来越多，相应的开发技巧被众多开发者所关注。本文将指导您对Unity和VuforiaSDK增强现实的应用进行光照和阴影渲染。这背后的理论同样适用于其它的SDK和游戏引擎。 光照与阴影的重要性想要使用Unity创建优质的游戏场景，光照和阴影的设置是非常重要的，因为它们被用来制造场景的景深，从而让画面更加自然与真实。缺少阴影会使得画面缺乏真实感，如果没有阴影，您无法区分出人物是站在平面上还是漂浮在空中，如下图所示。 从上图中可以看出有无阴影的明显区别，在AR增强现实应用开发中也是如此。 渲染光照和阴影存在的问题如果想在Unity中渲染光照或者阴影，就必须有网格。但是，添加网格会遮挡相机视图。如下图所示，灰色的平板挡住了桌面。 如果把灰色平板换成透明材质不就可以解决这个问题么？其实不然，如果使用透明材质替代上图的灰色平面，使用Unity的标准着色器就无法在上面投射阴影（虽然可能有些自定义着色器可以投射）。如下图所示，使用透明材质可以看到桌面，但没有阴影。 解决思路：分别渲染光照和阴影最初的想法是利用叠加(Addition)或者复合(Multiplication)效果，可以分别渲染光照和阴影，然后使用后处理效果将阴影和相机视图结合起来。 我们可以将场景内容分为三层：背景、光照和阴影、3D对象，然后将它们合并到一起。 _ _ 背景层：只包含相机渲染的图像 _ _ 光照和阴影层 _ _ 3D对象层 _ _ 三层叠加的最终效果 上图由于桌面太黑了，因此可能看不清阴影。您可以查看下面的视频了解更多详情。 详细步骤如果您还不清楚Unity结合Vuforia开发AR应用的基本步骤，可以先看看之前的文章《5分钟使用Unity制作AR应用》。 总得来讲，我们需要添加三个相机分别用来渲染背景、光照和阴影以及增强现实对象，这三个相机的视角与Vuforia的Augmented RealityCamera相机完全一样，本例中使用CopyCameraData.cs来实现上述功能。另外，由于无法将对象的阴影渲染到另外一层，因此需要将其进行拷贝，我们需要编辑副本的“MeshRenderer”，将“Cast Shadows”属性设置为“Shadow Only”。最后，本例中使用了ColorFX插件实现后处理效果。您可以在文末查看教程的视频演示，并点击【阅读原文】下载教程相关素材。 使用Unity实现本例中AR环境下的阴影与光照渲染效果的详细步骤如下： 1）新建场景，删除新场景默认的主相机和平行光。 2）将Vuforia中的预制件ARCamera拖拽至场景中，在检视面板中加入App License Key(Vuforia 的激活码),并勾选配置文件的Datasets(数据集)中的Load MyTargets Database和Active。 3）将Vuforia 中的预制件ImageTarget拖拽至场景中，设置好Database中的目标识别图。 4）新建一个Plane，将其Position的Y值设为-0.01(略低于识别目标图)。 5）新建一个立方体和球体，作为光照遮挡物。 6）新建一个点光源，设置好光照范围和阴影类型。 7）将ARCamera的中的World CenterMode由FIRST_TARGET改为SPECIFIC_TARGET。并将目标图像(ImageTarget)指定给World Center。 8）在ARCamera下再创建两个Camera分别命名为Light Camera和ARObject Camera。 9）打开Tags &amp; Layers检视面板，分别添加Background Layer、Light Layer 和 ARObject Layer三个层。 10）设置ARCamera下方的三个相机。将Light Camera的Culling Mask设置为Light Layer和Default；ARObjectCamera的Culling Mask设置为ARObject Layer和Default；Camera 的Clear Flags设置为SolidColor, Culling Mask设置为Background Layer,并且其子节点BackgroundPlane的Layer设置为Background Layer。 11）分别为Light Camera和ARObject Camera 添加 CopyCameraData脚本并将TargetCamera指定为Camera。 12）调整一下相机的视角，创建一个空对象命名为_ARObjects并将Plane、Cube和Sphere拖拽至其下方。然后复制_ARObjects对象并命名为_LightLayer Objects，并将Cube和Sphere的Cast Shadows 设置为Shadows Only。将_Light LayerObjects的层级设置为Light Layer。 13）删除_ARObjects中的 Plane，并将其层级设置为ARObject Layer。 这样三个相机对应三层就设置好了。最后在Camera上添加后处理脚本对图像进行混合。本例中使用ColorfulFX插件进行混合以实现后处理效果，您也可以使用其它的后处理脚本。在LightCamera上添加RendderTextureToBlend脚本并将Camera赋给脚本的Blend属性。最后将ARObject Camera的ClearFlags设置为Depth only并调整深度值即可。调整混合模式选取最理想的效果。 您可以跟着下面的视频一起练习一下： 在教学视频中所涉及一些自定义的脚本，您可以点击【阅读原文】进行下载。 总结希望本文可以帮您实现增强现实项目中的光照和阴影渲染。","link":"/blog/2019/05/17/Unity/使用Unity进行增强现实中的光照和阴影的渲染/"},{"title":"使用Raycast显示射击轨迹","text":"本教程适合Unity新手或对Raycast不甚了解的开发者，主要介绍Raycast的用途并绘制出射击游戏的射线轨迹。 最终效果 本课程包括鼠标控制相机旋转、射击物体、显示射线轨迹及准星三个部分，最终实现效果如下： 在讲解实现步骤之前，先来了解Raycast的概念。Raycast可以简单理解为游戏场景中由某点发出的隐形射线，它能返回所有被射线射中的游戏对象的详细信息及RaycastHit结构体，RaycastHit结构体包括该游戏对象的Transform引用和射线与游戏对象交点的坐标等等。这里需要注意的是，只有带有碰撞体的游戏对象才能被射线检测到。 想了解更多关于Raycast及RaycastHit的信息，请点击［阅读原文］进入Unity官方中文社区。 另外要注意的是， 在FPS游戏中，射击目标通常都是玩家眼睛朝向的位置，也就是相机正前方的中心点。所以这里瞄准物体并进行碰撞检测的射线并非我们需要绘制的射击轨迹。 ** ** 实现步骤 1 准备工作首先点击［阅读原文］进入Unity官方中文社区，下载本课程所需的工程资源并导入Unity项目中。 找到Let’s Try Shooter &gt;Scenes文件夹下的ShootingWithRaycasts场景并双击打开。其中已经设置好了本课程所需的游戏环境，FPSController来自Unity自带的StandardAssets资源包，下面新增了Gun游戏对象： 使用鼠标旋转场景中的相机，手臂会随着鼠标进行旋转。 2 添加射击脚本下面来添加射击脚本。在Scripts目录下新建C#脚本命名为RaycastShoot，将该脚本拖拽至层级视图的Gun游戏对象上，然后双击脚本进行编辑。RaycastShoot脚本的主要作用是发出射线，射击物体并造成伤害，播放射击音效，显示射击轨迹并等待一段时间后消失。脚本代码如下： 注意，射线应该从玩家眼睛所处位置向眼镜前方射出，玩家眼睛即相机所在位置。 上述代码涉及到还未添加的脚本与游戏对象，下面的步骤将一一说明。 3 添加LineRenderer组件为Gun游戏对象添加LineRenderer组件，用于在运行时的游戏视图中绘制出射击轨迹，只有子弹发出时才会显示轨迹，所以默认是隐藏的，取消勾选组件名左侧的复选框隐藏组件。另外这里并未指定材质，所以绘制出来的射线会是粉红色的，你也可以自行添加材质。 4 创建GunEnd这里需要一个空的游戏对象作为枪头处的位置标记，在层级视图中选中Gun游戏对象，右键单击在弹出菜单中选择CreateEmpty新建游戏对象，重命名为GunEnd。为GunEnd添加标签以便在场景中显示更明显，然后调整GunEnd的坐标至枪头处，这里设置为(0.36,-0.18, 1)： 将创建好的GunEnd游戏对象拖拽至Gun对象的RaycastShoot脚本的GunEnd字段。 5 添加RayViewer脚本上面提到了，瞄准物体并进行碰撞检测的射线并非我们需要绘制的射击轨迹。需要绘制的射击轨迹已经在RaycastShoot脚本中完成了，接下来添加RayViewer脚本，使用Debug功能在场景中绘制用于瞄准的射线，也就是从相机位置发出的射线。 新建C#脚本重命名为RayViewer，将脚本拖拽至Gun游戏对象上，双击脚本进行编辑。RayViewer脚本代码如下： 到此射线的处理与绘制就差不多了，运行场景会看到场景视图出现了两条射线： 找到层级视图中Environment &gt;Targets下，有两个TargetBox对象，选中对象会发现上面已经绑定了ShootableBox脚本。ShootableBox脚本的功能非常简单，CurrentHealth表示对象当前血量，初始总血量为3，脚本代码如下： 在上方的RaycastShoot脚本中已经添加了射击处理的逻辑，当射中立方体时，此时运行场景，已经可以进行射击了，但还是比较难进行瞄准。下面来添加准星。 6 添加UI在层级视图右键单击，弹出菜单中依次选择UI &gt; Image新建Image，点击Color右边的颜色选取按钮，将Image的颜色设置为红色： 然后点击Rect Transform的锚点设置按钮，按下Alt/Option键同时选择中心点，让准星永远出现在屏幕中心位置： 设置好后再次点击运行，大功告成啦！再看看运行效果：","link":"/blog/2019/05/17/Unity/使用Raycast显示射击轨迹/"},{"title":"关于界面高度height的计算","text":"首先看一个例子，新建一个Panel，在下面添加两个Button，分别命名为Button、Button2。 1、给Panel添加一个VerticalLayoutGroup组件，ChildForceExpand属性中勾上Width。 2、给Button、Button2添加LayoutElement组件，其中Button的FlexibleHeight设置为0.3，Button2的FlexibleHeight设置为0.1 3、将Panel的高度设置为100 这时我们发现，Button的高度是70，Button2的高度是30。奇怪，这个高度是怎么算出来的呢？ 网上搜索一番，竟然很少有人讨论uGUI的AutoLayout，尤其是flexibleWidth/Height属性的意义，官方文档也语焉不详。这时只能放大招了，uGUI已经开源，索性把代码拉下来看看到底怎么实现的。下面是托管代码的地址： https://bitbucket.org/Unity-Technologies/ui uGUI的AutoLayout有三个核心接口，定义在ILayoutElement.cs文件中： ILayoutElement ILayoutController ILayoutIgnorer 结构很清晰，由ILayoutElement提供布局信息，ILayoutController来控制布局，ILayoutIgnore提供给UI忽略AutoLayout的能力。 例子中使用的VerticalLayoutGroup继承自HorizontalOrVerticalLayoutGroup，这个类实现了布局的核心逻辑，代码量不多，我就直接贴上来了 其中SetChildrenAlongAxis方法清晰地阐释了minHeight,preferredHeight,flexibleHeight的涵义。 为了帮助理解，我们先定义几个概念。我们把当前UI所有同级并参与自动布局的组件的preferredHeight总和称为totalPreferredHeight，minHeight的总和称为totalMinHeight，父UI的真实高度称为realHeight。总结如下： 1、 minHeight 在自动布局中，此UI最小高度不会小于minHeight。这个参数定义了realHeight &lt; totalMinHeight时，当前子UI的height为minHeight。 2、 preferredHeight 可以理解为，UI自身希望的高度。 当totalMinHeight &lt; realHeight &lt; totalPreferredHeight时，realHeight处于totalMinHeight和totalPreferredHeight之间一定百分比，把这个比例应用到每一个接受自动布局的子UI上，即是我们最终得到的效果 3、 flexibleHeight 当realHeight &gt;totalPreferredHeight时，父UI会剩下一部分高度。flexibleHeight就是告诉AutoLayout系统，应该怎么瓜分剩下的高度，使子UI填充满父UI。flexibleHeight默认是-1，不会进行扩充。当flexibleHeight 0时，flexibleHeight值作为权重来计算当前子UI最终的高度，公式如下： height = preferredHeight + (flexibleHeight / totalFlexibleHeight) * (realHeight - totalPreferredHeight) flexibleHeight示意图 弄清楚这些概念后，我们再看一下文章开头的例子。 button1的flexibleHeight=0.3，button2的flexibleHeight=0.1，minHeight和preferredHeight都没有设置，按道理高度应该分别是75、25。为什么会出现70、30？ 查一下ILayoutElement的实现类 ILayoutElement实现类 发现Image和Text实现了ILayoutElement，而我们的按钮中默认是有一个Image组件的，用脚本获取这个Image然后打印它的preferredHeight，发现等于10 再套用flexibleHeight的计算公式： 这里有个问题，一个GameObject上挂载两个ILayoutElement组件，是怎么决定用哪个的？这个可以在LayoutUtility.cs中找到答案： 原来LayoutElement有一个layoutPriority属性用来决定优先级，这个属性暂时还没有在编辑器中暴露，也许后续版本会加强这方面的能力。 AutoLayout系统会选用优先级最高的ILayoutElement里相应属性返回。Image和Text的优先级默认是0，LayoutElement默认优先级是1。所以正常情况会使用LayoutElement中的设置，但我们的例子中，LayoutElement没有设置preferredHeight，LayoutElement里布局相关的初始值都是-1，所以还是使用了Image的preferredHeight:10。 【结语】 其实，只要官方文档描述详细一些，根本没必要浪费时间去查这个来龙去脉。这几天在学习Swift，苹果人性化的ProgrammingGuide加上iBooks的配合，使得学习这门语言真是件轻松愉快的事情。相比之下，Unity简直是在虐待开发者。Unity、Unreal、Cryengine等最近也为争市场弄得头破血流，除了降价开源提供新特性之外，完善文档也是不容忽视的工作，毕竟开发者才是这些厂商真正的衣食父母。","link":"/blog/2019/05/17/Unity/关于界面高度height的计算/"},{"title":"可用于VR环境的列表视图框架","text":"本文为大家介绍Unity Labs团队开发的可用于VR环境的列表视图框架，代码和示例场景可以从Unity AssetStore获取，也可从Unity开源Git仓库中获取。 Unity Labs介绍Unity Labs是专注于研究VR、AR、图形及游戏开发等相关前沿技术的团队。目前Unity Labs最主要的项目就是Unity VR编辑器以及CarteBlanche项目。Unity Labs团队介绍请看： Carte Blanche项目介绍Carte Blanche项目（PCB）是Unity实验室的研发计划，目的是为非技术用户提供VR-in-VR的编程工具。CarteBlanched的核心设计理念主要在于对象与行为的设计，它的一种典型示例：用户可以抓取虚拟的扑克牌，并将其放置在虚拟的桌子上，借助动作捕捉控制器真实地与卡牌互动。概念视频： PCB卡牌系统介绍 PCB的卡牌系统比传统滚动列表要复杂得多。PCB系统要求卡牌必须能够动态出现或消失，且用户可以触碰到它们。此外，VR应用程序对性能的要求也极其苛刻。还要尽量避免实例化/销毁场景对象，因为这些操作的开销非常之大。最后为了可重用性，外观和感觉上的统一性起见，还需要一套可扩展的解决方案，能够使用其他类型的UI元素制造出相似的体验。 Unity Labs为列表视图开发了一套通用框架作为PCB卡牌系统的基础。代码和示例场景可以从Unity AssetStore获取，也可从Unity开源Git仓库中获取。示例效果如下： Model与View的解耦 本框架的一个设计目标是遵循MVC或MVVM设计模式，将数据的显示逻辑（view）与数据的状态（mode）本身解耦。对于任何一个框架而言，框架本身应自动处理列表当前状态的显示。这种实现下我们只需要考虑数据的当前状态，而不用关心如何处理视图的更新。 框架本身会负责搞定这些列表行的内存分配问题，并在列表元素离开屏幕时回收并重用在接下来要显示的元素上。 更为具体的技术实现细节请访问Unity官方中文社区阅读！ 资源包List View框架现已发布至Unity资源商店，一同开放的还有Unity BitBucket官方账号的开源Git仓库。本文的框架是CarteBlanche项目资源包的首个模块，其他的模块将会陆续地以同样地方式对社区公布。 本框架可以归结为三个C#类：ListViewController（以两个文件存在），ListViewItem与ListViewItemData。这些类用来控制并处理鼠标与触摸的输入以及列表需要显示的数据。在处理游戏手柄，UI，手势输入或VR设备时这些类也能让开发者很方便地完成需要的特性。在PCB的例子中，列表视图的控制是通过手势追踪控制器来实现的。 更为具体的技术实现细节及代码下载请访问Unity官方中文社区！","link":"/blog/2019/05/17/Unity/可用于VR环境的列表视图框架/"},{"title":"各种移动GPU压缩纹理的使用方法","text":"1. 移动GPU大全目前移动市场的GPU主要有四大厂商系列： 1）Imagination Technologies的PowerVR SGX系列 代表型号：PowerVR SGX 535、PowerVR SGX 540、PowerVR SGX 543MP、PowerVR SGX 554MP等 代表作 ：Apple iPhone全系、iPad全系，三星I9000、P3100等 2）Qualcomm(高通)的Adreno系列 代表型号：Adreno 200、Adreno 205、Adreno 220、Adreno 320等 代表作 ：HTC G10、G14，小米1、2等 3）ARM的Mali系列 代表型号：Mali-400、Mali-T604等 代表作 ：三星Galaxy SII、Galaxy SIII、Galaxy Note1、Galaxy Note2(亚版)等 4）nVIDIA(英伟达)的Tegra系列 代表型号：nVIDIA Tegra2、nVIDIA Tegra3等 代表作 ：Google Nexus 7，HTC One X等 2. 压缩纹理的必要性1）首先要说一下图像文件格式和纹理格式的区别。常用的图像文件格式有BMP，TGA，JPG，GIF，PNG等； 常用的纹理格式有R5G6B5，A4R4G4B4，A1R5G5B5，R8G8B8, A8R8G8B8等。 文件格式是图像为了存储信息而使用的对信息的特殊编码方式，它存储在磁盘中，或者内存中，但是并不能被GPU所识别，因为以向量计算见长的GPU对于这些复杂的计算无能为力。这些文件格式当被游戏读入后，还是需要经过CPU解压成R5G6B5，A4R4G4B4，A1R5G5B5，R8G8B8,A8R8G8B8等像素格式，再传送到GPU端进行使用。 纹理格式是能被GPU所识别的像素格式，能被快速寻址并采样。 举个例子，DDS文件是游戏开发中常用的文件格式，它内部可以包含A4R4G4B4的纹理格式，也可以包含A8R8G8B8的纹理格式，甚至可以包含DXT1的纹理格式。在这里DDS文件有点容器的意味。 OpenGL ES 2.0支持以上提到的R5G6B5，A4R4G4B4，A1R5G5B5，R8G8B8，A8R8G8B8等纹理格式，其中R5G6B5，A4R4G4B4，A1R5G5B5每个像素占用2个字节(BYTE)，R8G8B8每个像素占用3个字节，A8R8G8B8每个像素占用 4个字节。 对于一张512512的纹理的话，R5G6B5格式的文件需要占用512KB的容量，A8R8G8B8格式的文件需要占用1MB的容量；如果是10241024的纹理，则各需要2M和4M的容量，这对于动辄需要几十、几百张甚至更多纹理的游戏，上G容量的游戏在移动平台上是不容易被接受的(当然，还是有1、2G的大作的，里面包含了几千张的纹理)。 聪明的设计师们在想，有没有其他办法，既能表现丰富的色彩和细节，又能是最小失真的情况下，达到更小的纹理容量呢。压缩纹理格式应运而生(当然，并不是在移动平台后才有的产物)。 3. 常见的压缩纹理格式基于OpenGL ES的压缩纹理有常见的如下几种实现： 1）ETC1（Ericsson texture compression) 2）PVRTC (PowerVR texture compression) 3）ATITC (ATI texture compression) 4）S3TC (S3 texture compression) ETC1: ETC1格式是OpenGL ES图形标准的一部分，并且被所有的Android设备所支持。 扩展名为: GL_OES_compressed_ETC1_RGB8_texture，不支持透明通道，所以仅能用于不透明纹理。 当加载压缩纹理时， 参数支持如下格式： GL_ETC1_RGB8_OES(RGB，每个像素0.5个字节) PVRTC: 支持的GPU为Imagination Technologies的PowerVR SGX系列。 OpenGL ES的扩展名为: GL_IMG_texture_compression_pvrtc。 当加载压缩纹理时， 参数支持如下几种格式： GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG (RGB，每个像素0.5个字节) GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG (RGB，每个像素0.25个字节) GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG (RGBA，每个像素0.5个字节) GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG (RGBA，每个像素0.25个字节) ATITC: 支持的GPU为Qualcomm的Adreno系列。 支持的OpenGL ES扩展名为: GL_ATI_texture_compression_atitc。 当加载压缩纹理时， 参数支持如下类型的纹理： GL_ATC_RGB_AMD (RGB，每个像素0.5个字节) GL_ATC_RGBA_EXPLICIT_ALPHA_AMD (RGBA，每个像素1个字节) GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD (RGBA，每个像素1个字节) S3TC: 也被称为DXTC，在PC上广泛被使用，但是在移动设备上还是属于新鲜事物。支持的GPU为NVIDIA Tegra系列。 OpenGL ES扩展名为: GL_EXT_texture_compression_dxt1和GL_EXT_texture_compression_s3tc。 当加载压缩纹理时， 的参数有如下几种格式： GL_COMPRESSED_RGB_S3TC_DXT1 (RGB，每个像素0.5个字节) GL_COMPRESSED_RGBA_S3TC_DXT1 (RGBA，每个像素0.5个字节) GL_COMPRESSED_RGBA_S3TC_DXT3 (RGBA，每个像素1个字节) GL_COMPRESSED_RGBA_S3TC_DXT5 (RGBA，每个像素1个字节) 由此可见，Mali系列GPU只支持ETC1格式的压缩纹理，而且该纹理不支持透明通道，有一定局限性。 以上压缩纹理格式每个像素大小相对A8R8G8B8格式的比例，最高压缩比是16:1，最低压缩比是4:1，对于减小纹理的数据容量有明显作用，相应在显存带宽上也有明显优势，从而提高游戏的运行效率(此特性没有绝对数值，根据每个游戏的用法和瓶颈点不同而有差别)。 4. OpenGL中相关API的使用1） 获得GPU的型号 glGetString(GL_RENDERER) 2） 获得GPU的生产厂商 glGetString(GL_VENDOR); 3） 获取GPU支持哪些压缩纹理 string extensions = (const char*)glGetString(GL_EXTENSIONS); a. 判断是否支持ETC1格式的压缩纹理 return (extensions.find(“GL_OES_compressed_ETC1_RGB8_texture”)!=string::npos); b. 判断是否支持DXT格式的压缩纹理 return (extensions.find(“GL_EXT_texture_compression_dxt1”)!= string::npos || extensions.find(“GL_EXT_texture_compression_s3tc”)!= string::npos); c. 判断是否支持PVRTC格式的压缩纹理 return (extensions.find(“GL_IMG_texture_compression_pvrtc”)!= string::npos); d. 判断是否支持ATITC格式的压缩纹理 return (extensions.find(“GL_AMD_compressed_ATC_texture”)!= string::npos || extensions.find(“GL_ATI_texture_compression_atitc”)!= string::npos); 4） 填充压缩纹理数据 void glCompressedTexImage2D ( GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data); 这里的参数不做详细解释，其中internalformat即是压缩纹理格式的类型。 5. 压缩纹理工具的使用每种压缩纹理以及相应的厂商都提供了压缩纹理的工具，工具都分两个版本： a. 可视化转换工具 (给美工或小白少量使用) b. 命令行转换工具 (给程序批量使用) 下面对每个工具的用法进行说明。 1）Imagination Technologies PowerVR工具下载地址 http://www.imgtec.com/powervr/insider/sdkdownloads/index.asp?installer=W… 可视化转换界面 命令行转换脚本 for %%i in (*.tga) do PVRTexTool.exe -f PVRTC4 -i %%i (将本目录下的所有tga文件，转换成”PVRTC4”编码格式的pvr文件，不带mipmap) 详细使用说明：PvrTexTool.exe /? 2）Qualcomm Adreno工具下载地址 [https://developer.qualcomm.com/mobile-development/mobile-technologies/ga…](https://developer.qualcomm.com/mobile-development/mobile-technologies/gaming-graphics-optimization-adreno/tools-and-resources) 可视化转换界面 命令行转换脚本 for %%i in (*.tga) do QCompressCmd.exe %%i %%i.ktx “ATC RGBA Explicit” yes (将本目录下的所有tga文件，转换成”ATC RGBA Explicit”编码格式的ktx文件，带mipmap) 详细使用说明：QCompressCmd.exe /? 3）ARM Mali工具下载地址 [http://malideveloper.arm.com/develop-for-mali/mali-gpu-texture-compressi…](http://malideveloper.arm.com/develop-for-mali/mali-gpu-texture-compression-tool/) 可视化转换界面 命令行转换脚本 for %%i in (*.tga) do PVRTexTool.exe -f ETC -i %%i (将本目录下的所有tga文件，转换成”ETC”编码格式的pvr文件，不带mipmap这里还是使用的PVRTexTool.exe，也可以使用QCompressCmd.exe) 详细使用说明：PVRTexTool.exe /? 4）nVIDIA Tegra可以使用DirectX SDK中自带的DirectX Texture Tool进行转换 可视化转换界面 命令行转换脚本 for %%i in (*.tga) do texconv.exe -f DXT5 %%i (将本目录下的所有tga文件，转换成”DXT5”编码格式的dds文件，不带mipmap) 详细使用说明：TexConv.exe /? 本文来源： http://www.cnblogs.com/luming1979/archive/2013/02/04/2891421.html 主流纹理压缩标准：ETC、PVRTC、S3TC 首先说OpenGL ES标准中的，2.0版规范中将ETC(Ericsson TextureCompression)作为基本的纹理压缩标准，这是大部分移动GPU都会支持的纹理标准。OpenGL ES3.0中还引入了ETC2、EAC纹理压缩格式，二者基本一致，只不过EAC主要用于1-2通道数据的情况。目前ECT2还在改进中，除了高通的Adreno320之外还没有移动GPU支持，Tgera 4也不行。 此外，OpenGL ES 3.0中还有一种可选纹理压缩格式——ASTC(Adaptive Scalable TextureCompression，自适应扩展纹理压缩)，这是ARM提出的，去年被Khronos组织认可，纳入到标准中来，不过并不是强制性的，目前也只有Mali-T600系列支持。 Imagination旗下的PowerVR GPU支持的是PVRTC(PowerVR texturecompression)和ETC，高通的Adreno 2xx系列支持ETC之外还有3Dc和ATITC。 后两者都是原来的ATI开发的，Adreno320除了前面三种标准之外还支持ETC2纹理压缩。 ARM的Mali-300/400系列支持ETC，Mali-T600还多了ASTC纹理支持。 NVIDIA的Tegra系列更有趣。之前的说法称Tegra支持自己的纹理格式， 实际上除了通用的ETC之外，Tegra支持的纹理叫做S3TC(S3Texture Compression)，也被称为DXTn或者DXTC。 S3TC是S3公司在1999年引入的，后来被DX 6.0和OpenGL1.3吸收为官方标准，DXTC相当于Windows版的名字，S3TC是OpenGL中的名字。 说到S3TC，之前苹果和HTC大打专利战的时候就涉及到了这个标准。S3已经归为VIA威盛旗下，HTC和威盛又有同一个老板——王雪红。为了支援HTC打专利战，威盛去年就把S3部门出售给了HTC，算是左手倒右手吧。 S3TC是DX显卡都支持的标准，NVIDIA也在Tegra中支持了这个标准，S3TC根据不同算法又分为DXT1-DXT5这五个级别，Terga支持的实际上是DXT1、DXT3和DXT5。 Vivante的GC系列也支持ETC和S3TC，跟NVIDIA的Tegra路线相同。 以前都说Vivante支持的是NVIDIATegra的纹理数据，实际上二者是选择了共同的路线而已，DXT也不是NVIDIA的专利。 目前来说我们能常用到的纹理压缩主要是ETC、PVRTC、S3TC、ATITC这四种种。 主流紋理压缩格式优缺点 常见的TC格式压缩比 先来看压缩比。如果无失真的PNG容量是5.4MB，那么S3TC和ETC都能压缩到1.1MB，PVRTC压缩最高，可压缩到528KB，不过PVRTC的问题在于它只支持PowerVR系列GPU，有排他性，高通的Adreno支持的ATITC同样有排他性，其他厂商并不支持。 ** ** ETC是最通用的纹理压缩格式，不过ETC并不招厂商待见，因为ETC纹理压缩不支持Alpha通道，只能用于压缩不透明的材质，不过ETC也有自己的优点，几乎所有的安卓设备都可以支持ETC压缩的GPU加速。 S3TC无论压缩速度还是压缩比都不错，也支持GPU加速，而且是桌面显卡通用的压缩格式，看起来是最完美的选择，可惜的是移动市场跟PC不一样，大家各自为王，NVIDIA现在还没强大到让其他GPU厂商低头采用S3TC标准的程度，因为S3TC说到底还是一种私有的标准，有专利上的麻烦。 ETC2压缩标准补全了ETC1不支持Alpha通道的缺陷，支持更高质量的RGBA(RGB+Alpha)压缩，而ARM提出的ASTC标准在压缩速度和质量上比S3TC要好，但是这两种压缩格式都是新出的，支持的厂商实在太少了。","link":"/blog/2019/05/17/Unity/各种移动GPU压缩纹理的使用方法/"},{"title":"在Unity中实现小地图（Minimap）","text":"小地图的基本概念 众所周知，小地图（或雷达）是用于显示周围环境信息的。首先，小地图是以主角为中心的。其次，小地图上应该用图标来代替真实的人物模型，因为小地图通常很小，玩家可能无法看清真实的模型。 大多数小地图都是圆形的，所以本文也将创建圆形小地图。通常小地图周围还会有一些按钮和标签，本文也会介绍。 创建场景新建场景，导入Unity Chan模型作为玩家，导入两个机器人作为敌人。 游戏视图添加一个新的相机。依次点击菜单项GameObject -&gt; Camera新建相机并命名为Minimap Camera。然后将该相机设为UnityChan的子对象，并将其坐标设为Unity Chan上方10个单位，把相机对准Unity Chan模型。 设置Minimap Camera为了达到更好的效果，将position设为(0, 10, 0)，rotation设为(90, 0, 0)。现在相机显示效果如下： 但这还不是小地图。现在运行场景，你可以看到只有上图中的内容显示出来。我们必须把小地图做成一个UI元素。 渲染到UI层这里需要用到Render Texture来实现。依次点击菜单项Assets -&gt; Create -&gt; Render Texture新建RenderTexture并命名为Minimap Render Texture。 选中Minimap Camera后在检视面板将Target Texture字段设为Minimap Render Texture。 现在运行场景会发现Minimap Camera中的内容不见了，这是因为它被显示到了新建的Render Texture中。 下面新建Canvas来添加UI元素。依次点击菜单项GameObject -&gt; UI -&gt; Canvas来新建Canvas。 这里需要使用Raw Image在Canvas中显示Render Texture的内容。依次点击菜单项GameObject -&gt; UI -&gt; RawImage新建Raw Image，然后命名为Minimap Image，在检视面板中将Texture字段设为Minimap Render Texture。 现在Minimap Camera相机中的内容可以作为UI来显示了！ 下面将小地图变为圆形。这里需要用到一张简单的遮罩纹理： 新建Image并为其添加Mask组件，将Image的Source Image字段设为上面的遮罩图片，并将Minimap Image设为Mask的子对象。 注意：为了达到更好的视觉效果，记得禁用遮罩纹理的Mipmap。 现在小地图显示效果如下： 小地图的白色背景看起来不太美观，给它加一个边框： 为了让整个小地图移动起来更方便，新建一个空的GameObject命名为Minimap，并将所有对象设为Minimap子对象。 最后将小地图移至屏幕右上角。 效果不错吧？但这还不是真正意义上的小地图，只是相机从顶部取景的图像而已。接下来通过Layer来做一些设置！ 设置Layer这里需要新建一个Layer。依次点击菜单项Edit -&gt; Project Settings -&gt; Tags andLayers新建Layer命名为Minimap。 然后新建三个球体。一个设为蓝色代表Unity Chan。将该球体设为Unity Chan的子对象，并将其Layer设为Minimap。 对两个机器人进行同样的操作，将球体改为红色。 现在最关键的一步来了！选中Main Camera并确保其Culling Mask中不包括Minimap这一层。 然后选中Minimap Camera让其Culling Mask只包括Minimap这一层。 现在这个小地图看起来就比较完善了！ 最后步骤还可以做一些调整。首先将Minimap Camera的Clear Flags设为SolidColor并将其颜色改为浅灰色，以便让小地图背景与小球的对比度更强。 还可以添加一些UI元素来操作小地图。这里使用标签作为示例，最后结果如下： 当角色或机器人移动时，小地图上的小球也会即时更新位置。 到此整个制作小地图的教程就结束了，如有任何问题，欢迎来下方评论区留言！ 本文来源于：http://blog.theknightsofunity.com 作者：Piotr Korzuszek","link":"/blog/2019/05/17/Unity/在Unity中实现小地图（Minimap）/"},{"title":"截图的实现","text":"下面是我总结的、在u3d中的，三种截屏方法： 1、使用Application类下的CaptureScreenshot方法。 1234void CaptureScreen(){ Application.CaptureScreenshot(&quot;Screenshot.png&quot;, 0);} 这个方法，截取的是某一帧时整个游戏的画面，或者说是全屏截图吧。 a、不能针对某一个相机（camera）的画面，进行截图。 b、对局部画面截图，实现起来不方便，效率也低，不建议在项目中使用： 虽然CaptureScreenshot这个方法呢，本身是不要做到这一点的。但是我们可以走曲线救国的路线来实现它。思路是这样的：你可以先用这个方法截图一个全屏，然后通过路径获取到这个截图；接下来就通过相关的图形类来，取得这个截图的局部区域并保存下来，这样就能得到一个局部截图了。在这里我就不实现它了，不过有兴趣的可以试试，肯定是可以实现的。 2、这第二个截图的方法是，使用Texture2d类下的相关方法，也可实现截图功能。 123456789101112131415161718/// &lt;summary/// Captures the screenshot2./// &lt;/summary/// &lt;returnsThe screenshot2.&lt;/returns/// &lt;param name=&quot;rect&quot;Rect.截图的区域，左下角为o点&lt;/paramTexture2D CaptureScreenshot2(Rect rect);// 先创建一个的空纹理，大小可根据实现需要来设置Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false);// 读取屏幕像素信息并存储为纹理数据，screenShot.ReadPixels(rect,0, 0);screenShot.Apply();// 然后将这些纹理数据，成一个png图片文件byte[] bytes = screenShot.EncodeToPNG();string filename = Application.dataPath + &quot;/Screenshot.png&quot;;System.IO.File.WriteAllBytes(filename, bytes); Debug.Log(string.Format(&quot;截屏了一张图片: {0}&quot;, filename)); // 最后，我返回这个Texture2d对象，这样我们直接，所这个截图图示在游戏中，当然这个根据自己的需求的。 return screenShot; 截全屏： 12CaptureScreenshot2( new Rect( Screen.width*0f, Screen.height*0f,Screen.width*1f, Screen.height*1f)); 截中间4分之1: 12CaptureScreenshot2( new Rect( Screen.width*0.25f, Screen.height*0.25f,Screen.width*0.5f, Screen.height*0.5f)); 这里使用了几个Texture2d类的方法，使用上也有一些要注意的地方，自己看吧。 当然，这个方法也不要到实现针对某个相机的截图的功能。不过关键接口已经出现了，它就是Texture2d.ReadPixels()，这段就不说了，接着往下看吧！ 3、这第三个方法，最牛了，可以针对某个相机进行截图。 这样的话，我就可截下，我的Avatar在游戏中场景中所看的画面了，UI界面（用一个专门的camera显示）什么的是不应该有的。要做到这一点，我们应该将分出一个camera来专门显示ui界面，用另一个camera相机来场景显示场景画面。然后，我们只对场景相机进行截屏就是了。所以这关键点就是：如何实现对某个相机进行截屏了。这里用到一个新的类是RenderTexture。 代码如下： 1234567891011121314151617181920212223242526272829303132/// &lt;summary/// 对相机截图。/// &lt;/summary/// &lt;returnsThe screenshot2.&lt;/returns/// &lt;param name=&quot;camera&quot;Camera.要被截屏的相机&lt;/param/// &lt;param name=&quot;rect&quot;Rect.截屏的区域&lt;/paramTexture2D CaptureCamera(Camera camera, Rect rect);// 创建一个RenderTexture对象RenderTexture rt = new RenderTexture((int)rect.width, (int)rect.height, 0);// 临时设置相关相机的targetTexture为rt, 并手动渲染相关相机camera.targetTexture = rt;camera.Render(); //ps: --- 如果这样加上第二个相机，可以实现只截图某几个指定的相机一起看到的图像。//ps: camera2.targetTexture = rt; //ps: camera2.Render(); //ps:-------------------------------------------------------------------// 激活这个rt, 并从中中读取像素。 RenderTexture.active = rt;Texture2D screenShot = new Texture2D((int)rect.width, (int)rect.height, TextureFormat.RGB24, false );screenShot.ReadPixels(rect,0, 0);// 注：这个时候，它是从RenderTexture.active中读取像素screenShot.Apply();// 重置相关参数，以使用camera继续在屏幕上显示 camera.targetTexture = **null** ;//ps: camera2.targetTexture = null; RenderTexture.active = **null** ; // JC: added to avoid errorsGameObject.Destroy(rt);// 最后将这些纹理数据，成一个png图片文件 byte[] bytes = screenShot.EncodeToPNG(); string filename = Application.dataPath + &quot;/Screenshot.png&quot;;System.IO.File.WriteAllBytes(filename, bytes); Debug.Log(string.Format(&quot;截屏了一张照片: {0}&quot;, filename));return screenShot; 多的我就不说了，相关知识自己去找资料吧，因为我也不懂！ 直接上图了。 无ui的全屏图： 只有ui的全屏图： 有ui有场景的全屏图（只指定这两个相机哦，相关提示在代码的“//ps”中）： 转载请在文首注明出处：http://blog.csdn.net/anyuanlzh/article/details/17008909","link":"/blog/2019/05/17/Unity/截图的实现/"},{"title":"提取游戏资源的三个工具","text":"这两天无意间又发现了两个提取Unity游戏资源的工具，这会儿刚好有时间我就码点字总结一下。 一、disunity 因为之前写过了所以这里就不介绍了 。Unity3D研究院之mac上从.ipa中提取unity3D游戏资源（六十六） http://www.xuanyusong.com/archives/2584 二、UnityAssetsExplorer 下载地址：http://www.nexusmods.com/pillarsofeternity/mods/27/?tab=2&amp;navtag=http%3A%2F%2Fwww.nexusmods.com%2Fpillarsofeternity%2Fajax%2Fmodfiles%2F%3Fid%3D27&amp;pUp=1 百度云下载地址： http://pan.baidu.com/s/1AwTrg 如果你想解Unity5的游戏包，请使用 UnityAssetsExplorer 1.5 以上版本。 百度云下载地址： http://pan.baidu.com/s/1sjkjSJz 如下图所示，OpenAssets-File 选一个 .asset 或者一个.assetbundle 然后ExtractAll即可导出，感觉只是在disunity上增加了一个可视化的功能。 三、UnityStudio 其实我觉得这个工具非常牛逼、前面两个都只能把资源解开，预览图片资源得用别的工具才能打开。然而UnityStudio可以直接在自己的软件上查看图片、shader、文本、还能直接播放音频、甚至还能看场景Hierarchy视图的树状结构。强烈推荐用UnityStudio啊。 下载地址：http://forum.xentax.com/viewtopic.php?f=10&amp;t=11807 百度云下载地址： http://pan.baidu.com/s/1hqjMnOg UnityStudio最新版本下载 支持unity5.x https://github.com/Perfare/UnityStudio/releases 直接预览图片 直接播放音频 查看场景树状结构 查看Shader代码。 查看文本内容 如果你想解Unity5的游戏包，请使用 UnityAssetsExplorer 1.5 以上版本。 百度云下载地址：http://pan.baidu.com/s/1sjkjSJz 因为Unity提供资源的工具很多，所有有些团队为了避免别人提取所以对资源进行了加密，最近又发现了一个神器基于硬件层面查看内存贴图，这样就直接无视对方加密了。。 下载地址在这里https://developer.nvidia.com/gameworksdownload 下载Tegra Graphics Debugger 支持Mac Linux Windows 安装好以后连上安卓机器， 这里安卓的机器得是Tegra 机型查询&lt;http://www.nvidia.cn/object/tegra-phones-cn.html&gt; 然后要选一个abd的路径，在android的sdk里platform-tools/adb 接着选择一个游戏包名，Lanch一下就会自动启动游戏，并且开始分析。 点击Capture Frame 截取一帧，然后选择Texture就可以看内存了， 给力吧。。 如果没有Tegra的手机，用高通的也可以，高通这个给力可以批量导出所有图片 下载地址：https://developer.qualcomm.com/software/adreno-gpu-sdk/tools 参考资料：http://zenhax.com/viewtopic.php?t=12","link":"/blog/2019/05/17/Unity/提取游戏资源的三个工具/"},{"title":"脚本批量打包渠道包研究","text":"最近在研究Unity3D脚本批量打包，比如在Android平台下各种不同分辨率和不同内存大小的机器，可能还有不同的渠道包，不同渠道可能用的SDK都不一样，这一切的一切都表明你的代码无法做到自适应的，除非批量打包提供各个平台的预定义标签#define。 Unity默认提供了一些预定义标签如： UNITY_EDITOR : 编辑器模式下。 UNITY_STANDALONE：PC Mac Linux模型下。 UNITY_IPHONE：IOS模式下。 UNITY_ANDROID：ANDROID模式下。 还有很多预定义标签、大家可以在这里看到：http://docs.unity3d.com/Documentation/Manual/PlatformDependentCompilation.html 官方提供的标签属于比较大的范围标签，比如我希望在UNITY_ANDROID下面在写一些自定义的标签、类似 QQ UCCMCC这样的渠道标签该如何呢？如下图所示，ProjectSetting打包界面每个平台都会有Scripting DefineSymbols这个选项，可以在这里添加每个平台下对应的自定义标签（多个标签用“;”号隔开），这里我设置的是Android平台，如果IOS也需要打这样的渠道标签那么也要在IOS页面ScriptingDefine Symbols选项处添加对应的标签。 标签做出来了就好办了，然后在代码中我们可以这样来写。如果在Scripting Define Symbols中没有出现的标签默认是不启用的，就像 #define Test 一样，会自动被注释掉。 然后我们看看如何实现脚本批量打包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155using UnityEngine;using UnityEditor;using System.Collections;using System.Collections.Generic;using System;using System.IO;public class MyEditorScript{ //得到工程中所有场景名称 static string[] SCENES = FindEnabledEditorScenes(); //一系列批量build的操作 [MenuItem(&quot;Custom/Build Android QQ&quot;)] static void PerformAndroidQQBuild() { BulidTarget(&quot;QQ&quot;, &quot;Android&quot;); } [MenuItem(&quot;Custom/Build Android UC&quot;)] static void PerformAndroidUCBuild() { BulidTarget(&quot;UC&quot;, &quot;Android&quot;); } [MenuItem(&quot;Custom/Build Android CMCC&quot;)] static void PerformAndroidCMCCBuild() { BulidTarget(&quot;CMCC&quot;, &quot;Android&quot;); } [MenuItem(&quot;Custom/Build Android ALL&quot;)] static void PerformAndroidALLBuild() { BulidTarget(&quot;QQ&quot;, &quot;Android&quot;); BulidTarget(&quot;UC&quot;, &quot;Android&quot;); BulidTarget(&quot;CMCC&quot;, &quot;Android&quot;); } [MenuItem(&quot;Custom/Build iPhone QQ&quot;)] static void PerformiPhoneQQBuild() { BulidTarget(&quot;QQ&quot;, &quot;IOS&quot;); } [MenuItem(&quot;Custom/Build iPhone QQ&quot;)] static void PerformiPhoneUCBuild() { BulidTarget(&quot;UC&quot;, &quot;IOS&quot;); } [MenuItem(&quot;Custom/Build iPhone CMCC&quot;)] static void PerformiPhoneCMCCBuild() { BulidTarget(&quot;CMCC&quot;, &quot;IOS&quot;); } [MenuItem(&quot;Custom/Build iPhone ALL&quot;)] static void PerformiPhoneALLBuild() { BulidTarget(&quot;QQ&quot;, &quot;IOS&quot;); BulidTarget(&quot;UC&quot;, &quot;IOS&quot;); BulidTarget(&quot;CMCC&quot;, &quot;IOS&quot;); } //这里封装了一个简单的通用方法。 static void BulidTarget(string name, string target) { string app_name = name; string target_dir = Application.dataPath + &quot;/TargetAndroid&quot;; string target_name = app_name + &quot;.apk&quot;; BuildTargetGroup targetGroup = BuildTargetGroup.Android; BuildTarget buildTarget = BuildTarget.Android; string applicationPath = Application.dataPath.Replace(&quot;/Assets&quot;, &quot;&quot;); if (target == &quot;Android&quot;) { target_dir = applicationPath + &quot;/TargetAndroid&quot;; target_name = app_name + &quot;.apk&quot;; targetGroup = BuildTargetGroup.Android; } if (target == &quot;IOS&quot;) { target_dir = applicationPath + &quot;/TargetIOS&quot;; target_name = app_name; targetGroup = BuildTargetGroup.iPhone; buildTarget = BuildTarget.iPhone; } //每次build删除之前的残留 if (Directory.Exists(target_dir)) { if (File.Exists(target_name)) { File.Delete(target_name); } } else { Directory.CreateDirectory(target_dir); } //==================这里是比较重要的东西======================= switch (name) { case &quot;QQ&quot;: PlayerSettings.bundleIdentifier = &quot;com.game.qq&quot;; PlayerSettings.bundleVersion = &quot;v0.0.1&quot;; PlayerSettings.SetScriptingDefineSymbolsForGroup(targetGroup, &quot;QQ&quot;); break; case &quot;UC&quot;: PlayerSettings.bundleIdentifier = &quot;com.game.uc&quot;; PlayerSettings.bundleVersion = &quot;v0.0.1&quot;; PlayerSettings.SetScriptingDefineSymbolsForGroup(targetGroup, &quot;UC&quot;); break; case &quot;CMCC&quot;: PlayerSettings.bundleIdentifier = &quot;com.game.cmcc&quot;; PlayerSettings.bundleVersion = &quot;v0.0.1&quot;; PlayerSettings.SetScriptingDefineSymbolsForGroup(targetGroup, &quot;CMCC&quot;); break; } //==================这里是比较重要的东西======================= //开始Build场景，等待吧～ GenericBuild(SCENES, target_dir + &quot;/&quot; + target_name,buildTarget, BuildOptions.None); } private static string[] FindEnabledEditorScenes() { List&lt;string&gt; EditorScenes = new List&lt;string&gt;(); foreach (EditorBuildSettingsScene scene in EditorBuildSettings.scenes) { if (!scene.enabled) continue; EditorScenes.Add(scene.path); } return EditorScenes.ToArray(); } static void GenericBuild(string[] scenes, string target_dir, BuildTarget build_target, BuildOptions build_options) { EditorUserBuildSettings.SwitchActiveBuildTarget(build_target); string res = BuildPipeline.BuildPlayer(scenes, target_dir, build_target, build_options); if (res.Length &lt;= 0) { throw new Exception(&quot;BuildPlayer failure: &quot; + res); } }}{ 这里面忘说了一点，如果我们希望在性能高的手机上用一套好的资源，在性能低的手机上用一套差一点的资源该怎么办？那么首先我们先搞清楚Unity会把什么资源打包，什么资源不打包？ 1.Resources文件夹 Resources文件夹是一个只读的文件夹，通过Resources.Load()来读取对象。因为这个文件夹下的所有资源都可以运行时来加载，所以Resources文件夹下的所有东西都会被无条件的打到发布包中。建议这个文件夹下只放Prefab或者一些Object对象，因为Prefab会自动过滤掉对象上不需要的资源。举个例子我把模型文件还有贴图文件都放在了Resources文件夹下，但是我有两张贴图是没有在模型上用的，那么此时这两张没用的贴图也会被打包到发布包中。假如这里我用Prefab，那么Prefab会自动过滤到这两张不被用的贴图，这样发布包就会小一些了。 2.StreamingAssets StreamingAssets文件夹也是一个只读的文件夹，但是它和Resources有点区别，Resources文件夹下的资源会进行一次压缩，而且也会加密，不使用点特殊办法是拿不到原始资源的。但是StreamingAssets文件夹就不一样了，它下面的所有资源不会被加密，然后是原封不动的打包到发布包中，这样很容易就拿到里面的文件。所以StreamingAssets适合放一些二进制文件，而Resources更适合放一些GameObject和Object文件。StreamingAssets只能用过www类来读取！！ 3.最后凡是在Hierarchy视图对象引用过的资源文件也会被无条件打包到发布包中。如果有一部分文件可能没有在Resources文件夹下也没有在StreamingAssets文件夹下，也没有被Hierarchy视图游戏对象引用，那么这类资源是不会被打包到发布包中的。 OK！搞清楚这一点就好办了！在处理不同包对应不同资源包的时候，尽量让可配置的资源放在Resources或StreamingAssets文件夹下，运行的时候程序动态的来读取它们，最后显示在游戏中就可以了。在批量打包前，在Project视图下创建不同包的资源文件夹，然后脚本 AssetDatabase 动态的将资源拷贝至Resources或StreamingAssets 文件夹中， http://docs.unity3d.com/Documentation/Manual/StreamingAssets.html 12345678[MenuItem(&quot;Custom/Build Android QQ&quot;)]static void PerformAndroidQQBuild(){ //先把资源拷贝到Resources或者StreamingAssets AssetDatabase.CopyAsset(&quot;path&quot;, &quot;newPath&quot;); //然后开始编译版本 BulidTarget(&quot;QQ&quot;, &quot;Android&quot;);} 代码中说到还有一个重要的东西就是PlayerSettings类。因为在Build的时候不同平台下可能会有一些PlatformSettings是不一样的，所以需要在脚本里面动态的设置它，强大的参数列表在这里：http://docs.unity3d.com/Documentation/ScriptReference/PlayerSettings.html。根据情况来批量构建自己的工程吧～ 另外，由于IOS工程比较特殊，使用这样的方法我们只能生成出来多个IOS的工程文件，但是这并不是最终发布的版本。如果想一键生成.ipa文件的话。 1.通过命令行来BuildIOShttp://docs.unity3d.com/Documentation/Manual/CommandLineArguments.html 2.通过shell来自动打包 1生成的xcode工程，最终生成渠道包。 这两种方法我已经在网上找到了答案，今天太晚了就不在研究了，下一篇的时候我在补上。 祝大家学习愉快！！不早了，晚安！欢迎大家一起来讨论与学习，嘿嘿！！！ 代码下载地址：http://vdisk.weibo.com/s/HUf2W","link":"/blog/2019/05/17/Unity/脚本批量打包渠道包研究/"},{"title":"解决Unity-Font字体破碎问题","text":"使用Unity的动态字体绘制文字的时候，在多次打开面板时出现文字破裂问题。 文字渲染原理： 通过RequestCharactersInTexture函数向Font请求更新文字信息，然后使用GetCharacterInfo获取文字信息来渲染。在调用GetCharacterInfo的时候要保证所有文字都通过RequestCharactersInTexture请求过了，这样文字才能顺利的被渲染出来。如果请求的时候，Font内部维护的texture不够用了，就会触发textureRebuildCallback的回调，通知外部使用Font的对象，其内部的texture被更新了，外部应该重新刷新。而这个重新刷新的过程就往往会导致界面上的文字破裂，因为外部的Texture重新计算并调整大小，其上面原来的文本信息就会被破坏。 解决方法： 在启动游戏时通过预加载的方法改变Font内部维护的Textrue的大小，让其有足够的空间容纳外部请求的文本信息。 我的方法是在网上下载一个常用汉字3500字的txt文档，将它导入到项目中，然后再启动游戏后首先使用这个文本向Font请求信息，这样便会在一开始就将Font内部的Texture设置的较大。 123456789101112public static string generalCharacter = null;public static void PreLoadGeneralText(){ if (generalCharacter == null) { TextAsset txt = LoadResource(&quot;Base/Font/generalText&quot;) asTextAsset; generalCharacter = txt.ToString(); } Font font = GetDefaultFont().dynamicFont; font.RequestCharactersInTexture(generalCharacter);} 其中LoadResource方法是封装的一个加载方法， 这里可以替换成 Resources.Load; GetDefaultFont()方法是加载我项目中使用的默认字体","link":"/blog/2019/05/17/Unity/解决Unity-Font字体破碎问题/"},{"title":"UGUI一个优化效率小技巧","text":"无意间发现了一个小技巧。如下图所示，可以发现UGUI的Image组件的RaycastTarget勾选以后会消耗一些效率，为了节省效率就不要勾选它了，不仅Image组件Text组件也有这样的问题。一般UI里也就是按钮才需要接收响应事件，那么大部分image和text是是不需要开RaycastTarget的。 但是问题就来了，Unity默认在hierarchy窗口Create-UI-Image 、Text的时候就会自动帮我们勾选上RaycastTarget，一个复杂点的界面至少也300+个Image和Text， 总不能一个个取消吧。 所以我们可以重写Create-UI-Image的事件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[MenuItem(&quot;GameObject/UI/Image&quot;)] static void CreatImage() { if(Selection.activeTransform) { if(Selection.activeTransform.GetComponentInParent&lt;Canvas()) { GameObject go = new GameObject(&quot;image&quot;,typeof(Image)); go.GetComponent&lt;Image().raycastTarget = false; go.transform.SetParent(Selection.activeTransform); } } } 这样创建出来的Image就不带 RaycastTarget,Text组件原理同上。 Unity版本5.3.3 作者：雨松MOMO","link":"/blog/2019/05/17/Unity优化/UGUI一个优化效率小技巧/"},{"title":"UGUI降低填充率技巧两则","text":"FillRate(填充率)是指显卡每帧每秒能够渲染的像素数。在每帧绘制中，如果一个像素被反复绘制的次数越多，那么它占用的资源也必然更多。目前在移动设备上，FillRate的压力主要来自半透明物体。因为多数情况下，半透明物体需要开启 Alpha Blend 且关闭 ZTest和 ZWrite，同时如果我们绘制像 alpha=0这种实际上不会产生效果的颜色上去，也同样有 Blend 操作，这是一种极大的浪费。因此，今天我们为大家推荐两则UGUI 降低填充率的技巧，希望大家能受用。 这是侑虎科技第50篇原创文章，感谢作者钱康来供稿。欢迎转发分享，未经作者授权请勿转载。同时如果您有任何独到的见解或者发现也欢迎联系我们，一起探讨。（QQ群465082844） 作者博客：http://qiankanglai.me 知乎专栏：&lt;https://zhuanlan.zhihu.com/soulgame 在Unity中，与能直接看到的Verts/Tris/Batches数据不同，填充率并不能被直接统计到，但是我们可以通过查看OverDraw来大致查看： 对于UI来说，后者其实是很容易被忽视的热点(特别是对于中低端移动设备来说)。下面我就以具体两个例子为例，并探讨其解决思路。 滥用不可见组件之前在Profile手头项目的时候发现红米上一个奇怪的现象：战斗界面维持60fps没问题；进入UI界面之后瞬间掉到45fps，甚至有的复杂界面掉到30fps。但战斗场景的Tris/Verts比UI高不少。 通过工具很方便的就定位到了瓶颈在于FillRate爆了，最后发现新手教学部分用了很多“不可见”的Image作为交互响应的控件；但这些东西虽然画上去没有效果，依然占用了显卡资源，特别是有很多大块的区域…找到问题之后就解决起来很方便：实现一个只在逻辑上响应Raycast但是不参与绘制的组件即可，改完之后帧率瞬间正常。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using UnityEngine; using System.Collections; namespace UnityEngine.UI { public class Empty4Raycast : MaskableGraphic { protected Empty4Raycast() { useLegacyMeshGeneration = false; } protected override void OnPopulateMesh(VertexHelper toFill) { toFill.Clear(); } } } 这里顺便提一句，显卡资源消耗在没有到瓶颈的时候，大概是随着使用的增加正相关，但是到瓶颈之后很多时候是“崩盘”节奏。 Polygon Mode Sprites在UI部分中我们会大量使用图片作为元素，如果图片边缘有大片留白就会和上面那个问题一样，产生很多无用填充。Unity和TexturePacker目前都支持了PolygonMode，也就是说将原来的矩形Sprite用更加紧致的Polygon来描述，从而能更有效的利用空白空间(顺便也减小了打包出来的图资源)。 当然，目前Unity只在Sprite Render里支持了这个模式，在UGUI的Image中还无法正常使用。我自己实现了一个挂官方论坛[UGUI Imagewith polygon sprites](http://forum.unity3d.com/threads/ugui-image-with-polygon-sprites.390039/)，Texture Packer作者也表示很感兴趣~ 可以看到同样的一个图片，新的模式下顶点数变多了，但是绘制的范围变小了不少；同时在打包的时候图片也更加的紧致了，因为在不规则大图周围能塞进去不少小的元素。 下面这个脚本是针对Image的扩展，使其支持Polygon Mode Sprite…不过精力有限，只支持了Simple而且没做PreserveAspect，有兴趣的朋友如果实现了别的模式还望多多交流(主要是Filled和Sliced下要自己重新划分三角形，想想就麻烦…) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279using System.Collections.Generic; namespace UnityEngine.UI { [AddComponentMenu(&quot;UI/Effects/PolygonImage&quot;, 16)] [RequireComponent(typeof(Image))] public class PolygonImage : BaseMeshEffect { protected PolygonImage() { } // GC Friendly private static Vector3[] fourCorners = new Vector3[4]; private static UIVertex vertice = new UIVertex(); private RectTransform rectTransform = null; private Image image = null; public override void ModifyMesh(VertexHelper vh) { if (!isActiveAndEnabled) return; if (rectTransform == null) { rectTransform = GetComponent&lt;RectTransform(); } if (image == null) { image = GetComponent&lt;Image(); } if (image.type != Image.Type.Simple) { return; } Sprite sprite = image.overrideSprite; if (sprite == null || sprite.triangles.Length == 6) { // only 2 triangles return; } // Kanglai: at first I copy codes fromImage.GetDrawingDimensions // to calculate Image&apos;s dimensions. But now for easy to read, Ijust take usage of corners. if (vh.currentVertCount != 4) { return; } rectTransform.GetLocalCorners(fourCorners); // Kanglai: recalculate vertices from Sprite! int len = sprite.vertices.Length; var vertices = new List&lt;UIVertex(len); Vector2 Center = sprite.bounds.center; Vector2 invExtend = new Vector2(1 / sprite.bounds.size.x, 1 /sprite.bounds.size.y); for (int i = 0; i &lt; len; i++) { // normalize float x = (sprite.vertices[i].x - Center.x) * invExtend.x +0.5f; float y = (sprite.vertices[i].y - Center.y) * invExtend.y +0.5f; // lerp to position vertice.position = new Vector2(Mathf.Lerp(fourCorners[0].x,fourCorners[2].x, x), Mathf.Lerp(fourCorners[0].y, fourCorners[2].y, y)); vertice.color = image.color; vertice.uv0 = sprite.uv[i]; vertices.Add(vertice); } len = sprite.triangles.Length; var triangles = new List&lt;int(len); for (int i = 0; i &lt; len; i++) { triangles.Add(sprite.triangles[i]); } vh.Clear(); vh.AddUIVertexStream(vertices, triangles); } } } 这个做法是用顶点数来换填充率，具体是否这么干还要看项目本身的瓶颈。这一点在官方论坛的帖子里我也和别人讨论过，这里就不再赘述了。","link":"/blog/2019/05/17/Unity优化/UGUI降低填充率技巧两则/"},{"title":"Unity-Profiler-window分析器窗口","text":"Attaching to Unity players 附加到Unity播放器To profile your game running on an other device or a player running on anothercomputer, it is possible to connect the editor to that other player. Thedropdown Active Profiler will show all players running on the localnetwork. These players are identified by player type and the host name runningthe player “iPhonePlayer (Toms iPhone)”. To be able to connect to a player,the player must be launched with the Development Build checkbox found inthe Build Settings dialog. From here it is also possible to tick acheckbox to make the Editor and Player Autoconnect at startup. 要分析你的游戏运行在其他设备上或者在另一台计算机上运行的播放器，可以连接编辑器到其他播放器。ActiveProfiler下拉菜单显示在本地网络上运行的所有播放器。这些播放器通过播放器的类型和运行播放器的主机名”iPhonePlayer（TomsiPhone）”被识别。要能够连接到一个播放器，播放器必须在 Build Settings对话框中找到Development Build复选框勾上的情况下打包生成。从这里也可以勾选一个复选框，使编辑器和播放器在启动时自动连接。 Profiler Controls 分析器控件 Profiler controls are in the toolbar at the top of the window. Use these toturn profiling on and off, navigate through profiled frames and so on. Thetransport controls are at the far right end of the toolbar. Note that when thegame is running and the profiler is collecting data clicking on any of thesetransport controls will pause the game. The controls go to the first recordedframe, step one frame back, step one frame forward and go to the last framerespectively. The profiler does not keep all recorded frames, so the notion ofthe first frame should really be though of as the oldest frame that isstill kept in memory. The “current” transport button causes the profilestatistics window to display data collected in real-time. The Active Profilerpopup menu allows you to select whether profiling should be done in the editoror a separate player (for example, a game running on an attached iOS device). 分析器控件在窗口顶部的工具栏。使用这些控件打开和关闭分析，浏览分析好的帧等。传输控件在工具栏的最右端。请注意，当游戏运行、分析器收集数据时，点击任何这些传输控件（那两个小箭头）将暂停游戏。控件转到记录的第一帧，一步一帧向前(左箭头)，一步一帧向后（右箭头），分别去到最后一帧。分析器不保留所有记录的帧，因此第一帧的概念，事实上应该是仍然保存在内存中的最旧的一帧。“current”按钮会使得分析统计窗口显示实时采集的数据。激活分析器（ActiveProfiler）弹出菜单让你选择是否应在编辑器或一个或独立播放器进行分析（例如，一个游戏运行在iOS设备）。 Deep Profiling 深度分析When you turn on Deep Profile, all your script code is profiled - that is,all function calls are recorded. This is useful to know where exactly time isspent in your game code. 当你打开深度分析（Deep Profile），所有脚本代码将被分析 - 也就是说，所有的函数调用被记录。知道确切在你的游戏代码中花费的时间，这是有用的。 Note that Deep Profiling incurs a very large overhead and uses a lot ofmemory, and as a result your game will run significantly slower whileprofiling. If you are using complex script code, Deep Profiling might not bepossible at all. Deep profiling should work fast enough for small games withsimple scripting. If you find that Deep Profiling for your entire game causesthe frame rate to drop so much that the game barely runs, you should considernot using this approach, and instead use the approach described below. You mayfind deep profiling more helpful as you are designing your game and decidinghow to best implement key features. Note that for large games deep profilingmay cause Unity to run out of memory and so for this reason deep profiling maynot be possible. 注意深度分析（DeepProfiling）会造成非常大的开销，并使用大量的内存，结果你的游戏在分析同时运行明显变慢。如果您使用的是复杂的脚本代码，深度分析可能不会完全有效。深度分析为使用简单的脚本的小游戏工作足够快。如果您发现您的整个游戏在深度分析时运行，导致帧速率下降很多，以至于游戏几乎不能运行，你应该考虑不采用这种方法，而是使用下面描述的方法。您可能会发现深度分析更有利于设计你的游戏，并确定如何最好地实现关键特性。注意深度分析，对于大型游戏可能会导致Unity耗尽内存，基于这个原因，深度分析未必有效。 Manually profiling blocks of your script code will have a smaller overheadthan using Deep Profiling. UseProfiler.BeginSampleandProfiler.EndSamplescripting functions to enable and disable profiling around sections of code. 手动分析脚本代码块比使用深度分析产生更小的开销。使用Profiler.BeginSample和Profiler.EndSample函数，启用和禁用分析代码段（从Profiler.BeginSample到Profiler.EndSample间的代码）。 View SyncTime 查看同步时间When running at a fixed framerate or running in sync with the vertical blank,Unity records the waiting time in “Wait For Target FPS”. By default thisamount of time is not shown in the profiler. To view how much time is spentwaiting, you can toggle “View SyncTime”. This is also a measure of how muchheadroom you have before losing frames. 当运行在一个固定的帧率或带垂直空白同步运行，Unity在”Wait For TargetFPS”记录等待时间，默认情况下，该段时间没有显示在分析器。要查看等待花费多少时间，您可以切换”ViewSyncTime”。这也是衡量多少余量你之前丢失帧。 Profiler Timeline 分析器时间轴 The upper part of the Profiler window displays performance data over time.When you run a game, data is recorded each frame, and the history of the lastseveral hundred frames is displayed. Clicking on a particular frame willdisplay it’s details in the lower part of the window. Different details aredisplayed depending on which timeline area is currently selected. 分析器窗口的上部显示随着时间的推移的性能数据。当您运行游戏，每一帧数据被记录，最后则会显示几百帧的历史。点击一个特定的帧上，该帧的细节将显示在窗口的下部。具体取决于当前选定的时间轴区域显示不同的细节。 The vertical scale of the timeline is managed automatically and will attemptto fill the vertical space of the window. Note that to get more detail in saythe CPU Usage area you can remove the Memory and Rendering areas. Also, thesplitter between the timeline and the statistics area can be selected anddragged downward to increase the screen area used for the timeline chart. 时间轴的垂直刻度是自动管理，并尝试填补窗口的垂直空间。请注意，要获得更多关于CPU的使用率(CPU Usage)的细节，您可以删除内存（Memory）和渲染（Rendering ）区域。此外，时间轴和统计区域之间的分离器能被选择和向下拖动，为时间轴图表增加屏幕面积。 The timeline consists of several areas: CPU Usage, Rendering and Memory. Theseareas can be removed by clicking the close button in the panel, and re-addedagain using the Add Area drop down in the Profile Controls bar. 时间轴包括几个方面：CPU使用率，渲染和内存。这些区域可以在面板上按一下关闭按钮删除和 在分析控件（Profile Controls）工具栏中使用AddArea 下拉菜单再次重新添加。 CPU Usage AreaCPU使用率区域 Rendering Area渲染区域 Memory Area内存区域 Audio Area音频区域 Physics Area物理学区域 GPU AreaGPU区域","link":"/blog/2019/05/17/Unity优化/Unity-Profiler-window分析器窗口/"},{"title":"Unity-Profiler性能分析","text":"Profiler窗口 1. CPUA. WaitForTargetFPS: Vsync(垂直同步)功能所，即显示当前帧的CPU等待时间 B. Overhead： Profiler总体时间-所有单项的记录时间总和。用于记录尚不明确的时间消耗，以帮助进一步完善Profiler的统计。 C. Physics.Simulate： 当前帧物理模拟的CPU占用时间。 D. Camera.Render： 相机渲染准备工作的CPU占用量 E. RenderTexture.SetActive： 设置RenderTexture操作. 底层实现：1.比对当前帧与前一帧的ColorSurface和DepthSurface. 2.如果这两个Buffer一致则不生成新的RT，否则则生成新的RT，并设置与之相对应的Viewport和空间转换矩阵. F. Monobehaviour.OnMouse_ ： 用于检测鼠标的输入消息接收和反馈，主要包括：SendMouseEvents和DoSendMouseEvents。（只要Edtor开起来，这个就会存在） G. HandleUtility.SetViewInfo： 仅用于Editor中，作用是将GUI和Editor中的显示看起来与发布版本的显示一致。 H. GUI.Repaint： GUI的重绘(说明在有使用原生的OnGUI) I. Event.Internal_MakeMasterEventCurrent： 负责GUI的消息传送 J. Cleanup Unused Cached Data： 清空无用的缓存数据，主要包括RenderBuffer的垃圾回收和TextRendering的垃圾回收。 1.RenderTexture.GarbageCollectTemporary:存在于RenderBuffer的垃圾回收中，清除临时的FreeTexture. 2.TextRendering.Cleanup:TextMesh的垃圾回收操作 K. Application.Integrate Assets in Background： 遍历预加载的线程队列并完成加载，同时，完成纹理的加载、Substance的Update等. L. Application.LoadLevelAsync Integrate： 加载场景的CPU占用，通常如果此项时间长的话70%的可能是Texture过长导致. M. UnloadScene： 卸载场景中的GameObjects、Component和GameManager，一般用在切换场景时. N. CollectGameObjectObjects： 执行上面M项的同时，会将场景中的GameObject和Component聚集到一个Array中.然后执行下面的Destroy. O. Destroy： 删除GameObject和Component的CPU占用. P. AssetBundle.LoadAsync Integrate： 多线程加载AwakeQueue中的内容，即多线程执行资源的AwakeFromLoad函数. Q. Loading.AwakeFromLoad： 在资源被加载后调用，对每种资源进行与其对应用处理. 2.GPU UsageA. Device.Present: device.PresentFrame的耗时显示，该选项出现在发布版本中. B. Graphics.PresentAndSync： GPU上的显示和垂直同步耗时.该选项出现在发布版本中. C. Mesh.DrawVBO： GPU中关于Mesh的Vertex Buffer Object的渲染耗时. D. Shader.Parse： 资源加入后引擎对Shader的解析过程. E. Shader.CreateGPUProgram： 根据当前设备支持的图形库来建立GPU工程. 3. Memory ProfilerA. Used Total: 当前帧的Unity内存、Mono内存、GfxDriver内存、Profiler内存的总和. B. Reserved Total: 系统在当前帧的申请内存. C. Total System Memory Usage: 当前帧的虚拟内存使用量.（通常是我们当前使用内存的1.5~3倍) D. GameObjects in Scene: 当前帧场景中的GameObject数量. E. Total Objects in Scene: 当前帧场景中的Object数量(除GameObject外，还有Component等). F. Total Object Count: Object数据 + Asset数量. 4. Detail Memory ProfilerA. Assets: Texture2d:记录当前帧内存中所使用的纹理资源情况，包括各种GameObject的纹理、天空盒纹理以及场景中所用的Lightmap资源. B. Scene Memory: 记录当前场景中各个方面的内存占用情况，包括GameObject、所用资源、各种组件以及GameManager等（天般情况通过AssetBundle加载的不会显示在这里). A. Other: ManagedHeap.UseSize:代码在运行时造成的堆内存分配，表示上次GC到目前为止所分配的堆内存量. SerializedFile(3): WebStream:这个是由WWW来进行加载的内存占用. System.ExecutableAndDlls:不同平台和不同硬件得到的值会不一样。 5. 优化重点A. CPU-GC Allow: 关注原则：1.检测任何一次性内存分配大于2KB的选项 2.检测每帧都具有20B以上内存分配的选项. B. Time ms: 记录游戏运行时每帧CPU占用（特别注意占用5ms以上的）. C. Memory Profiler-Other: 1.ManagedHeap.UsedSize: 移动游戏建议不要超过20MB. 2.SerializedFile: 通过异步加载(LoadFromCache、WWW等)的时候留下的序列化文件,可监视是否被卸载. 3.WebStream: 通过异步WWW下载的资源文件在内存中的解压版本,比SerializedFile大几倍或几十倍,重点监视.**** D. Memory Profiler-Assets: 1.Texture2D: 重点检查是否有重复资源和超大Memory是否需要压缩等. 2.AnimationClip: 重点检查是否有重复资源. 3.Mesh： 重点检查是否有重复资源. 6. 项目中可能遇到的问题A. Device.Present: 1.GPU的presentdevice确实非常耗时，一般出现在使用了非常复杂的shader. 2.GPU运行的非常快，而由于Vsync的原因，使得它需要等待较长的时间. 3.同样是Vsync的原因，但其他线程非常耗时，所以导致该等待时间很长，比如：过量AssetBundle加载时容易出现该问题. 4.Shader.CreateGPUProgram:Shader在runtime阶段（非预加载）会出现卡顿(华为K3V2芯片). B.StackTraceUtility.PostprocessStacktrace()和StackTraceUtility.ExtractStackTrace(): 1.一般是由Debug.Log或类似API造成. 2.游戏发布后需将Debug API进行屏蔽. C. Overhead: 1.一般情况为Vsync所致. 2.通常出现在Android设备上. D. GC.Collect: 原因: 1.代码分配内存过量(恶性的) 2.一定时间间隔由系统调用(良性的). 占用时间：1.与现有Garbage size相关 2.与剩余内存使用颗粒相关（比如场景物件过多，利用率低的情况下，GC释放后需要做内存重排) E. GarbageCollectAssetsProfile: 1.引擎在执行UnloadUnusedAssets操作(该操作是比较耗时的,建议在切场景的时候进行). 2.尽可能地避免使用Unity内建GUI，避免GUI.Repaint过渡GC Allow. 3.if(other.tag ==GearParent.MogoPlayerTag)改为other.CompareTag(GearParent.MogoPlayerTag).因为other.tag为产生180B的GCAllow. F. 少用foreach，因为每次foreach为产生一个enumerator(约16B的内存分配)，尽量改为for. G. Lambda表达式，使用不当会产生内存泄漏. H. 尽量少用LINQ： 1.部分功能无法在某些平台使用. 2.会分配大量GC Allow. I. 控制StartCoroutine的次数： 1.开启一个Coroutine(协程)，至少分配37B的内存. 2.Coroutine类的实例 — 21B. 3.Enumerator — 16B. J. 使用StringBuilder替代字符串直接连接. K. 缓存组件: 1.每次GetComponent均会分配一定的GC Allow. 2.每次Object.name都会分配39B的堆内存. Unity优化系列文章：http://www.unity.5helpyou.com/tag/unity%E4%BC%98%E5%8C%96 本文转截自：http://www.unity.5helpyou.com/2791.html","link":"/blog/2019/05/17/Unity优化/Unity-Profiler性能分析/"},{"title":"Unity-Profiler性能分析器的使用","text":"长话短说，我整理了一下mac版Unity3Dpro下的Profiler连接Android的使用。注意是专业版的Unity3D。在Window下会有Profiler 这个工具的意义是，游戏在客户端跑然后UnityProfile测试一些参数 连接手机有两种方式。 1.wifi：让手机和电脑痛处于同一局域网内。 2.数据线连接（下好各种驱动），一般只要Unity中 Build And Run 时游戏能在客户端跑 就基本连接没问题 1.File-&gt;Build Setting 注意勾选 Development Build 点击 Player Settings 找到ProductName 记录下来 2.数据线连接手机，File-&gt;Build And Run 3.打开终端，找到adb的文件 cd /Applications/android/adt-bundle-mac-x86_64-20140702/sdk/platform-tools 每个mac 不一样 ./adb forward tcp:54999 localabstract:Unity-&lt;包名&gt; 4.window-&gt;profiler 同时手机运行游戏 如果用wifi连接 先Enter IP 输入手机在局域网中ip即会成为2 如果是数据线 直接选一 ok，随玩游戏随测，数据线连接的话 ，注意不要断开连接。","link":"/blog/2019/05/17/Unity优化/Unity-Profiler性能分析器的使用/"},{"title":"Unity-UI优化技术与技巧","text":"优化UI有时候并没有什么很简洁的方式。本文介绍了一些可能对UI性能提升有帮助的建议，有些建议是针对结构上“不清晰”，或难于维护，或者效果很差。另一些则可能对开发初期的UI用户界面简化有所帮助，但也相对更容易产生一些性能问题。 基于RectTransform的布局Layout组件的性能开销相当大，因为每次当它们被标记为Dirty时，都必须重新计算所有子节点的坐标和尺寸。如果在给定的Layout内有一些相对较小的固定数量的元素，并且布局的结构也相对简单，那么就有可能将Layout替换为基于矩形变换的布局（RectTransform-based layout）。 通过设置RectTransform的锚点（Anchors），RectTransform的坐标和大小会根据父节点进行缩放。例如，一个简单的两列布局可以用两个RectTransform实现: 左列的锚点应该是X: (0, 0.5) 以及 Y: (0, 1) 右列的锚点应该是X: (0.5, 1) 以及 Y: (0, 1) 对于RectTransform坐标和大小的计算会由Transform系统自身的源代码进行驱动。通常情况下这比Luyout系统更高效。也可以通过MonoBehaviours来实现基于RectTransform的Layout。然而，这是一个相对复杂的任务，不在本文中描述。 禁用Canvas渲染器当显示或者隐藏UI的某个部分时，通常是激活（Enable）或者禁用（Disable）UI根节点的GameObject。这会导致被禁用UI下的所有组件都将不再接收输入或者Unity回调。 然而，这也会导致Canvas丢弃它的VBO（Vertex BufferObjects，顶点缓存对象）数据。重新激活Canvas需要Canvas（以及它的子Canvas）执行重新构建（Rebuild）以及重新批处理（Rebatch）操作。如果这种情况非常频繁，那么CPU使用率的增加就会导致应用程序帧率的卡顿。 一个可行但有风险的解决方案是让将那些需要切换显示或隐藏的UI放在单独的Canvas或子Canvas中，然后仅仅激活/禁用附加在Canvas上的Canvas渲染组件（CanvasRenderer）。 这会导致UI的网格不被绘制，但它们会一直存在于内存中，并且原始的批处理信息（Batching）也会被保留。此外，UI层级结构（Hierarchy）下的OnEnable或者 OnDisable回调将不会执行。 注意，这并不会将UI图形从图形记录（GraphicRegistry）中消除，所以它们依然会出现在组件列表中，可以被光线投射（Raycast）检测到。隐藏UI也不会禁用任何的MonoBehaviour，所以那些MonoBehaviour依然会接受Unity生命周期相关的回调，比如Update函数。 隐藏UI的MonoBehaviour脚本不直接实现那些Unity生命周期相关的回调函数，而是从UI根节点上的“回调管理器”MonoBehaviour中接收回调，可以避免出现这样的问题。这个“回调管理器”无论UI是否显示都可以访问，并且保证了生命周期事件按需发送。 分配事件相机如果使用了Unity内置的输入管理器，并将Canvas的渲染模式设为世界空间（World Space）或者屏幕空间相机（Screen Space –Camera）渲染，有一点很重要，就是分别设置Event Camera和RenderCamera的属性。这可以在脚本中访问Canvas的worldCamera属性进行设置。 如果没有设置worldCamera属性，那么Unity UI会查找标签为MainCamera的GameObject上附加的Camera脚本来搜索主相机。这个查询会在世界空间（World Space）和相机空间（CameraSpace）的Canvas中都至少分别执行一次。由于GameObject.FindWithTag非常缓慢，Unity强烈建议大家在设计或初始化所有的世界空间（WorldSpace）和相机空间（Camera Space）的Canvas时，就分配好各自的相机属性。 这个问题不会在渲染模式为Overlay的Canvas中出现。","link":"/blog/2019/05/17/Unity优化/Unity-UI优化技术与技巧/"},{"title":"Unity中的UGUI优化","text":"一、界面制作Q1：UGUI里的这个选项 ，应该是ETC2拆分Alpha通道的意思，但是在使用中并没起作用？请问有没有什么拆分的标准和特别要求呢？ 据我们所知，alpha split 的功能最初只对 Unity 2D 的Sprite（SpriteRenderer）有完整的支持，而UI的支持是在Unity 5.4版本之后的。建议大家在Unity5.4版本以后的UGUI中尝试该功能。 Q2：在UI界面中，用Canvas还是用RectTransform做根节点更好？哪种方法效率更高？ Canvas划分是个很大的话题。简单来说，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致DrawCall的上升。我们后续将对UI模块做具体的讲解，尽请期待。 Q3：UWA性能检测报告中的Shared UI Mesh表示什么呢？ Shared UI Mesh是在Unity 5.2 版本后UGUI系统维护的UIMesh。在以前的版本中，UGUI会为每一个Canvas维护一个Mesh（名为BatchedMesh，其中再按材质分为不同的SubMesh）。而在Unity5.2版本后，UGUI底层引入了多线程机制，而其Mesh的维护也发生了改变，目前Shared UIMesh作为静态全局变量，由底层直接维护，其大小与当前场景中所有激活的UI元素所生成的网格数相关。 一般来说当界面上UI元素较多，或者文字较多时该值都会较高，在使用UI/Effect/shadow和UI/Effect/Outline时需要注意该值，因为这两个Effect会明显增加文字所带来的网格数。 Q4：在使用NGUI时，我们通常会将很多小图打成一个大的图集，以优化内存和DrawCall。而在UGUI时代，UI所使用的Image必须是Sprite；Unity提供了SpritePacker。 它的工作流程和UGUI AtlasPaker有较大的差别。在Unity Asset中，我们压根看不到图集的存在。 问题是： 1. SpritePacker大概的工作机制是什么样的？ 2.如果Sprite没有打包成AssetBundle，直接在GameObject上引用，那么在Build时Unity会将分散的Sprite拼接在一起么？如果没有拼接，那SpritePacker是不是只会优化DrawCall，内存占用上和不用SpritePacker的分离图效果一样？ 3.如果将Sprite打成AssetBundle，AssetBundle中的资源是分散的Sprite吗？如果不是，不同的AssetBundle中引用了两张Sprite，这两张Sprite恰好用SpritePacker拼在了一起，是不是就会存在两份拼接的Sprite集？ 4. 如果想使用NGUI Atlas Packer的工作流程，该如何去实现？ 简单来说，UGUI和 NGUI 类似，但是更加自动化。只需要通过设定 Packing Tag 即可指定哪些 Sprite 放在同一个 Atlas 下。 可以通过 Edit -&gt; Project Settings -&gt; Editor -&gt; Sprite Packer 的 Mode来设置是否起效，何时起效（一种是进入 Play Mode 就生效，一种是 Build 时才生效）。所以只要不选 Disabled，Build 时就会把分散的Sprite 拼起来。 可以认为 Sprite 就是一个壳子，实际上本身不包含纹理资源，所以打包的时候会把Atlas 打进去。如果不用依赖打包，那么分开打两个 Sprite就意味各自的AssetBundle 里都会有一个 Atlas。 可以通过第三方工具（如 Texture Packer）制作 Atlas，导出 Sprite 信息（如，第 N 个 Sprite 的 Offset 和Width，Height 等），然后在 Unity 中通过脚本将该 Atlas 转成一个 Multiple Mode 的 Sprite纹理（即一张纹理上包含了多个 Sprite），同时禁用 Unity 的 Sprite Packer 即可。 两种做法各有利弊，建议分析一下两种做法对于自身项目的合适程度来进行选择。 Q5：在Unity 5.x版本下，我们在用UGUI的过程中发现它把图集都打进了包里，这样就不能自动更新了，请问图集怎么做自动更新呢？ 在Unity 5.x中UGUI使用的Atlas确实是不可见的，因此无法直接将其独立打包。但我们建议，可以把PackingTag相同的源纹理文件，打到同一个AssetBundle中（设置一样的AssetBundleName），从而避免Atlas的冗余。同时这样打包可以让依赖它的Canvas的打包更加自由，即不需要把依赖它的Canvas都打在一个AssetBundle中，在更新时直接更新Atlas所在的AssetBundle即可。 Q6：ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases，有办法消除吗？ ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。 如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了PixelPerfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭PixelPerfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。 二、网格重建 Q1：我在UGUI里更改了Image的Color属性，那么Canvas是否会重建？我只想借用它的Color做Animation里的变化量。 如果修改的是Image组件上的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。而通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的DrawCall。 Q2：Unity自带的UI Shader处理颜色时，改_Color属性不会触发顶点重建吗? 在UI的默认Shader中存在一个TintColor的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的TintColor属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。 Q3：能否就UGUI Batch提出一些建议呢？是否有一些Batch的规则？ 在 UGUI中，Batch是以Canvas为单位的，即在同一个Canvas下的UI元素最终都会被Batch到同一个Mesh中。而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。而Batch的操作只会在UI元素发生变化时才进行，且合成的Mesh越大，操作的耗时也就越大。 因此，我们建议尽可能把频繁变化（位置，颜色，长宽等）的UI元素从复杂的Canvas中分离出来，从而避免复杂的Canvas频繁重建。 Q4：我用的是UGUI Canvas，Unity 5.3.4版本，请问如何查看每次Rebuild Batch影响的顶点数， MemoryProfiler是个办法但是不好定位。 由于Unity引擎在5.2后开始使用Shared UI Mesh来存储UIMesh，所以确实很难查看每次Rebuild的UI顶点数。但是，研发团队可以尝试通过Frame Debugger工具对UI界面进行进一步的查看。 Q5：动静分离或者多Canvas带来性能提升的理论基础是什么呢？如果静态部分不变动，整个Canvas就不刷新了？ 在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。 Q6：UWA建议“尽可能将静态UI元素和频繁变化的动态UI元素分开，存放于不同的Panel下。同时，对于不同频率的动态元素也建议存放于不同的Panel中。”那么请问，如果把特效放在Panel里面，需要把特效拆到动态的里面吗？ 通常特效是指粒子系统，而粒子系统的渲染和UI是独立的，仅能通过RenderOrder来改变两者的渲染顺序，而粒子系统的变化并不会引起UI部分的重建，因此特效的放置并没有特殊的要求。 Q7：多人同屏的时候，人物移动会使得头顶上的名字Mesh重组，从而导致较为严重的卡顿，请问一下是否有优化的办法？ 如果是用UGUI开发的，当头顶文字数量较多时，确实很容易引起性能问题，可以考虑从以下几点入手进行优化： 尽可能避免使用UI/Effect，特别是Outline，会使得文本的Mesh增加4倍，导致UI重建开销明显增大； 拆分Canvas，将屏幕中所有的头顶文字进行分组，放在不同的Canvas下，一方面可以降低更新的频率（如果分组中没有文字移动，该组就不会重建），另一方面可以减小重建时涉及到的Mesh大小（重建是以Canvas为单位进行的）； 降低移动中的文字的更新频率，可以考虑在文字移动的距离超过一个阈值时才真正进行位移，从而可以从概率上降低Canvas更新的频率。 三、界面切换Q1：游戏中出现UI界面重叠，该怎么处理较好？比如当前有一个全屏显示的UI界面，点其中一个按钮会再起一个全屏界面，并把第一个UI界面盖住。我现在的做法是把被覆盖的界面SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches又降低 GC Alloc 的话，有什么推荐的方案吗？ 可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。 这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh也会始终存在于内存中（通常也不太大）。 以上的方式可供参考，而性能影响依旧是需要视具体情况而定。 Q2：通过移动位置来隐藏UI界面，会使得被隐藏的UIPanel继续执行更新（LateUpdate有持续开销），那么如果打开的界面比较多，CPU的持续开销是否就会超过一次SetActive所带来的开销？ 这确实是需要注意的，通过移动的方式“隐藏”的UI界面只适用于几个切换频率最高的界面，另外，如果“隐藏”的界面持续开销较高，可以考虑只把一部分Disable，这个可能就需要具体看界面的复杂度了。一般来说在没有UI元素变化的情况下，持续的Update 开销是不太明显的。 Q3：如图，我们在UI打开或者移动到某处的时候经常会观测到CPU上的冲激，经过进一步观察发现是因为Instantiate产生了大量的GC。想请问下Instantiate是否应该产生GC呢？我们能否通过资源制作上的调整来避免这样的GC呢？如下图，因为一次性产生若干MB的GC在直观感受上还是很可观的。 准确的说这些 GC Alloc 并不是由Instantiate 直接引起的，而是因为被实例化出来的组件会进行 OnEnable 操作，而在 OnEnable操作中产生了 GC，比如以上图中的函数为例： 上图中的 Text.OnEnable 是在实例化一个 UI 界面时，UI 中的文本（即 Text 组件）进行了 OnEnable操作，其中主要是初始化文本网格的信息（每个文字所在的网格顶点，UV，顶点色等等属性），而这些信息都是储存在数组中（即堆内存中），所以文本越多，堆内存开销越大。但这是不可避免的，只能尽量减少出现次数。 因此，我们不建议通过 Instantiate/Destroy 来处理切换频繁的 UI 界面，而是通过SetActive(true/false)，甚至是直接移动 UI 的方式，以避免反复地造成堆内存开销。 四、加载相关 Q1：UGUI的图集操作中我们有这么一个问题，加载完一张图集后，使用这个方式获取其中一张图的信息：assetBundle.Load (subFile,typeof (Sprite)) as Sprite; 这样会复制出一个新贴图（图集中的子图），不知道有什么办法可以不用复制新的子图，而是直接使用图集资源。 经过测试，这确实是 Unity 在 4.x 版本中的一个缺陷，理论上这张“新贴图（图集中的子图）”是不需要的，并不应该加载。因此，我们建议通过以下方法来绕过该问题： 在 assetBundle.Load (subFile, typeof (Sprite)) as Sprite; 之后，调用 Texture2D t = assetBundle.Load (subFile, typeof (Texture2D)) as Texture2D; Resources.UnloadAsset(t); 从而卸载这部分多余的内存。 Q2：加载UI预制的时候，如果把特效放到预制里，会导致加载非常耗时。怎么优化这个加载时间呢？ UI和特效（粒子系统）的加载开销在多数项目中都占据较高的CPU耗时。UI界面的实例化和加载耗时主要由以下几个方面构成： 纹理资源加载耗时 UI界面加载的主要耗时开销，因为在其资源加载过程中，时常伴有大量较大分辨率的Atlas纹理加载，我们在之前的Unity加载模块深度分析之纹理篇有详细讲解。对此，我们建议研发团队在美术质量允许的情况下，尽可能对UI纹理进行简化，从而加快UI界面的加载效率。 UI网格重建耗时 UI界面在实例化或Active时，往往会造成Canvas（UGUI）或Panel（NGUI）中UIDrawCall的变化，进而触发网格重建操作。当Canvas或Panel中网格量较大时，其重建开销也会随之较大。 UI相关构造函数和初始化操作开销 这部分是指UI底层类在实例化时的ctor开销，以及OnEnable和OnDisable的自身开销。 上述2和3主要为引擎或插件的自身逻辑开销，因此，我们应该尽可能避免或降低这两个操作的发生频率。我们的建议如下： 在内存允许的情况下，对于UI界面进行缓存。尽可能减少UI界面相关资源的重复加载以及相关类的重复初始化； 根据UI界面的使用频率，使用更为合适的切换方式。比如移进移出或使用CullingLayer来实现UI界面的切换效果等，从而降低UI界面的加载耗时，提升切换的流畅度。 对于特效（特别是粒子特效）来说，我们暂时并没有发现将UI界面和特效耦合在一起，其加载耗时会大于二者分别加载的耗时总和。因此，我们仅从优化粒子系统加载效率的角度来回答这个问题。粒子系统的加载开销，就目前来看，主要和其本身组件的反序列化耗时和加载数量相关。对于反序列化耗时而言，这是Unity引擎负责粒子系统的自身加载开销，开发者可以控制的空间并不大。对于加载数量，则是开发者需要密切关注的，因为在我们目前看到的项目中，不少都存在大量的粒子系统加载，有些项目的数量甚至超过1000个，如下图所示。因此，建议研发团队密切关注自身项目中粒子系统的数量使用情况。一般来说，建议我们建议粒子系统使用数量的峰值控制在400以下。 Q3：我有一个UI预设，它使用了一个图集，我在打包的时候把图集和UI一起打成了AssetBundle。我在加载生成了GameObject后立刻卸载了AssetBundle对象，但是当我后面再销毁GameObject的时候发现图集依然存在，这是什么情况呢？ 这是很可能出现的。unload(false)卸载AssetBundle并不会销毁其加载的资源 ，是必须调用Resources.UnloadUnusedAssets才行。关于AssetBundle加载的详细解释可以参考我们之前的文章：你应该知道的AssetBundle管理机制。 五、字体相关 Q1：我在用Profiler真机查看iPhoneApp时，发现第一次打开某些UI时，Font.CacheFontForText占用时间超过2s，这块主要是由什么影响的?若iPhone5在这个接口消耗2s多，是不是问题很大？这个消耗和已经生成的RenderTexture的大小有关吗？ Font.CacheFontForText主要是指生成动态字体Font Texture的开销,一次性打开UI界面中的文字越多，其开销越大。如果该项占用时间超过2s，那么确实是挺大的，这个消耗也与已经生成的FontTexture有关系。简单来说，它主要是看目前Font Texture中是否有地方可以容下接下来的文字，如果容不下才会进行一步扩大FontTexture，从而造成了性能开销。","link":"/blog/2019/05/17/Unity优化/Unity中的UGUI优化/"},{"title":"Unity3D如何减少安装包大小","text":"译官方文档：http://docs.unity3d.com/Manual/ReducingFilesize.html PDF文档：http://www.rukawa.cn/Uploads/Attachment/ReducingFilesize/ReducingFilesize.pdf 原文地址：http://www.rukawa.cn/index.php?s=/home/article/detail/id/27.html 需要这么做的目的和好处就不多说了。 第一步要做的就是：看看哪些文件是最占空间的，那么它们就是首选优化对象了。 你可以在刚刚完成一次build之后在“Editor Log”中找到这些信息。 如何打开Editor Log： 在Mac上看起来就是这样的了： 可以看出这份log提供了一份资源总括：各种类型资源的总大小，以及所占百分比。同时还降序列出了单个文件的大小。 顺带一提，资源类型中的“Fileheaders”它们并不是资源本身，而是加在原始资源上，用来存储“引用”与“配置信息”的额外数据。通常可以忽略这些数据的大小，但如果在你的“Resources”文件夹里有着十分庞大的资源文件的话，这些数据也可能会很大。。 这份log可以帮助你鉴定哪些文件是你或许想要删掉或者进行优化的。 不过在开工之前，还需要先了解几点： 1、Unity再编码会把资源导成它自己的内部格式，所以资源源文件的类型是不相干的。比如你有一个多图层的PS纹理，那么在build之前它就会被拼接、压缩。所以刻意把这份纹理转成PNG格式其实对减少包大小并没有帮助。在开发时还是用最方便的格式就好了。 2、Unity会在build时去掉那些你的项目中没有使用到的资源，所以不需要我们手动找出来删掉了。但是脚本是不会被删掉的（不过它们不占资源），还有“Resources”文件夹里的全部资源，也是不会自动帮你删除的（因为Unity无法判断这里面哪些是需要用到的）。所以我们要确保“Resources”文件夹里的都是我们真正要用到的。当然，你还可以通过动态加载AssetBundles的方式来代替“Resources”文件夹里的资源，以减少包大小。 一些建议： 纹理（Textures）纹理通常会占据大部分空间。第一步要做的就是选用经压缩的纹理格式（DXT 或者PVRTC）。如果这样没有减少它的所占用空间，那么试试缩小纹理的尺寸吧。你不需要对资源本身进行修改，只要在 Project 下选中纹理，然后在Inspectpr 下设置Max Size就行了。 有一个好办法就是：在场景中找到使用了该纹理的object，放大画面，然后一边降低 Max Size，一边看场景中的object，直到它看起来比较糟糕，就可以知道怎样是最合适的了。。 由以上几张图对比来看，我们就能发现，选择512甚至256的Max Size，效果都是可以的，而且资源大小也能有显著的减少。修改纹理的MaxSize并不会影响到资源本身，只是改变了它在游戏里的分辨率。下表列出了不同图片格式所占用空间的大小（单位bpp：字节/像素） 一张图片的大小计算公式：width * height * bpp，如果你使用的是mipmap贴图，那么其大小将是普通图片的3倍左右。 Unity默认在导入纹理时就会进行压缩，为了在开发时节约时间，我们可以在偏好设置里手动关掉此功能 而在build时，Unity不管你有没有勾选这一项，都会对纹理进行压缩。 网格与动画（Meshes and Animations）网格与导入的动画（Animation Clips）都可以被压缩。在选中一个模型之后，就可以在Inspector中进行设置了。 不过对它们进行压缩，是可能造成误差的。所以最好先弄清楚什么程度的压缩是可接受范围内的。另外，mesh的压缩仅仅是减少数据文件的大小，并不会减少运行时的内存消耗。而减少动画关键帧，则会让两者都有所减少，一般情况下我们都应该开启。 动态链接库（DLLs）默认情况下，Unity只会在build时包含以下dll： 我们应该避免对 System.dll 或者 System.Xml.dll 有所引用，否则还是会在build时包含进来，而它们也会占用数M的空间。 如果在游戏中确实需要解析XML，那么可以使用“Mono.Xml.zip”来代替系统级的dll。此外，大多数泛型容器都已经包含在标准库中，只有少数几个在System.dll里，所以可能的话，也应该避免使用到它。 减少手机上使用的 .NET 库的大小Unity为移动设备提供了两套 .NET 的API：.NET 2.0 和.NET 2.0 Subset .NET 2.0提供了几乎整套的API功能，但是很多时候游戏都用不上那么多，导致大量多余的代码占用了宝贵的空间资源。为了避免浪费，我们就可以用Unity提供的 .NET2.0 Subset（相当于.NET2.0的一个子集）。为节省资源，这里面很多一般用不到的例程库都被移除了，所以这一优化也会是很有用的，只是需要确保我们的代码能够正常工作。 可在“Player Settings”中进行设置 移除无用的代码目前我们的项目比较适合使用Strip ByteCode选项,并配合link.xml使用,link.xml放到项目的Assetes目录下: 对于android平台，如果包实在太大，可以使用 Split Application Binary 功能在Player Setting &gt; Publishing Settings里， 关于Split Application Binary&lt;http://www.ceeger.com/Manual/android-OBBsupport.html&gt;","link":"/blog/2019/05/17/Unity优化/Unity3D如何减少安装包大小/"},{"title":"Unity中的批处理优化与GPU-Instancing","text":"Unity大中华区技术经理马瑞曾经为大家带来《Unity中的Daydream开发与实例》，本文马瑞将继续为大家分享Unity中的批处理优化与GPUInstancing技术。 我们都希望能够在场景中投入一百万个物体，不幸的是，渲染和管理大量的游戏对象是以牺牲CPU和GPU性能为代价的，因为有太多DrawCall的问题，最后我们必须找到其他的解决方案。 在本文中，我们将讨论两种优化技术，它们可以帮助您减少Unity游戏中的Draw Call数量以提高整体性能：批处理和GPU Instancing。 批处理开发者在日常工作中遇到的最常见的问题之一是性能不足，这是由于CPU和GPU的运行能力不足。一些游戏可以运行在PC上，但是在移动设备上不行。游戏运行时运行是否流畅受DrawCall数量的影响很大。有几个解决方案能帮助您解决这个问题。最常见的是批处理，包括Static Batching和Dynamic Batching。 Static Batching可以让引擎降低任何尺寸网格的Draw Call，如下图所示： 要让场景中的物体使用Static Batching，需要将其标记为Static，并在Mesh Renderer中共享相同的材质，因为StaticBatching不会在CPU上做顶点转换，所以它通常比DynamicBatching更有效。不过它会使用更多的内存，例如你的场景中有相同物体的多个副本，Unity会将它们组合成一个大网格并可能会增加内存使用。Unity将尽可能多的网格结合到一个静态网格中，并将其作为一个DrawCall提交。这种方法的缺点是：标记为Static的物体在其生命周期中不能移动。 Dynamic Batching启用时，Unity将尝试自动批量移动物体到一个DrawCall中。要使物体可以被动态批处理，它们应该共享相同的材质，但是还有一些其他限制： 顶点数量： DynamicBatching场景中物体的每个顶点都有一定的开销，因此批处理只适用于少于900个顶点属性的网格物体。举个例子，如果你的着色器使用顶点位置，法线和一个UV，那么你可以动态批处理多达300个顶点；而如果你的着色器使用顶点位置，法线，UV0，UV1和切线，那么只有180个顶点。值得注意的是，属性计数限制可能会在将来更改。 镜像信息： 如果物体包含的Transform具备镜像信息，例如A物体的大小是(1f, 1f, 1f)，而B物体的大小则是(-1f, -1f,-1f)，则无法做批处理。 材质 ：如果物体使用不同的材质实例，即使它们本质上相同，也不会被批量处理。而Shadow Caster Rendering是个例外。 渲染器：拥有光照贴图的物体有其他渲染器参数，例如光照贴图索引或光照贴图的偏移与缩放。一般来说，动态光照贴图的游戏对象应该指向要批量处理的完全相同光照贴图的位置。 不能使用Multi-pass着色器的情况： 几乎所有的Unity着色器都支持多个灯光的正向渲染模式（ForwardRendering），这要求额外的渲染次数，所以绘制 “额外的每像素灯”时不会被批处理；Legacy Deferred（Light Pre-Pass）渲染路径不能被动态批处理，因为它必须绘制物体两次。 Dynamic Batching通过将所有物体的顶点转换为CPU上的世界空间来工作，所以它只能在渲染DrawCall的工作量小于CPU顶点转换工作量的时候，才会起到提高性能的作用。当用游戏机或如Metal这样的现代API，DrawCall的开销通常低得多，Dynamic Batching就无法提高性能了。了解到以上限制后，如果明智地使用批处理，可以显著提高您游戏的性能。 GPU Instancing提高图形性能的另一个好办法是使用GPU Instancing。GPU Instancing的最大优势是可以减少内存使用和CPU开销。当使用GPUInstancing时，不需要打开批处理，GPU Instancing的目的是一个网格可以与一系列附加参数一起被推送到GPU。要利用GPUInstancing，您必须使用相同的材质，且可以传递额外的参数到着色器，如颜色，浮点数等。 Unity从5.4版本开始支持GPU Instancing。 唯一的限制是在游戏物体上要使用相同的材质和网格。 目前支持以下平台： Windows DX11/DX12 和 SM 4.0 或更高/OpenGL 4.1 或更高 OS X and Linux：OpenGL 4.1 and above 移动：OpenGL ES 3.0 或更高/Metal PlayStation 4 Xbox One 如果您想要进行进一步的优化，例如减少管理场景物体的开销，您也可以使用Graphics.DrawMeshInstanced方法。您只需要传递您的网格，材质和附加属性来绘制您的物体。现在的限制是一次最多1023个实例。在Unity5.6中，我们添加了Graphics.DrawMeshInstancedIndirect的新方法，可以用来指定需要渲染的实例数量。 GPU Instancing案例要创建支持GPU Instancing的基本标准表面着色器，可以在您的项目里面点击： Create-&gt;Shader-&gt;StandardSurfaceShader(Instanced)。 然后，在材质属性中选择新创建的着色器。 虽然实例化的物体共享相同的网格和材质，但您可以使用MaterialPropertyBlock API为每一个物体设置单独的着色器属性。 如果一个游戏对象被标记为“Static”并且打开了Static Batching，那么这个游戏对象就不能进行GPUInstancing，检视器中会出现一个警告框，提示“静态批处理”标志可以在播放器设置（PlayerSettings）中取消。如果游戏对象支持DynamicBatching，但是它使用的某个材质可以进行实例化，那么这个游戏对象将不会被批处理，并且将被自动实例化。 当使用Forward Rendering渲染模式，受多个灯光影响的物体无法有效地实例化。只有BasePass可以有效地利用实例化，而不是添加的Pass。此外，使用光照贴图或受不同光或Reflectionprobe影响的物体无法实例化。如下图所示，您可以在Frame Debug中发现和GPU Instancing相关的Draw Call被标记为“DrawMesh（Instanced）”。 GPU Instancing是一个非常强大的功能。在Unity5.6中，您可以使用Graphics.DrawMeshInstancedIndirect绘制大量网格。在MacPro中，我们能够画出约68万个具有不同颜色的移动立方体并保持稳定的60帧每秒的帧率。 下图是一个示例场景，超过6千个包子在天空中围绕一个大碗飞翔，它们都投射和接收阴影。由于使用了GPUInstancing，几乎没有性能开销。这里的包子模型使用了StandardSurface Shader（Instanced）。 总结在本文中，我们描述了用于优化渲染性能的两种最流行的技术：批处理和GPUInstancing。我们向您展示了如何在实践中使用它们并讨论可能的应用。正因为有诸如批处理和GPUInstancing等优化技术的存在，我们能够绘制大量的对象并保持稳定的性能。","link":"/blog/2019/05/17/Unity优化/Unity中的批处理优化与GPU-Instancing/"},{"title":"Unity内存优化","text":"一、内存使用 Q1：在Unity的内存管理机制中, Reserved Total 和 Used Total之间的关系是怎样的？ Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统“即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。所以，从图表中可以看到，ReservedTotal 的内存占用量略大于 Used Total， 且两者走势基本一致。 注意：对于绝大多数平台而言，Reserved Total内存 = Reserved Unity内存 + GFX内存 + FMOD内存 +Mono内存。大家可以参考《性能优化,进无止境——内存篇（上）》 Q2：在UWA的帮助下，我们追踪到了一个Reserved GFX的内存占用，并且显示比较高。我们应当如何降低该内存占用呢？ 一般来说，Reserved GFX中的内存，主要是纹理和网格资源，可以尝试对纹理格式进行检测，尽可能使用硬件支持的压缩纹理；而对于网格资源，则可以从减少顶点或者顶点属性入手。 另外，更重要的是检测纹理和网格资源是否存在冗余（多份一样的资源）或者泄露（比如，主城中的大纹理出现在战斗场景中），这是需要极力避免的。关于资源冗余、内存泄露，开发者可以参考我们之前的文章《 性能优化，进无止境——内存篇（下）》。 Q3：Profiler中Not Saved是指什么？ Profiler中的Not Saved指的是项目中通过代码生成的各种资源记录。如上图所示，其Mesh均为NGUI插件通过脚本生成的UI界面Mesh资源。 Q4：如图，在Editor中查看Profiler里的内存详细信息，发现Used Total中有个“Unity”，请问是什么意思？为什么会特别大？ 在Editor中运行时，“Unity”大是正常的，因为在Editor中运行项目时，引擎包含了所有的资源占用的内存（除了部分纹理和Mesh是在GFX中），同时自身会进行很多的辅助操作来记录各种游戏运行信息。一般来说，在查看游戏运行时的真实消耗内存，我们均是推荐直接在发布游戏上通过Profiler进行查看，在Editor中运行游戏所看到的内存是要大很多的。 Q5：不太明白Profiler中ManagedHeap.UsedSize是什么，以及这个参数的意义何在？是否重要？ ManagedHeap.UsedSize是项目逻辑代码在运行时申请的堆内存，该选项只能通过优化代码来进行降低。 优化方法一般如下： 尽可能地复用变量，减少new的次数； 使用StringBuilder代替String连接，使用for代替foreach； 对于局部变量或非常驻变量，尽可能使用Struct来代替Class。 ManagedHeap.UsedSize过大，一方面可能会影响一次GC的耗时；另一方面也可能反映出脚本中不合理的GC Alloc。 Q6：System.ExecutableAndDlls占内存巨大，且一直在增长，这个属于正常情况吗？ System.ExecutableAndDlls该项显示的是执行文件和所调用的库（物理、渲染、IO等系统库）的总和。开发团队不用太担心该选项的数值，因为很多应用均在共用这些库，并且它对于真实项目的内存压力非常小，几乎没有影响，而且OS也不会因为该内存而杀掉游戏或应用。 Q7：如下图：我在Profiler中看到这些没有引用的资源，他们是否还在内存中？ 是的，凡是在Unity Profiler中能看到的资源就会保留在内存中。对于这种资源，在切换场景时调一下UnloadUnusedAssetsAPI就可以释放。 Q8：有没有办法可以减少游戏中Mono内存占用的大小？我现在读完游戏表以后就占用了60MB，我看其他游戏读完配置表也才10MB左右，这个是怎么做到的呀？ 如果刚进入游戏后，Mono堆内存就达到了60MB，那么你的游戏项目极有可能在一开始加载了一个非常大的配置表。对此，我们建议出现该问题的研发团队对配置文件的初始加载进行详细检测，查看是否可以精简配置文件信息。如果不行，则尝试将配置文件拆散，按需加载，从而降低Mono内存上升过快问题发生的概率。 Q9：我用Profiler.BeginSample统计到的数据与直接看Memory下的不一样，前者比后者的数据更大，这是为何？用Profiler的API获取到的这一帧的内存消耗是85.6MB，而堆内存中显示的是62.9MB，这怎么理解？ ** ** Profiler中数据 这种情况确实也是经常会遇到的。一帧中分配如此高的内存是会触发GC.Collect的，而Mono中显示的数值则是GC之后的Mono内存数值。 Q10：正常情况下游戏如果一直玩下去，Mono是不是会一直增加？ 比如频繁打开一个界面，界面里有脚本会不断创建一些东西，那么Mono是否会不断增加？对性能上会不会造成影响呢？ Mono 确实是不会下降，但并不应该一直上升。 创建出来的东西，如果被引用在一个容器里，或者被某些脚本的变量引用，那么这部分堆内存就释放不掉；但如果没有被任何容器或者变量引用（比如，临时拼一个String），那么这部分堆内存会在 GC 的时候释放（释放是指变为空闲的堆内存，堆内存的总量是不会下降的）。 对于后者，频繁地 new 对象虽然不会一直增加堆内存，但是会加速 GC 调用的频率，所以同样是需要尽量避免的。 Q11：我想请教一下，下图这个函数中，每次我都申请了一个List temp =list();在这里存放6KB的数据，但是如果不做GC处理，这6KB是否就一直累加，直到做GC处理了才会释放掉，是这样么？如果调用次数很多，每次都调用一点点，也会推高内存占用吗？ 是的，这个6KB堆内存会随着Update的执行一直分配内存，所累积的堆内存会在GC触发时进行销毁。一般来说，研发团队需要尽可能避免在高频次调用函数中进行堆内存的分配。 Q12：在进行内存优化时，Unity Profiler给出的数据和Android系统(adb dumpsysmeminfo,已经考虑memtrack的影响)的数据差距较大（已经分析了Profiler自身的内存占用），如何分析这部分差异，比如包括对显存消耗进行准确统计，OS消耗的统计等等？ 内存差异较大是正常的，一般来说，Profiler统计的内存较为一致，而Android系统通过ADB反馈的PSS、PrivateDirty等值则是差别很大。这主要是因为芯片和OS的不同而导致。具体的Android内存，建议直接查看Google Android OS的相关文档。 Unity Profiler反馈的则是引擎的真实物理使用内存，一般我们都建议通过Profiler来查看内存是否存在冗余、泄露等问题。 Q13：已经预加载怪物，然后显示怪物 PSS上升，并且在隐藏怪物后并没有下降，这是什么原因导致？显存上去了吗？ 仅仅隐藏怪物的话，内存是不会下降的。因为隐藏只是改变了GameObject的状态，并没有对内存中的Object和资源进行移除。同时，即使是提前加载了怪物，也依然可能存在以上问题，因为某些资源是在显示的时候，才会传输一份到GPU的，比如Mesh。一般情况下，显存都不会即刻降低，这个是由GraphicsDriver来管理的。建议可以看Profiler是否增长，如果Profiler没有问题而PSS持续增长，就有可能发生了内存泄露。 对于这个问题，建议查看《性能优化，进无止境—内存篇（下）》加深理解。 Q14：对于Handheld.PlayFullScreenMovie这个Unity播放开场动画的API，会有内存问题吗？比如我的mp4动画有20MB，那么这个动画会撑高mono堆内存吗？ Android上PlayFullScreenMovie的实现实际上是通过Android原生的接口直接播放的，播放过程中Unity也是停止更新的，因此这部分的内存理论上并不会记录在 Unity中，同样也不影响mono。 Q15：Texture占用内存总是双倍，这个是我们自己的问题，还是Unity引擎的机制？ 出现这种情况的原因有两种：一种是你在真机运行时开启了Read&amp;Write。另一种可能是Unity的Bug，目前的Unity 5.2.3 releasenote如下 ： (735644) - OpenGL: Fixed texture memory usage reporting in profiler, was twicethe actual size for most textures. 开发者需要关注下自己的开发版本，5.2.3以前类似情况的项目可以参考一下。 Q16：如果脚本引用了GameObject，那转换场景的时候脚本和GameObject都没了，还会产生堆内存的吗？ 如果脚本是MonoBehaviour，而且在切换场景后所挂的Game Object被释放了，那么这个脚本对象所引用的堆内存就会在GC的时候被释放。但有一种例外，如果是通过Static变量引用的堆内存，那么依然是释放不掉的，除非手动解开引用，比如变量置Null，数组Clear等等。 二、内存泄露 &amp;冗余 Q1：我们测试了下发现，在名为A的MonoBehaviour中，有个数组来存放名为B的MonoBehaviour对象的引用。当我们其他的逻辑去Destroy了B对象所在的GameObject后，在A对象中的数组里，遍历打印，它们（B的引用）都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。这种现象是否正常？为什么值为Null但却还是被引用着，无法通过GC释放呢？ 首先这种现象是正常的。这是Unity中对Null的检测做了特殊的处理所致，在Unity中MonoBehaviour对象除了存在于ManagedHeap中（作为“壳”），在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时ManagedHeap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。 相关的细节可见官方blog对Unity中Null判断的解释：&lt;http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/&gt; Q2：字体作为多个资源的依赖包，会在游戏中被加载多次。我们现在有个问题，AssetBundleA资源依赖于这个字体，加载A的时候加载了一份字体，然后B资源也依赖这字体，而后加载B的时候我们没有去重复加载字体，这时候发现B资源上出现了字体丢失的现象。请问加载资源的时候，Unity会自动去识别内存里是否有它的资源依赖包吗？如果有的话，为什么B加载的时候找不到已经存在内存中的字体？这里需要手动去做些什么处理吗？ 同时我发现依赖包资源如果进行了bundle.m_AssetBundle.Unload(false)以后，其他依赖于这个包的资源就引用不到了。我们流程上对于每个读进来的AssetBundle，都会加载完后马上进行Unload(false)，请问如果是依赖包的话，是不是不能对其进行这步操作？ Unity引擎是会自动根据依赖关系去搜寻依赖的资源的，但需要注意的是，依赖的AssetBundle文件必须存在。也就是说，依赖关系包如果后续还会使用的话，是不应该被Unload的，否则后续AssetBundle加载上来后，被依赖的资源是无法找到的。对于Unity5.3之前的版本，出于内存的考虑，开发团队可以通过CreateFromFile或LoadFromCacheorDownload来加载AssetBundle，既可以保留AssetBundle之间的依赖关系，同时又不会产生Webstream。 开发团队可以参考《你应该了解的AssetBundle管理机制》，进一步了解相关API。 Q3：我们的游戏玩了20分钟后，Texture2D的内存涨到了60MB多，并且重复的资源很多，是否由于没有卸载完全？还是打包AssetBundle依赖性的问题？用的是UGUI。 ** ** 存在如下两个原因： 1、AB依赖关系打包存在问题，即atlas没有被依赖打包； 2、加载卸载的管理问题，可能是加载了一次后被一个Container索引了，这时又加载了一次同样的AssetBundle又被索引。如果这些一直没有释放，也会出现这种情况。","link":"/blog/2019/05/17/Unity优化/Unity内存优化/"},{"title":"Unity加载资源深度解析","text":"在游戏和VR项目的研发过程中，加载模块所带来的效率开销和内存占用（即“加载效率”、“场景切换速度”等）经常是开发团队非常头疼的问题，它不仅包括资源的加载耗时，同时也包含场景物件的实例化和资源卸载等。在我们看来，该模块的耗时是目前引擎中仅次于渲染的第二大模块。因此，我们认为非常有必要来跟大家分享一下目前加载模块的主要性能问题。 我们通过对提交到www.uwa4d.com网站的大量项目进行分析，认为目前加载模块中最为耗时的性能开销可以归结为以下几类：资源加载、资源卸载、Object的实例化和代码的序列化等 。今天，我们先为大家带来资源加载中纹理资源的加载性能分析。 这是侑虎科技第48篇原创文章，欢迎转发分享，未经作者授权请勿转载。同时如果您有任何独到的见解或者发现也欢迎联系我们，一起探讨。（QQ群465082844） 资源加载资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中，相信经常查看Profiler的朋友对这两项肯定毫不陌生了。 Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现，主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等。下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。 在很多项目中，存在另外一种加载方式，即场景为空场景，绝大部分资源和GameObject都是通过OnLevelWasLoaded回调函数中进行加载、实例化和拼合的。对于这种情况，Loading.UpdatePreloading的加载开销会很小。 Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。正因如此，我们就当前项目中所用的主流资源进行了大量的测试和分析，下面我们将分析结果与大家一起分享，希望可以帮到正在进行开发的你。 注意事项：本篇文章的资源性能分析主要是针对移动项目而言，因为目前UWA所测评的项目中，移动游戏/应用占比在90%以上。所以，我们选择首先在移动设备上针对每种资源的加载性能进行分析和总结。 资源加载性能测试代码以下为我们测试时所使用的测试代码，我们将每种资源均制作成一定大小的AssetBundle文件，并逐一通过以下代码在不同设备上进行加载，以期得到不同硬件设备上的资源加载性能比较。 ** ** 测试环境 引擎版本：Unity 5.2版本 测试设备：五台不同档次的移动设备（Android：红米2、红米Note2和三星S6，iOS：iPhone 5 和 iPhone 6） 纹理资源纹理资源是项目加载过程中开销占用最大的资源之一，其加载效率由其自身大小决定。目前，决定纹理资源大小的因素主要有三种：分辨率、格式和Mipmap是否开启。 1. 分辨率 &amp; 格式 分辨率和格式是影响纹理资源加载效率的重要因素，因为这两项的设置对纹理资源的大小影响很大。因此，我们对这两种因素进行了详细的测试： 测试1：相同格式、不同分辨率的加载效率测试 我们选取了两张分辨率为2048x2048的普通纹理资源，并在打成AssetBundle时，将其分辨率最大值分别设置为512x512、1024x1024和2048x20248，纹理格式均设置为ETC1（Android）和PVRTC（iOS）、且关闭Mipmap功能。所以，三组纹理的内存占用分别为256KB、1MB和4MB，其对应AssetBundle大小为156KB、531KB和1.92MB（对于Android平台）、175KB、628KB和2.4MB（对于iOS平台）。Unity版本为5.2，压缩格式为默认的LZMA压缩。 Android平台测试纹理： 我们在五种不同档次的机型上加载这些纹理资源，为降低偶然性，每台设备上重复进行十次加载操作并将取其平均值作为最终性能开销。具体测试结果如下表所示。 通过上述测试，我们可以得到以下结论： 1、纹理资源的分辨率对加载性能影响较大，分辨率越高，其加载越为耗时。设备性能越差，其耗时差别越为明显； 2、设备越好，加载效率确实越高。但是，对于硬件支持纹理（ETC1/PVRTC）来说,中高端设备的加载效率差别已经很小，比如图中的红米Note2和三星S6设备，差别已经很不明显。 测试2：不同格式、相同分辨率的加载效率测试 我们选取了两张分辨率为1024x1024的普通纹理资源，并在打成AssetBundle时，根据不同平台将其纹理格式分别设置不同格式用于打包。对于Android平台，我们使用ETC1、ETC2、RGBA16和RGBA32四种格式，对于iOS平台，我们使用PVRTC4BPP、RGBA16和RGBA32三种格式，同时，对于每张纹理均关闭Mipmap功能。所以，三组纹理的内存占用分别为1MB、1MB、4MB 和8MB（Android平台）/1MB、4MB 和 8MB（iOS平台）。 Android平台测试纹理： 与测试1相同，我们在五种不同档次的机型上重复进行十次加载操作并将取其平均值作为最终性能开销。具体测试结果如下图所示。 Android设备： ** ** iOS设备： 通过上述测试，我们可以得到以下结论： 1、纹理资源的格式对加载性能影响同样较大，Android平台上，ETC1和ETC2的加载效率最高。同样，iOS平台上，PVRTC 4BPP的加载效率最高。 2、RGBA16格式纹理的加载效率同样很高，与RGBA32格式相比，其加载效率与ETC1/PVRTC非常接近，并且设备越好，加载开销差别越不明显； 3、RGBA32格式纹理的加载效率受硬件设备的性能影响较大，ETC/PVRTC/RGBA16受硬件设备的影响较低。 注意事项：这里需要指出的是测试中所使用的ETC1和ETC2纹理均为RGB4Bit格式，所以对于半透明纹理贴图，需要两张ETC1格式的纹理进行支持（一张RGB通道，一张Alpha通道）。逐一加载两张ETC1格式的纹理，其加载效率要低于RGBA16格式，但可以通过加载方式来进行弥补。这一点我们将在后续文章中进行详细说明。 2. 开启Mipmap功能 开启Mipmap功能同样会增大一部分纹理大小，一般来说，其内存会增加至原始大小的1.33倍。因此，我们对开启Mipmap功能前后的加载性能进行了详细的测试： 测试3：开启/关闭Mipmap功能的加载效率测试 我们仍然使用两张分辨率为1024x1024的普通纹理资源，分别使用ETC1格式、PVRTC格式、RGBA16格式和RGBA32格式（测试所用纹理与测试2相同），并在打成AssetBundle时，一组开启Mipmap功能，一组关闭Mipmap功能。 与测试1相同，我们在五种不同档次的机型上重复进行十次加载操作并将取其平均值作为最终性能开销。具体测试结果如下图所示。 Android平台： ** ** ** ** iOS平台： ** ** 通过上述测试，我们可以看出： 开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大。 通过以上性能测试，我们对于纹理资源的加载建议如下： 1、严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。 2、在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。 3、严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。 4、ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGLES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGLES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。 ** ** 正是由于以上加载效率问题，我们在UWA测评报告中加入了对每个检测到的纹理资源参数的详细展示，以方便开发团队可以快速查看资源的使用情况，只需对相关信息列进行排序，即可定位引发性能问题的具体资源。 ** ** 说明：以上测试数据为我们所用的测试纹理加载数据，需要指出的是，不同纹理的加载效率是不相同的，因为其内容的不同会造成AssetBundle压缩包大小的不同，进而造成最终加载效率的不同。这里我们给出的具体性能比较，其本意是让大家通过数据直观了解到纹理格式、分辨率和Mipmap功能对加载性能的影响。另外，我们后续会进行更多的测试，以期为大家提供更为普遍的测试结果。 以上为纹理资源在加载时的性能测试。关于加载模块的性能问题，我们会不断推出网格、音频等其他资源的加载性能分析、资源卸载性能分析、资源实例化性能分析、不同加载方式的性能分析等一系列技术文章，并对目前UWA所检测过项目的共性问题进行总结，以期让大家对项目的加载效率有更加深入的认知，并提升对加载模块的掌控能力。","link":"/blog/2019/05/17/Unity优化/Unity加载资源深度解析/"},{"title":"Unity图集的理解和使用","text":"图集的好处： 1.减少draw call: 多张图片需要多次draw call，合成了一张大图则只需要一次draw call。 2.减少内存占用：OpenGLES中每张贴图都需要设置成2的n次方才能使用。比如你有一张宽高为100x100和一张宽高为10x10的图片,如果不合成大贴图,那么需要使用128x128和16x16的两张图片(分别是2的7次方和2的4次方),但如果使用一张大图的话，可以把100x100和10x10的图片放到128x128的大图中,这样就用一张图片。 UGUI的图集打包与工作原理，整整看了一天多，终于看明白了～晕～还是记录一下我研究的成果，也希望大家在下面给我留言我们一起讨论一下。 先说说UGUI的Atlas和NGUI的Atlas的区别，NGUI是必须先打出图集然后才能开始做界面。这一点很烦，因为始终都要去考虑你的UI图集。比如图集会不会超1024，图集该如何来规划等等。而UGUI的原理则是，让开发者彻底模糊图集的概念，让开发者不要去关心自己的图集。做界面的时候只用小图，而在最终打包的时候unity才会把你的小图和并在一张大的图集里面。然而这一切一切都是自动完成的，开发者不需要去care它。 如下图所示，Editor-&gt;Project Settings 下面有sprite packer的模式。Disabled表示不启用它，Enabled ForBuilds 表示只有打包的时候才会启用它，Always Enabled 表示永远启用它。 这里的启用它就表示是否将小图自动打成图集。 我的选项是Always Enabled 。因为开发的时候我们需要清楚的看到现在是几个DrawCall，从而才能优化小图。在最终打包的时候unity会自动构建大的图集，可是我开发的时候就想看图集会占几个DrawCall，这怎么办呢？如下图所示，首先将你的图片拖入unity中，将同一图集的所有图片的packing tag设置成一个名子即可。 注意你的图片不能放在Resources文件夹下面，Resources文件夹下的资源将不会被打入图集，切记（也就是在这里混淆了我很久）。然后在Windows-&gt;SpritePacker 里，点击packer在这里你就可以预览到你的图集信息。图集的大小还有图集的格式等等很多参数我们都是可以控制的，也可以通过脚本来设置。我在下一篇文章里详细说这个（请期待嘿嘿）。 图集的预览紧紧是让你看看你的图集大概张什么样子。那么我们的图集的这张图片保存在了哪里呢？它保存在和Assets文件夹同级的目录，Libary/AtlasCache里面。你不用管它，也不要删除它，就算你删除了也没用因为只要你打包，它就会生成并且会打到包中。 此时在Hierarchy视图中创建两个Image对象。如下图所示，我们可以清楚的看到此时我的draw call已经被合并成了1 。 这两个图片是我是在Editor模式下预先拖入Hierarchy视图中的，可是如果我想运行时根据图片的名子来动态创建精灵该如何？可是unity根本没有提供加载图集的方法，也没有提供加载图集上某个图片的方法。因为UGUI就不像让开发者有图集的这个概念，可是我们肯定是要实现这个需求的。。怎么办呢？ 第一个设想，先把散＝小图打包成图集，然后再把所有散图拷贝在Resources文件夹下，这样运行时就能用Resources.load了。 第二个设想，还是先把小图打成图集，然后把所有小图关联在prefab上，拷贝在Resources文件夹下，这样运行时也能用Resources.load了。到底那个靠谱呢？给大家看一个图大家就知道答案了。 如下图所示，打成图集的图片如果在放在Resources那么资源就变成双份了。。所以我们只能把小图关联在Prefab上，把所有的Prefab放在Resources下面，这样就不占用多余的空间了。 好了，现在方法我们已经掌握，那么就开始写工具吧。如下图所示可以按文件夹分，每一个文件夹就是一个图集。然后每一张小图创建一个Prefab，Prefab的名子就起小图的名子，文件关联在Resources下面。 、 代码比较简单，我就不注释了。 [MenuItem (“MyMenu/AtlasMaker”)] static private void MakeAtlas() { string spriteDir = Application.dataPath +”/Resources/Sprite”; if(!Directory.Exists(spriteDir)){ Directory.CreateDirectory(spriteDir); } DirectoryInfo rootDirInfo = new DirectoryInfo (Application.dataPath+”/Atlas”); foreach (DirectoryInfo dirInfo in rootDirInfo.GetDirectories()) { foreach (FileInfo pngFile indirInfo.GetFiles(“*.png”,SearchOption.AllDirectories)) { string allPath = pngFile.FullName; string assetPath = allPath.Substring(allPath.IndexOf(“Assets”)); Sprite sprite = Resources.LoadAssetAtPath(assetPath); GameObject go = new GameObject(sprite.name); go.AddComponent().sprite = sprite; allPath = spriteDir+”/“+sprite.name+”.prefab”; string prefabPath = allPath.Substring(allPath.IndexOf(“Assets”)); PrefabUtility.CreatePrefab(prefabPath,go); GameObject.DestroyImmediate(go); } } } 然后是运行时的代码。 using UnityEngine; using System.Collections; using UnityEngine.UI; public class UIMain : MonoBehaviour { void Start () { CreatImage(loadSprite(“image0”)); CreatImage(loadSprite(“image1”)); } private void CreatImage(Sprite sprite ){ GameObject go = new GameObject(sprite.name); go.layer = LayerMask.NameToLayer(“UI”); go.transform.parent = transform; go.transform.localScale= Vector3.one; Image image = go.AddComponent(); image.sprite = sprite; image.SetNativeSize(); } private Sprite loadSprite(string spriteName){ return Resources.Load(“Sprite/“ +spriteName).GetComponent().sprite; } } 因为这两个图是在同一个图集上，所以drawcall就是1了。这样我们就可以根据图片的名子来运行时加载图片了。 接下来就是Assetbundle了，如果我们的图集需要在线更新那该怎么办呢？其实Assetbundle比Resources要更简单一些，无论如何我们要先开始打图集。 [MenuItem (“MyMenu/Build Assetbundle”)] static private void BuildAssetBundle() { string dir = Application.dataPath +”/StreamingAssets”; if(!Directory.Exists(dir)){ Directory.CreateDirectory(dir); } DirectoryInfo rootDirInfo = new DirectoryInfo (Application.dataPath+”/Atlas”); foreach (DirectoryInfo dirInfo in rootDirInfo.GetDirectories()) { List assets = new List(); string path = dir +”/“+dirInfo.Name+”.assetbundle”; foreach (FileInfo pngFile indirInfo.GetFiles(“*.png”,SearchOption.AllDirectories)) { string allPath = pngFile.FullName; string assetPath = allPath.Substring(allPath.IndexOf(“Assets”)); assets.Add(Resources.LoadAssetAtPath(assetPath)); } if(BuildPipeline.BuildAssetBundle(null, assets.ToArray(),path,BuildAssetBundleOptions.UncompressedAssetBundle|BuildAssetBundleOptions.CollectDependencies, GetBuildTarget())){ } } } static private BuildTarget GetBuildTarget() { BuildTarget target = BuildTarget.WebPlayer; #if UNITY_STANDALONE target = BuildTarget.StandaloneWindows; #elif UNITY_IPHONE target = BuildTarget.iPhone; #elif UNITY_ANDROID target = BuildTarget.Android; #endif return target; } 如下图所示，我的assetbundle已经打出来了。 然后把UIMain.cs在改一改。 using UnityEngine; using System.Collections; using UnityEngine.UI; public class UIMain : MonoBehaviour { AssetBundle assetbundle = null; void Start () { CreatImage(loadSprite(“image0”)); CreatImage(loadSprite(“image1”)); } private void CreatImage(Sprite sprite ){ GameObject go = new GameObject(sprite.name); go.layer = LayerMask.NameToLayer(“UI”); go.transform.parent = transform; go.transform.localScale= Vector3.one; Image image = go.AddComponent(); image.sprite = sprite; image.SetNativeSize(); } private Sprite loadSprite(string spriteName){ #if USE_ASSETBUNDLE if(assetbundle == null) assetbundle = AssetBundle.CreateFromFile(Application.streamingAssetsPath+”/Main.assetbundle”); return assetbundle.Load(spriteName) as Sprite; #else return Resources.Load(“Sprite/“ +spriteName).GetComponent().sprite; #endif } } 如下图所示，依然还是一个drawcall。 衷心希望有经验的朋友在留言处给我提提意见， 或者大家一起讨论讨论。。 我们共同为把NGUI干掉的目标而奋斗，嘻嘻。","link":"/blog/2019/05/17/Unity优化/Unity图集的理解和使用/"},{"title":"Unity性能优化方法总结","text":"资源分离打包与加载 游戏中会有很多地方使用同一份资源。比如，有些界面共用同一份字体、同一张图集，有些场景共用同一张贴图，有些怪物使用同一个Animator，等等。在制作游戏安装包时将这些公用资源从其它资源中分离出来，单独打包。比如若资源A和B都引用了资源C，则将C分离出来单独打一个bundle。在游戏运行时，如果要加载A，则先加载C；之后如果要加载B，因为C的实例已经在内存，所以只要直接加载B，让B指向C即可。如果打包时不将C从A和B分离出来，那么A的包里会有一份C，B的包里也会有一份C，冗余的C会将安装包撑大；并且在运行时，如果A和B都加载进内存，内存里就会有两个C实例，增大了内存占用。 资源分离打包与加载是最有效的减小安装包体积与运行时内存占用的手段。一般打包粒度越细，这两个指标就越小；而且当两个renderQueue相邻的DrawCall使用了相同的贴图、材质和shader实例时，这两个DrawCall就可以合并。但打包也并不是越细就越好。如果运行时要同时加载大量小bundle，那么加载速度将会非常慢——时间都浪费在协程之间的调度和多批次的小I/O上了；而且DrawCall合并不见得会提高性能，有时反而会降低性能，后文会提到。因此需要有策略地控制打包粒度。一般只字体和贴图这种体积较大的公用资源。 可以用AssetDatabase.GetDependencies得知一份资源使用了哪些其它资源。 2 贴图透明通道分离，压缩格式设为ETC/PVRTC 最初我们使用了DXT5作为贴图压缩格式，希望能减小贴图的内存占用，但很快发现移动平台的显卡是不支持的。因此对于一张1024x1024大小的RGBA32贴图，虽然DXT5可将它从4MB压缩到1MB，但系统将它送进显卡之前，会先用CPU在内存里将它解压成4MB的RGBA32格式（软件解压），然后再将这4MB送进显存。于是在这段时间里，这张贴图就占用了5MB内存和4MB显存；而移动平台往往没有独立显存，需要从内存里抠一块作为显存，于是原以为只占1MB内存的贴图实际却占了9MB！ 所有不支持硬件解压的压缩格式都有这个问题。经过一番调研，我们发现安卓上硬件支持最广泛的格式是ETC，苹果上则是PVRTC。但这两种格式都是不带透明（Alpha）通道的。因此我们将每张原始贴图的透明通道都分离了出来，写进另一张贴图的红色通道里。这两张贴图都采用ETC/PVRTC压缩。渲染的时候，将两张贴图都送进显存。同时我们修改了NGUI的shader，在渲染时将第二张贴图的红色通道写到第一张贴图的透明通道里，恢复原来的颜色： fixed4 frag (v2f i) : COLOR fixed4 col; col.rgb = tex2D(_MainTex, i.texcoord).rgb; col.a = tex2D(_AlphaTex, i.texcoord).r; return col * i.color;fixed4 frag (v2f i) : COLOR { fixed4 col; col.rgb = tex2D(_MainTex, i.texcoord).rgb; col.a = tex2D(_AlphaTex, i.texcoord).r; return col * i.color;} 这样，一张4MB的1024x1024大小的RGBA32原始贴图，会被分离并压缩成两张0.5MB的ETC/PVRTC贴图（我们用的是ETC/PVRTC 4bits）。它们渲染时的内存占用则是2x0.5+2x0.5=2MB。 3 关闭贴图的读写选项 Unity中导入的每张贴图都有一个启用可读可写（Read/WriteEnabled）的开关，对应的程序参数是[TextureImporter.isReadable](http://docs.unity3d.com/ScriptReference/TextureImporter-isReadable.html)。选中贴图后可在ImportSetting选项卡中看到这个开关。只有打开这个开关，才可以对贴图使用Texture2D.GetPixel，读取或改写贴图资源的像素，但这就需要系统在内存里保留一份贴图的拷贝，以供CPU访问。一般游戏运行时不会有这样的需求，因此我们对所有贴图都关闭了这个开关，只在编辑中做贴图导入后处理（比如对原始贴图分离透明通道）时打开它。这样，上文提到的1024x1024大小的贴图，其运行时的2MB内存占用又可以少一半，减小到1MB。 4 减少场景中的GameObject数量 有一次我们将场景中的GameObject数量减少了近2万个，游戏在iPhone3S上的内存占用立马减了20MB。这些GameObject虽然基本是在隐藏状态（activeInHierarchy为false），但仍然会占用不少内存。这些GameObject身上还挂载了不少脚本，每个GameObject中的每个脚本都要实例化，又是一比不菲的内存占用。因此后来我们规定场景中的GameObject数量不得超过1万，并且将GameObject数量列为每周版本的性能监测指标。 5 图集 整理图集的主要目的是节省运行时内存（虽然有时也能起到合并DrawCall的作用）。从这个角度讲，显示一个界面时送进显存的图集尺寸之和是越小越好。一般有如下方法可以帮助我们做到这点： 1）在界面设计上，尽量让美术将控件设计为可以做九宫格拉伸，即UISprite的类型为Sliced。这样美术就可以只切出一张小图，我们在Unity中将它拉大。当然，一个控件做九宫格也就意味着其顶点数量从4个增加到至少16个（九宫格的中心格子采用Tiled做平铺类型的话，顶点数会更多），构建DrawCall的开销会更大（见第6点），但一般只要DrawCall安排合理（同样见第6点）就不会有问题。 2）同样是在界面设计上，尽量让美术将图案设计成对称的形式。这样切图的时候，美术就可以只切一部分，我们在Unity中将完整的图案拼出来。比如对一个圆形图案，美术可以只切出四分之一；对一张脸，美术可以只切出一半。不过，与第1）点类似，这个方法同样有其它性能代价——一个图案所对应的顶点数和GameObject数量都增多了。第4点已经提到，GameObject数量的增多有时也会显著占用更多内存。因此一般只对尺寸较大的图案采用这个方法。 3）确保不要让不必要的贴图素材驻留内存，更不要在渲染时将无关的贴图素材送进显存。为此需要将图集按照界面分开，一般一张图集只放一个界面的素材，一个界面中的UISprite也不要使用别的界面的图集。假设界面A和界面B上都有一个小小的一模一样的金币图标，不要因为在制作时贪图方便，就让界面A的UISprite直接引用界面B中的金币素材；否则界面A显示的时候，会将整个界面B的图集也送进显存，而且只要A还在内存中，B的图集也会驻留内存。对于这种情况，应该在A和B的图集中各放一个一模一样的金币图标，A中的UISprite只使用A的图集，B中的UISprite只使用B的图集。 不过，如果两个界面之间存在大量相同的素材，那么这两个界面就可以共用同一张图集。这样可以减少所有界面的总内存占用量。具体操作时需要根据美术的设计进行权衡。一般界面之间相同的通用的素材越多，程序的内存负担就越小。但界面之间相同的东西太多的话，美术效果可能就不生动，这是美术和程序之间又一个需要寻求平衡的地方。 另外，数量庞大的图标资源（如物品图标）不要做在图集里，而应该采用UITexture。 4）减少图集中的空白地方。图集中完全透明的像素和不透名的像素所占的内存空间其实是一样的。因此在素材量不变的情况下，要尽量减少图集中的空白。有时一张1024x1024的图集中，素材所占的面积还没超过一半，这时可以考虑将这张图集切成两张512x512的图集。（有人会问为什么不能做成一张1024x512的图集，这是因为iOS平台似乎要求送进显存的贴图一定是方形。）当然，两张不同图集的DrawCall是无法合并的，但这并不是什么问题（见第6点）。 应该说，图集的整理在具体操作时并没有一成不变的标准，很多时候需要权衡利弊来最终决定如何整理，因为不管哪种措施都会有别的性能代价。 8 降低贴图素材分辨率 这一招说白了其实就是减小贴图素材的尺寸。比如对一张在原画里尺寸是100x80的，我们将它导入Unity后会把它缩小到50x40，即缩小两倍。游戏实际使用的是缩小后的贴图。不过这一招是必然会显著降低美术品质的，美术立马会发现画面变得更模糊，因此一般不到程序撑不住的时候不会采用。 9 界面的延迟加载和定时卸载策略 如果一些界面的重要性较低，并且不常被使用，可以等到界面需要打开显示的时候才从bundle加载资源，并且在关闭时将卸载出内存，或者等过一段时间再卸载。不过这个方法有两个代价：一是会影响体验，玩家要求打开界面时，界面的显示会有延迟；二是更容易出bug，上层写逻辑时要考虑异步情况，当程序员要访问一个界面时，这个界面未必会在内存里。因此目前为止我们仍未实施该方案。目前只是进入一个新场景时，卸载上一个场景用到但新场景不会用到的界面。 以上的9个方法中，4、5、6需要在一定程度上从策划和美术的角度考虑问题，并且需要持续保持监控以维护优化状态（因为在设计上总是会有新界面的需求或改动老界面的需求）；其它都是一劳永逸的解决方案，只要实施稳定后，就不需要再在上面花费精力。不过2和8都是会降低美术品质的方法，尤其是8。如果美术对品质的降低程度实在忍不了的话，也可能不会允许采用这两个方法。 10避免频繁调用GameObject.SetActive 我们游戏的某些逻辑会在一帧内频繁调用GameObject.SetActive，显示或隐藏一些对象，数量达到一百多次之多。这类操作的CPU开销很大（尤其是NGUI的UIWidget在激活的时候会做很多初始化工作），而且会触发大量GC。后来我们改变了显示和隐藏对象的方法——让对象一直保持激活状态（activeInHierarchy为true），而原来的SetActive(false)改为将对象移到屏幕外，SetActive(true)改为将对象移回屏幕内。这样性能就好多了。","link":"/blog/2019/05/17/Unity优化/Unity性能优化方法总结/"},{"title":"unity图片mipmap","text":"Mipmap技术有点类似于LOD技术，但是不同的是，LOD针对的是模型资源，而Mipmap针对的纹理贴图资源 使用Mipmap后，贴图会根据摄像机距离的远近，选择使用不同精度的贴图。 会占用内存，因为mipmap会根据摄像机远近不同而生成对应的八个贴图，所以必然占内存！ 优点： 会优化显存带宽，用来减少渲染，因为可以根据实际情况，会选择适合的贴图来渲染，距离摄像机越远，显示的贴图像素越低，反之，像素越高！ MipMap可以用于跑酷类游戏，当角色靠近时，贴图清晰显示，否则模糊显示 如果我们使用的贴图不需要这样效果的话，就一定要把Generate Mip Maps选项和Read/WriteEnabled选项取消勾选！因为Mipmap会十分占内存！ mipMap会让你的包占更大的容量！ 下面来看下怎么设置贴图的mipmap： 设置贴图的Texture Type为Advanced类型 → 勾选Generate Mip Maps → Apply应用 来看看贴图的变化，可以看出生成了对应的8个Mip 那么贴图就会根据摄像机的远近，显示相应的贴图了！","link":"/blog/2019/05/17/Unity优化/unity图片mipmap/"},{"title":"unity图片压缩格式和内存计算","text":"例子1：使用RGBA 32bit真彩（Truecolor），占用内存 = 4Bytes512512 = 1MB; 例子2：使用RGB ETC 4bit压缩，占用内存 = 0.5Bytes512512 = 128KB 一、2的N次方大小的图片会得到引擎更大的支持，包括压缩比率，内存消耗，打包压缩大小，而且支持的力度非常大。 二、减小图片的占用大小和内存方式有:图片大小变化(Maxsize),色彩位数变化(16位，32位)，压缩(PVRC)。 三、U3D对于图片的格式是自己生成的，而并不是你给他什么格式，他就用什么格式，一张10241024图在无压缩格式下，它会被U3D以无压缩文件形式存放，也就是说U3D里的TexturePreview里显示的占用大小*MB不只是内存占用大小，还是空间占用大小 U3D的内部机制为自动生成图片类型来替换我们给的图片，在图片的压缩方式上需要进行谨慎的选择。 压缩格式在U3D的Component Reference里有介绍我就不再详细介绍，只介绍几个重点的: RGBA32格式为无压缩最保真格式，但也是最浪费内存和空间的格式。Automatic Turecolor和它一个意思。 RGBA16格式为无压缩16位格式，比32位节省一半的空间和内存。Automatic 16bits和它一个意思。 RGBA Compressed PVRTC4bits格式为PVRTC图片格式，它相当于把图片更改了压缩方式新生成了一个图片来替换原来的我们给的图片格式(比如我们给的是PNG格式)。 注意：U3D所有图片的压缩格式都会以另一种方式来存储，不会以你给的方式来存储，只有你指定了某种格式，它才会转成你要的格式。而且压缩格式在Android里并不一定有效，因为Android的机型多，GPU的渲染方式也不一样，有的是Nvidia，有的是PowerVR，最最好的在安卓机子上启用RGBA16方式，因为这个是适应所有机型的，并且比32位占用量少一半，但也需要因项目而异，只是推荐使用的格式，可以多用，但要权衡内存和显示效果。","link":"/blog/2019/05/17/Unity优化/unity图片压缩格式和内存计算/"},{"title":"unity性能优化","text":"资源管理Q：我们图标现在是制作成图集后再使用的，但是当图标数量很多的时候，图集的膨胀就很厉害了。对此我们的做法有两种：1）拆为多个图集； 2）不再使用图集转而使用UITexture来使用。请问UWA有什么建议呢？ 使用图集的主要缺点在于内存较大，且管理不便；而使用UITexture的主要缺点在于产生的Draw Call较多（每个UITexture都会产生一个DrawCall且无法拼合），影响运行效率。因此，如果同时出现在屏幕上的图标不多，即UITexture所产生的DrawCall数量不大时，可以考虑直接使用；但如果图标数量较多，且目前项目的DrawCall已经较高，那么我们依然建议继续使用图集，按照一定的规则拆分为若干组，从而将 Draw Call控制在较低的范围内。 Q：粒子系统的Prewarm主要用来做什么的，这个怎么优化呢？ ParticleSystem.Prewarm的出现表示当前加载、激活或者首次渲染的粒子系统开启了”Prewarm”选项，而开启该选项的粒子系统在加载后会立即执行一次完整的模拟。以“火焰”为例，Prewarm开启时，加载后第一帧即能看到“大火”，而不是从“火苗”开始逐渐变大。但Prewarm的操作通常都有一定的耗时，建议在可以不用的情况下，将其关闭。 Q：我们为了降低像素填充就限制了最大分辨率，但是发现限制之后NGUI的字体显示就变得模糊了。是否可以避免NGUI字体模糊呢？下图是我们在小米5上测试得到的结果：低分辨率下文字就模糊了。 从开发团队提供的图片上看，小米5上的低分辨率用的是983x552，相当于将原来的画面的四分之一分辨率。此时，降低分辨率的做法可以理解为把983x552的纹理拉伸后贴到1920x1080的屏幕上，而“贴”的过程还会涉及到重新采样，因此造成模糊是正常的，而不仅仅是文本。只是文本的边缘对比度较高，拉伸后变糊的现象会更加明显。 我们建议尝试通过RenderTexture来控制不同内容的分辨率，对于UI部分尽量不要把分辨率降得太低。 Q：打包AssetBundle的时候，我发现切换场景时，即使打同一个场景的AssetBundle，它们的Hash值都是不一样的，可能是什么原因造成的呢？ 在不同的场景下打包同一个资源或场景时，如果出现AssetBundle的差异，目前很可能是ShaderStripping造成的，其原理可见文档：&lt;https://docs.unity3d.com/Manual/class-GraphicsSettings.html&gt; 简单来说就是根据当前场景对Shader进行简化，因此如果打包时包含的场景的Lightmap或Fog设置不同，打出来的AssetBundle包也有可能是不同的。可以尝试通过把GraphicsSettings中的Shader Stripping设置进行修改来避免这个问题。 Q：当UI关闭后，Texture图片却还留在内存，是下次垃圾回收或者Resources.UnloadUnusedAssets调用的时候就会清除吗？如果想立即清除，该如何操作？ 垃圾回收并不会卸载内存中的资源，而Resources.UnloadUnusedAssets是可以的，但前提是纹理资源已经不再被其他Object引用。如果要立即清除，可以尝试直接调用Resources.UnloadAsset来进行卸载。 Q：我们的游戏中，不透明渲染在总体渲染里占比较高，主要的开销在于 MeshSkinning.Render 部分，这部分的DrawCall过高，共有65个， 请问该如何优化呢？ 默认情况下Skinned Mesh是无法合并Draw Call的，从而导致Draw Call过高的问题。 我们建议尝试通过SkinnedMeshRenderer的BakeMesh接口，将蒙皮动画转为网格序列帧，同时确保顶点属性的数目符合动态拼合的条件，从而降低这部分的DrawCall。另外，这种做法也可以降低MeshSkinning.Update以及Animator.Update的CPU耗时，只是网格序列帧会占用较大的内存，研发团队可以尝试做一个评估。 Q:预设中的变量，拖拽到Inspector面板和Transform.find这两种方法对加载影响是一样的吗？ 对加载性能有微小的不同。Transform.Find是可以灵活控制调用时机的，可以真正要用的时候再进行Transform.Find，这样GameObject被实例化时效率会更高一些。但如果拖上去，GameObject被实例化时，该变量就需要进行序列化。因此，加载和实例化时两者的性能会存在一些微小的变化。 UI Q：我发现当把UI挪到屏幕外时，Draw Call不会减少，只有设置Enabled去掉才能减少。UI是没有遮罩剔除这类功能吗？那是否意味着ScrollRect只能自己做动态加载或者动态设置Enabled之类的优化了？ 因为UGUI合并网格时是以Canvas为单位的，所以只把一部分UI元素移除屏幕并不能降低Draw Call，在Unity 5.2版本以前需要满足两点： 1． 使用Screen Space – Camera 的 Render Mode； 2． 需要将移出的UI元素放在独立的Canvas中，然后整体移出屏幕。 但在Unity 5.2版本之后，上述方法也已经失效。 因此我们建议，在移出后，通过将Canvas的Layer修改为相机Culling Mask中未选中的Layer来去除这部分多余的Draw Call，&gt;但这种方法同样需要将移出的UI元素放在独立的Canvas中。这种方法，相比Enabled的设置，可以减少一定的CPU开销。而对于ScrollRect，如果包含的UI元素较多，确实需要自己做动态加载和动态设置Enabled来进行优化。 Q：UI展示动画时，使用Mask做和使用UI本身做 ，哪个效率会更高些? 一般来说建议尽可能少用Mask组件，该组件的使用对于Draw Call会有较大的影响，也可尝试用 Rect2DMask来代替。而如果直接通过改变UI元素本身来做动画，当涉及的UI元素数量较大时，容易引起较高的网格重建开销。 Q：GameObject.Instantiate()每实例化一个GameObject到场景中，会造成卡顿，有什么办法可以优化吗？就算我采用了异步加载，仍然会有稍许的卡顿感。除了缓存池，是否还有别的方法？ 建议研发团队先通过UnityProfiler来确定该性能卡顿的位置。如果只是一个空的GameObject，Instantiate实例化是很快的。一般来说，Instantiate实例化时间较长，主要由以下三个原因： （1）与资源的加载有关：对于这种情况，研发团度需要精简资源，或者预加载资源来降低实例化的开销； （2）序列化信息比较多：当GameObject上的Component比较多时，其Instantiate实例化性能会受到影响，比如说粒子系统，这种情况就只能通过分帧实例化，或者通过缓存池来避免； （3）自定义组件的Awake：在Instantiate实例化时，其GameObject上挂载脚本的Awake函数也会被触发，其中产生的CPU占用，也会被计算在Instantiate实例化内。","link":"/blog/2019/05/17/Unity优化/unity性能优化/"},{"title":"unity性能优化CPU篇","text":"CPU方面就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。正因如此，我们在UWA测评报告中，就这些模块进行详细的性能分析，以方便大家快速定位项目的性能瓶颈，同时，根据我们的分析和建议对问题进行迅速排查和解决。 通过大量的性能测评数据，我们发现渲染模块、UI模块和加载模块，往往占据了游戏CPU性能开销的Top3。 一、渲染模块渲染模块可以说是任何游戏中最为消耗CPU性能的引擎模块，因为几乎所有的游戏都离不开场景、物体和特效的渲染。对于渲染模块的优化，主要从以下两个方面入手： （1）降低Draw Call Draw Call是渲染模块优化方面的重中之重，一般来说，DrawCall越高，则渲染模块的CPU开销越大。究其原因，要从底层Driver和GPU的渲染流程讲起，限于篇幅我们不在这里做过多的介绍。有兴趣的朋友可以查看[这里](http://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive)，或者自行Google相关的技术文献。 降低Draw Call的方法则主要是减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量。Unity文档对于Draw CallBatching的原理和注意事项有非常详细的讲解，感兴趣的朋友可以直接查看Unity官方文档。 但是，需要注意的是，游戏性能并非Draw Call越小越好。这是因为，决定渲染模块性能的除了DrawCall之外，还有用于传输渲染数据的总线带宽。当我们使用Draw CallBatching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。 Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。 （2）简化资源 简化资源是非常行之有效的优化手段。在大量的移动游戏中，其渲染资源其实是“过量”的，过量的网格资源、不合规的纹理资源等等。所以，我们在UWA测评报告中对资源的使用进行了详细的展示（每帧渲染的三角形面片数、网格和纹理资源的具体使用情况等），以帮助大家快速查找和完善存在问题的资源。 关于渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和CullingDistance等等。我们会在后续的渲染模块技术专题中进行更为详细的讲解，敬请期待。 二、UI模块UI模块同样也是几乎所有的游戏项目中必备的模块。一个性能优异的UI模块可以将游戏的用户体验再抬高一个档次。在目前国内的大量项目中，NGUI作为UI解决方案的占比仍然非常高。所以，UWA测评报告对NGUI的性能分析进行了极大的支持，我们会根据用户所使用的UI解决方案（UGUI或NGUI）的不同提供不同的性能分析和优化建议。 在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。UI模块制作的难点并不在于其表现上，因为UI界面的表现力是由设计师来决定的，但两套表现完全一致的UI系统，其底层的性能开销则可能千差万别。如何让UI系统使用尽可能小的CPU开销来达到设计师所设计的表现力，则足以考验每一位UI开发人员的制作功底。 目前，我们在UWA测评报告中将统计意义上CPU开销最为耗时的几个函数进行展示，并将其详细的CPU占用和堆内存分配进行统计，从而让研发团队对UI系统的性能开销进行直接地掌握，同时结合项目截图对UI模块何时存在较大开销进行直观地定位。 对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下： 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内； 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中； 控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。 另外，限于篇幅限制，我们在此仅介绍NGUI中重要性能问题，而对于UGUI系统以及UI系统自身的DrawCall问题，我们将在后续的UI模块技术专题中进行详细的讲解，敬请期待。 三、加载模块加载模块同样也是任何游戏项目中所不可缺少的组成成分。与之前两个模块不同的是，加载模块的性能开销比较集中，主要出现于场景切换处，且CPU占用峰值均较高。 这里，我们先来说说场景切换时，其性能开销的主要体现形式。对于目前的Unity版本而言，场景切换时的主要性能开销主要体现在两个方面，前一场景的场景卸载和下一场景的场景加载。下面，我们就具体来说说这两个方面的性能瓶颈： （1）场景卸载 对于Unity引擎而言，场景卸载一般是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据： Destroy 引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。 Resources.UnloadUnusedAssets 一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。 ** ** （2）场景加载 场景加载过程的性能开销又可细分成以下几个部分： 资源加载 资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别，所以我们在UWA测评报告中，特别将每种资源的具体使用情况进行展示，以帮助用户可以立刻查找到问题资源并及时进行改正。 Instantiate实例化 在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力（关于AssetBundle资源的加载，则是另一个很大的Story了，我们会在以后的AssetBundle加载技术专题中进行详细的讲解）。 另一方面，Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的。 以上是游戏项目中性能开销最大的三个模块，当然，游戏类型的不同、设计的不同，其他模块仍然会有较大的CPU占用。比如，ARPG游戏中的动画系统和物理系统，音乐休闲类游戏中的音频系统和粒子系统等。对此，我们会在后续的技术专题中进行详细的讲解，敬请期待。 四、代码效率逻辑代码在一个较为复杂的游戏项目中往往占据较大的性能开销。这种情况在MOBA、ARPG、MMORPG等游戏类型中非常常见。 在项目优化过程中，我们经常会想知道，到底是哪些函数占据了大量的CPU开销。同时，绝大多数的项目中其性能开销都遵循着“二八原则”，即80%的性能开销都集中在20%的函数上。所以，我们在UWA测评报告中将项目中代码占用的CPU开销进行统计，不仅可以提供代码的总体累积CPU占用，还可以更近一步看到函数内部的性能分配，从而帮助大家更快地定位问题函数。 当然，我们还希望可以为大家提供更多的代码性能信息，比如函数任何一帧中更为详细的性能分配、更为准确的截图信息等等。这些都是我们目前正在努力研发的功能，并在后续版本中提供给大家进行使用。","link":"/blog/2019/05/17/Unity优化/unity性能优化CPU篇/"},{"title":"unity性能优化内存篇","text":"资源内存占用在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上。因此，资源使用是否恰当直接决定了项目的内存占用情况。一般来说，一款游戏项目的资源主要可分为如下几种：纹理（Texture）、网格（Mesh）、动画片段（AnimationClip）、音频片段（AudioClip）、材质（Material）、着色器（Shader）、字体资源（Font）以及文本资源（TextAsset）等等。其中，纹理、网格、动画片段和音频片段则是最容易造成较大内存开销的资源。 纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源。一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB。因此，项目中纹理资源的使用是否得当会极大地影响项目的内存占用。 那么，纹理资源在使用时应该注意哪些地方呢？ （1） 纹理格式 纹理格式是研发团队最需要关注的纹理属性。因为它不仅影响着纹理的内存占用，同时还决定了纹理的加载效率。一般来说，我们建议开发团队尽可能根据硬件的种类选择硬件支持的纹理格式，比如Android平台的ETC、iOS平台的PVRTC、WindowsPC上的DXT等等。 因此，我们在UWA测评报告中，将纹理格式进行详细罗列，以便开发团队进行快速查找，一步定位。 在使用硬件支持的纹理格式时，你可能会遇到以下几个问题： 色阶问题 由于ETC、PVRTC等格式均为有损压缩，因此，当纹理色差范围跨度较大时，均不可避免地造成不同程度的“阶梯”状的色阶问题。因此，很多研发团队使用RGBA32/ARGB32格式来实现更好的效果。但是，这种做法将造成很大的内存占用。比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。所以，研发团队在使用RGBA32或ARGB32格式的纹理时，一定要慎重考虑，更为明智的选择是尽量减少纹理的色差范围，使其尽可能使用硬件支持的压缩格式进行储存。 ETC1 不支持透明通道问题 在Android平台上，对于使用OpenGL ES2.0的设备，其纹理格式仅能支持ETC1格式，该格式有个较为严重的问题，即不支持Alpha透明通道，使得透明贴图无法直接通过ETC1格式来进行储存。对此，我们建议研发团队将透明贴图尽可能分拆成两张，即一张RGB24位纹理记录原始纹理的颜色部分和一张Alpha8纹理记录原始纹理的透明通道部分。然后，将这两张贴图分别转化为ETC1格式的纹理，并通过特定的Shader来进行渲染，从而来达到支持透明贴图的效果。该种方法不仅可以极大程度上逼近RGBA透明贴图的渲染效果，同时还可以降低纹理的内存占用，是我们非常推荐的使用方式。 当然，目前已经有越来越多的设备支持了OpenGL ES3.0，这样Android平台上你可以进一步使用ETC2甚至ASTC，这些纹理格式均为支持透明通道且压缩比更为理想的纹理格式。如果你的游戏适合人群为中高端设备用户，那么不妨直接使用这两种格式来作为纹理的主要存储格式。 （2）纹理尺寸 一般来说，纹理尺寸越大，则内存占用越大。所以，尽可能降低纹理尺寸，如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理，因为后者的内存占用是前者的四倍。因此，我们在UWA测评报告中，将纹理的尺寸进行详细展示，以便开发团队进行快速检测。 ** ** （3） Mipmap功能 Mipmap旨在有效降低渲染带宽的压力，提升游戏的渲染效率。但是，开启Mipmap会将纹理内存提升1.33倍。对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的，但是在我们的测评项目中，经常会发现部分UI纹理也开启了Mipmap功能。这其实就没有必要的，绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用。因此，建议研发团队在UWA的测评报告中通过Mipmap一项进行排序，详细检测开启Mipmap功能的资源是否为UI资源。 （4） Read &amp; Write 一般情况下，纹理资源的“Read &amp; Write”功能在Unity引擎中是默认关闭的。但是，我们仍然在项目深度优化时发现了不少项目的纹理资源会开启该选项。对此，我们建议研发团队密切关注纹理资源中该选项的使用，因为开启该选项将会使纹理内存增大一倍。 网格资源在较为复杂的游戏中，往往占据较高的内存。对于网格资源来说，它在使用时应该注意哪些方面呢？ （1） Normal、Color和Tangent 在我们深度优化过的大量项目中，Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据。这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用。其中，Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。 更为麻烦的是，如果项目对Mesh进行Draw CallBatching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。正因如此，我们在UWA测评报告中为每个Mesh展示了其Normal、Color和Tangent属性的具体使用情况，研发团队可以直接针对每种属性进行排序查看，直接定位出现冗余数据的资源。 一般来说这些数据主要为Shader所用，来生成较为酷炫的效果。所以，建议研发团队针对项目中的网格资源进行详细检测，查看该模型的渲染Shader中是否需要这些数据进行渲染。 限于篇幅，我们今天只针对纹理和网格资源进行详细介绍，对于动画片段、音频片段等其他资源，建议您直接通过UWA测评报告中进行查看。同时，我们会在后续的资源专题中进行详细讲解，敬请期待。 引擎模块自身占用引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)… 一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处： WebStream 和SerializedFile 。其绝大部分的内存分配则是由AssetBundle加载资源所致。简单言之，当您使用newWWW或CreateFromMemory来加载AssetBundle时，Unity引擎会加载原始数据到内存中并对其进行解压，而WebStream的大小则是AssetBundle原始文件大小 解压后的数据大小 + DecompressionBuffer(0.5MB)。同时，由于Unity 5.3版本之前的AssetBundle文件为LZMA压缩，其压缩比类似于Zip（20%-25%）,所以对于一个1MB的原始AssetBundle文件，其加载后WebStream的大小则可能是5~6MB，因此，当项目中存在通过newWWW加载多个AssetBundle文件，且AssetBundle又无法及时释放时，WebStream的内存可能会很大，这是研发团队需要时刻关注的。 对于SerializedFile，则是当你使用LoadFromCacheOrDownload、CreateFromFile或newWWW本地AssetBundle文件时产生的序列化文件。 对于WebStream和SerializedFile，你需要关注以下两点： 是否存在AssetBundle没有被清理干净的情况。开发团队可以通过Unity Profiler直接查看其使用具体的使用情况，并确定TakeSample时AssetBundle的存在是否合理； 对于占用WebStream较大的AssetBundle文件（如UIAtlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间。 注意：关于AssetBundle的详细管理机制，建议查看我们之前的AssetBundle技术文章。 托管堆内存占用对于目前绝大多数基于Unity引擎开发的项目而言，其托管堆内存是由Mono分配和管理的。“托管”的本意是Mono可以自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收（GarbageCollection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。 但是这并不意味着研发团队可以在代码中肆无忌惮地开辟托管堆内存，因为目前Unity所使用的Mono版本存在一个很严重的问题，即：Mono的堆内存一旦分配，就不会返还给系统。这意味着Mono的堆内存是只升不降的。举个例子，项目运行时，在场景A中开辟了60MB的托管堆内存，而到下一场景B时，只需要使用20MB的托管堆内存，那么Mono中将会存在40MB空闲的堆内存，且不会返还给系统。这是我们非常不愿意看到的现象，因为对于游戏（特别是移动游戏）来说，内存的占用可谓是寸土寸金的，让Mono毫无必要地锁住大量的内存，是一件非常浪费的事情。所以，我们在UWA测评报告中，为研发团队统计了测试过程中累积的函数堆内存分配量，大家只需要通过查看堆内存分配Top10的函数，即可快速对其底层代码实现进行查看，定位是否有分配不必要堆内存的代码存在。 读到这里，你可能会产生这样的疑问： 我知道了哪些函数的堆内存分配大了，但是我该如何去进一步定位不必要的堆内存呢？ 这是我们经常遇到的问题，所以在我们的深度项目优化服务中，我们都会直接进驻到项目团队，现场查看项目代码并对问题代码进行定位。在经过了大量的深度检测后，我们发现用户不必要的堆内存分配主要来自于以下几个方面： 高频率地 New Class/Container/Array等。研发团队切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。做个简单的计算，假设你的项目中某一函数每一帧只分配100B的堆内存，帧率是1秒30帧，那么1秒钟游戏的堆内存分配则是3KB，1分钟的堆内存分配就是180KB，10分钟后就已经分配了1.8MB。如果你有10个这样的函数，那么10分钟后，堆内存的分配就是18MB，这期间，它可能会造成Mono的堆内存峰值升高，同时又可能引起了多次GC的调用。在我们的测评项目中，一个函数在10分钟内分配上百MB的情况比比皆是，有时候甚至会分配上GB的堆内存。 Log输出。我们发现在大量的项目中，仍然存在大量Log输出的情况。建议研发团队对自身Log的输出进行严格的控制，仅保留关键Log，以避免不必要的堆内存分配。对此，我们在UWA测评报告中对Log的输出进行了详细的检测，不仅提供详细的性能开销，同时占用Log输出的调用路径。这样，研发团队可直接通过报告定位和控制Log的输出。 UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。因此，其对应的优化方法是直接查看CPU篇中的UI模块讲解。 关于代码堆内存分配的注意点还有很多，比如String连接、部分引擎API（GetComponent）的使用等等，这些已经是老生常谈了，鉴于篇幅限制不在此处多作介绍，大家感兴趣可以Google自行搜索。后续也会有专门的代码效率专题讲解，敬请关注。 UWA测评的内存标准在大家使用过UWA之后，对于UWA推荐的内存标准值提出了很大的疑惑。在这里，我们也分享下UWA内存标准的制定规则。 （1）150MB的总体内存标准主要由以下两个因素得出： 经过了大量的项目优化后总结而得。其实，对于目前市场主流的Unity游戏来说，其内存占用主要集中在120~200MB。同时，顾及到iPhone4和512MB/768MB等低端Android机型，其应用的自身总体内存占用不可超过200MB（iPhone4的安全线应该在180MB左右），所以我们将ReservedTotal设定在150MB，这是Unity引擎的自身内存分配，以保证App在使用到的系统库后，其OS中的整体内存也在200MB以下。 某些渠道对Android游戏的PSS内存进行了严格的限制。 一般要求游戏的PSS内存在200MB以下。这是我们将ReservedTotal内存设定在150MB的另外一个重要原因。 （2）当总体内存设定为150MB后，我们进一步对其具体分配进行了设定。但需要说明的是，这里的内存分配其实并没有严格的公式来进行论证，仅是我们在大量的项目优化工作中提炼出的经验值。目前，项目较为合理的内存分配如下： 纹理资源： 50 MB 网格资源： 20 MB 动画片段： 15 MB 音频片段： 15 MB Mono堆内存： 40 MB 其他： 10 MB 需要指出的是，150MB中并没有涵盖较为复杂的字体文件（比如微软雅黑）以及Text Asset，这些需要根据游戏需求而定。 （3）目前的UWA内存标准是较为苛刻的，对于中高端设备而言，其内容允许量其实要比150MB要大得多。但我们坚持认为，在研发过程中，一个严苛的标准对于一个项目来说是一件好事。至少，它可以为大家提个醒，让大家时刻关注自己的问题。据我们了解，目前的三到五线城市，其低端手机的覆盖率还是相当高的。同时，对于中高端移动设备，我们仍在不断试验和研究中。我们希望在不久的将来可以做到针对各种不同档次的机型都给出一个更为合理的推荐值，从而让大家更为简单地对内存进行管理。 以上所说的是游戏项目中主要的内存分配情况，希望读到此处的你，可以更加了解Unity项目的内存开销和潜在问题，并对自己的项目进行更有针对性的检测。 除以上内容外，还有两个更为重要的地方需要研发团队关注： 内存泄露 和 资源冗余。我们将在下一篇内存优化文章中为您带来相关分享。同时，不同的项目遇到的问题不尽相同。","link":"/blog/2019/05/17/Unity优化/unity性能优化内存篇/"},{"title":"unity性能优化规范","text":"和java不同 能用for就不用foreach,因为foreach会使用迭代器并会产生额外几kb的gc。 和findViewById一样 GameObject.Find和Transform.Find尽量少调用 在Awake和Start只获取一次对象或组件。 与java不同 函数名首字母大写。 工具类声明为 static class 静态类。 开启monoDevelop的代码分析功能 并根据提示尽量优化代码。使用Profile工具进行性能分析测试。 有光照的情况下，烘焙场景和物体可以节约计算资源 你把物体模型放进了场景里之后， 引擎会计算光线，光线照到你的物体的表面形成反光和阴影。 如果不烘焙，游戏运行的时候，这些反光和阴影都是由显卡和CPU计算出来的。你烘焙之后，这些反光和阴影都记录到了你的模型里，变成了新的贴图了，运行的时候，显卡和CPU不需要进行对环境光效果的运算了，节约CPU资源。 字符串连接用StringBuilder 。 不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag(“human”))。因为访问物体的tag属性会在堆上额外的分配空间 。 对比通过方法GetComponent()获取Transform组件,通过MonoBehavor的transform属性去取，后者更快，但GetComponent又快于Find 。 善于使用OnBecameVisible()和OnBecameInVisible来控制物体的update()函数的执行以减少开销。 使用内建的数组，比如用Vector3.zero而不是new Vector(0, 0, 0)。 在c#里面List速度优于ArrayList 而且类型安全。 资源及代码都尽量继承和复用framework下的。 尝试使用IL2CPP。 设置贴图压缩格式以优化安装包大小及运行效率：iOS上尽量使用PVRTC，Android上使用ETC 或者选择自动压缩，但需要在显示质量和性能进行权衡，每家的GPU支持不同的压缩格式，但他们都兼容ETC格式，对于透明贴图，我们只能选择RGBA 16bit或者RGBA 32bit。如果不调用SetPixels或GetPixels函数，最好关闭Read/Writeenable开关，否则会复制一份贴图到内存中，内存占用会大两倍，这个属性的实质是决定了这个贴图的存放位置，是在内存上还是在显存上。（虽说在移动设备上显存和内存是共用的，但数据不直接互通）如果可读写，那么这个贴图既在显存上，又在内存上，而且还必须得是非压缩的格式（ARGB32，ARGB4444之类）。用getPixel(s)，setPixel(s)之类的方法，读取或设置的数据，都是内存上的数据，但其他属性不区分内存还是显存。Apply方法的作用是把这个贴图在内存上的传给显存。Apply方法的第二个参数，决定了这个这个贴图是否还可读写，换种说法就是内存上这部分数据在执行完这个方法之后还要不要。 代码能加namespace的尽量都加namespace。 在ProjectSetting-&gt;Quality中的，关闭垂直同步。可以考虑降低FPS，降低FPS的好处：1）省电，减少手机发热的情况；2）能都稳定游戏FPS，减少出现卡顿的情况。当我们设置了FPS后，再调整下Fixedtimestep这个参数，这个参数在ProjectSetting-&gt;Time中，目的是减少物理计算的次数，来提高游戏性能。可以考虑待机时，调整游戏的FPS为1（手动设置帧率可以用Application.targetFrameRate），节省电量。 尽量少使用Update LateUpdateFixedUpdate，这样也可以提升性能和节省电量。多使用事件（不是SendMessage，使用自己写的，或者C#中的事件委托）。 把大部分图片打成图集减少drawcall，可以用unity自带的工具打http://www.xuanyusong.com/archives/3304也可以用TexturePackerGUI。图集大小最好不要高于1024，否则游戏安装之后、低端机直接崩溃、原因是手机系统版本低于2.2、超过1000的图集无法读取、导致。2.2以上没有遇见这个情况。注意手机的RAM 与 ROM、小于 512M的手机、直接放弃机型适配。 RectMask2D性能好于Mask。 考虑使用Occlusion Culling遮挡剔除技术，减少绘制。 对象最好复用同一个材质，并且保证缩放一致，unity会自动进行动态批处理，减少drawcall。Lightmap对象由于多了光照烘焙材质，以及有阴影的对象，不会被批处理。对静止的物体勾选static，就会自动静态批处理，比动态批处理更节约资源。但无论是动态批处理还是静态批处理，都是空间换时间的操作，所以会更占内存，需要权衡利弊。 避免使用顶点过多的对象，减少计算量。 避免使用过于复杂的数学函数，且整形类型计算优于浮点型。 使用有规则的碰撞体，比如长方形，球形，胶囊形，效率高于网格碰撞体。 Image组件的RaycastTarget勾选以后会消耗一些效率，为了节省效率就不要勾选它了，不仅Image组件Text组件也有这样的问题。一般UI里也就是按钮才需要接收响应事件，那么大部分image和text是是不需要开RaycastTarget的。http://www.xuanyusong.com/archives/4006 按界面分离canvas，减少界面刷新，按静态和动态物体分离canvas，减少界面刷新。 若使用了AndroidJavaXXX类则需要使用using语句或者Dispose函数来确保资源会被释放回收","link":"/blog/2019/05/17/Unity优化/unity性能优化规范/"},{"title":"使用link-xml来控制strippinglevel减少dll库大小技巧、优化安装包大小","text":"无论从减少安装包大小还是迎合unity64位IL2CPP默认就会打开StrippingLevel功能，通过库剖离来减少DLL的空间大小。 那么问题是我们自定义库使用了一些type，例如xml，或者webclient c#封装的http请求等，如果被任性解剖出去，那么肯定是不允许的。 可以在Assets/下添加link.xml文件来手动排除不被剖离的类。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;linker&gt; &lt;assembly fullname=&quot;mscorlib&quot;&gt; &lt; fullname=&quot;System.Reflection&quot; preserve=&quot;all&quot;/&gt; &lt; fullname=&quot;System.Security.Cryptography&quot; preserve=&quot;all&quot;/&gt; &lt; fullname=&quot;System.Runtime.CompilerServices&quot;&gt;preserve=&quot;all&quot;/ &lt; fullname=&quot;System.Runtime.InteropServices&quot; preserve=&quot;all&quot;/&gt; &lt; fullname=&quot;System.Diagnostics&quot; preserve=&quot;all&quot;/&gt; &lt; fullname=&quot;System.Security&quot; preserve=&quot;all&quot;/&gt; &lt; fullname=&quot;System.Security.Permissions&quot; preserve=&quot;all&quot;/&gt; &lt;/assembly&gt; &lt;/linker&gt; 如上我们保持link.xml里面的格式这样既可assembly其实就是dll库名，我们要排除这个dll库里面的1：整个命名空间；2：某个命名空间里面的某个具体类 补充针对排除整个命名空间可以这样加： 12345&lt;assembly fullname=&quot;JsonDotNet&quot;&gt; &lt;namespace fullname=&quot;Newtonsoft.Json&quot; preserve=&quot;all&quot;/&gt; &lt;/assembly&gt; 关于查看dll库可以用默认的mono编辑器或者vs点进目录文件分类的dll就能看见了。 关于如何知道什么类或者命名空间你需要添加进去link.xml，只能你使用这个特殊命名空间才知道了。或者你通过xcode debug出错、eclipsedebug真机运行时出错来查看那些类空间报错添加进去即可。","link":"/blog/2019/05/17/Unity优化/使用link-xml来控制strippinglevel减少dll库大小技巧、优化安装包大小/"},{"title":"如何优化UGUI的ScrollRect","text":"介绍每个元素知道自己的序号，可以根据需要修改自己的内容、大小等信息。 此外支持了ScrollBar，支持横向、纵向及正反向。 在关闭Mask后可以看到，只有当需要的时候才动态实例化元素，使用完后回收。 最原始版本的代码是@ivomarel的InfinityScroll。我改到后来，基本和原始版没啥相同的了。 原代码使用了sizeDelta作为大小，但是这个在锚点不重合情况下是不成立的 支持了GridLayout 在启动时检查锚点和轴心，方便使用 修复了原代码在往前拖拽会卡顿的问题 优化代码，提升性能 支持反向滑动 支持ScrollBar (在无尽模式下不起作用;如果元素大小不一致会出现滚动条瑕疵) 此外，我修改了Easy Object Pool作为池子，循环利用元素。 警告:为了解决原始代码回拉卡顿的问题，我直接复制了一份UGUI中的ScrollRect代码，而没有继承。这是因为老的做法是在onDrag里停止并立即启动滚动，而我通过修改两个私有变量保证了滑动顺畅。所有我的代码都用==========LoopScrollRect==========这样的注释包起来，维护起来就像打patch了。 框架思路和UGUI自带的ScrollRect有所不同，我拆分出了LoopHorizontalScrollRect和LoopVerticalScrollRect两个类，分别代表水平滚动条和水平滚动条。下面我们以LoopVerticalScrollRect为例，水平版本类似。 1. 判定cell大小 LoopScrollRect要解决的核心问题是：如何计算每个元素的大小。这里我使用了Content Size Fitter配合LayoutElement来控制每个cell的长宽，因此对于GridLayout直接取高度，否则取PreferredHeight。需要注意的是，除了元素本身的大小之外，我们还要将padding考虑进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected override float GetSize(RectTransform item){ float size = contentSpacing; if (m_GridLayout != null) { size += m_GridLayout.cellSize.y; } else { size += LayoutUtility.GetPreferredHeight(item); } return size;} 这个其实也是最核心的一个地方：在能够准确计算格子大小的基础上，后续工作就好实现了。 2. 如何优雅的增删元素 对于每个ScrollRect，其实只需要考虑在头部和尾部是否需要增加或者删除元素。在这里以头部的各种情况为例进行解释，因为在正向滑动情况下，必须保证在修改元素之后整个ScrollRect内容显示一致不跳变；这些情况比尾部处理会麻烦一些。 NewItemAtStart函数实现了在头部增加一个(或一行，针对GridLayout)元素，并返回这些元素的高度；DeleteItemAtStart代表删除头部的一个元素。需要注意的是，在修改头部元素之后要及时修改content的anchoredPosition，这样才能保证整个内容区域不会因为多了或者少了一行而产生跳变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101protected float NewItemAtStart() { float size = 0; for (int i = 0; i &lt; contentConstraintCount; i++) { // Get Element from ObjectPool } if (!reverseDirection) { // Modify content.anchoredPosition } return size; } protected float DeleteItemAtStart() { float size = 0; for (int i = 0; i &lt; contentConstraintCount; i++) { // Return Element to ObjectPool } if (!reverseDirection) { // Modify content.anchoredPosition } return size; } 3. 何时需要增删元素 这里需要有两个概念viewBounds和contentBounds：前者是指ScrollRect本身的大小，一般也对应Mask；后者是指ScrollRect里所有cell组成的内容部分的大小。在这个基础上就简单了：如果contentBounds的最上面比viewBounds的最上面要低，那么尝试在顶部增加元素；如果contentBounds的最上面比viewBounds的最上面高很多，那么尝试删除元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485protected override bool UpdateItems(Bounds viewBounds, Bounds contentBounds) { bool changed = false; // cases for NewItemAtEnd/DeleteItemAtEnd if (viewBounds.max.y contentBounds.max.y - 1) { float size = NewItemAtStart(); if (size 0) { changed = true; } } else if (viewBounds.max.y &lt; contentBounds.max.y - threshold) { float size = DeleteItemAtStart(); if (size 0) { changed = true; } } return changed; } 4. 对象池交互 在新建cell和销毁cell的时候，使用对象池来避免内存碎片；同时这里使用了SendMessage来向每个cell发送必须的信息，保证数据的正确性。 private void SendMessageToNewObject(Transform go, int idx) { go.SendMessage(&quot;ScrollCellIndex&quot;, idx); } private void ReturnObjectAndSendMessage(Transform go) { go.SendMessage(&quot;ScrollCellReturn&quot;,SendMessageOptions.DontRequireReceiver); prefabPool.ReturnObjectToPool(go.gameObject); } private RectTransform InstantiateNextItem(int itemIdx) { RectTransform nextItem =prefabPool.GetObjectFromPool(prefabPoolName).GetComponent&lt;RectTransform(); nextItem.transform.SetParent(content, false); nextItem.gameObject.SetActive(true); SendMessageToNewObject(nextItem, itemIdx); return nextItem; } 5. 滚动条相关 这块我其实是估算的，根据当前的长度和当前元素个数/总个数按照比例缩放，这个在所有cell大小一致的情况下是没有问题的；但是如果大小不一致我就无法得到精确结果，所以会产生一定抖动。我暂时没有更好办法，因为得到的信息就是不够用。 6. 其他细节 我主要遇到了两个坑： 增加或者删除元素之后，有时候需要强行调用Canvas.ForceUpdateCanvases()刷新下。 注意不要在Build Canvas过程中再次修改元素，从而再次触发Build Canvas。 使用示例以竖直滚动条为例，介绍一下步骤。如果觉得麻烦的话，直接打开DemoScene复制粘贴就好。当然你也可以干掉EasyObjPool，自己控制生成和销毁。 1. 准备好Prefabs 每个物体上需要贴上Layout Element并指定preferred width/height。 贴上一个脚本接受void ScrollCellIndex (int idx) 消息，从而对每个位置的元素根据需要灵活修改。 ** ** 2. 在Hierarchy里右键，选择UI/Loop Horizontal Scroll Rect或UI/Loop Vertical ScrollRect即可。 使用Component菜单里的也是一样的。 Init in Start: 启动时自动调用Refill cells初始化 Prefab Pool: EasyObjPool物体 Prefab Pool Name: 第二步中对应的Cell Prefab名字 Total Count: 总共能有多少物体，范围0 ~ TotalCount-1 Threshold: 两端预留出来的缓存量(像素数) ReverseDirection: 如果是从下往上或者从右往左拖动，就打开这里 Clear Cells: 清除已有元素，恢复到未初始化状态 Refill Cells: 初始化并填充元素 如果是正向滑动，就设置pivot为1；否则设为0并打开ReverseDirection。我强烈建议你试试在播放状态下修改这些参数。 无尽模式 如果需要无限滚动模式，将totalCount设为负数即可。 其他参考 后来搜了下，发现网上也有人提到过UGUI ScrollRect优化（&lt;http://blog.csdn.net/subsystemp/article/details/46912479），不过他的策略是监听ScrollRect的value，然后禁用范围外的cell。最后作者也提到改成动态加载策略。这种基于value的做法我不太确认在在滚动前动态添加新元素的时候是否会出现问题。 文末，再次感谢钱康来的分享，如果您有任何独到的见解或者发现也欢迎联系我们，一起探讨。（QQ群465082844）。","link":"/blog/2019/05/17/Unity优化/如何优化UGUI的ScrollRect/"},{"title":"深入浅出聊Unity3D项目优化：从Draw-Calls到GC","text":"匹夫印象里遇到的童靴，提Unity3D项目优化则必提DrawCall，这自然没错，但也有很不好影响。因为这会给人一个错误的认识： ** 所谓的优化就是把DrawCall弄的比较低就对了。** 对优化有这种第一印象的人不在少数，drawcall的确是一个很重要的指标，但绝非全部。为了让各位和匹夫能达成尽可能多的共识，匹夫首先介绍一下本文可能会涉及到的几个概念，之后会提出优化所涉及的三大方面： drawcall是啥？其实就是对底层图形程序（比如：OpenGL ES)接口的调用，以在屏幕上画出东西。所以，是谁去调用这些接口呢？CPU。 fragment是啥？经常有人说vf啥的，vertex我们都知道是顶点，那fragment是啥呢？说它之前需要先说一下像素，像素各位应该都知道吧？像素是构成数码影像的基本单元呀。那fragment呢？是有可能成为像素的东西。啥叫有可能？就是最终会不会被画出来不一定，是潜在的像素。这会涉及到谁呢？GPU。 batching是啥？都知道批处理是干嘛的吧？没错，将批处理之前需要很多次调用（drawcall）的物体合并，之后只需要调用一次底层图形程序的接口就行。听上去这简直就是优化的终极方案啊！但是，理想是美好的，世界是残酷的，一些不足之后我们再细聊。 内存的分配：记住，除了Unity3D自己的内存损耗。我们可是还带着Mono呢啊，还有托管的那一套东西呢。更别说你一激动，又引入了自己的几个dll。这些都是内存开销上需要考虑到的。 好啦，文中的几个概念提前讲清楚了，其实各位也能看的出来匹夫接下来要说的匹夫关注的优化时需要注意的方面： CPU方面 GPU方面 内存方面 所以，这篇文章也会按照CPU—-GPU—-内存的顺序进行。 CPU的方面的优化： 上文中说了，drawcall影响的是CPU的效率，而且也是最知名的一个优化点。但是除了drawcall之外，还有哪些因素也会影响到CPU的效率呢？让我们一一列出暂时能想得到的： DrawCalls 物理组件（Physics） GC（什么？GC不是处理内存问题的嘛？匹夫你不要骗我啊！不过，匹夫也要提醒一句，GC是用来处理内存的，但是是谁使用GC去处理内存的呢？） 当然，还有代码质量 DrawCalls： 前面说过了，DrawCall是CPU调用底层图形接口。比如有上千个物体，每一个的渲染都需要去调用一次底层接口，而每一次的调用CPU都需要做很多工作，那么CPU必然不堪重负。但是对于GPU来说，图形处理的工作量是一样的。所以对DrawCall的优化，主要就是为了尽量解放CPU在调用图形接口上的开销。所以针对drawcall我们主要的思路就是每个物体尽量减少渲染次数，多个物体最好一起渲染。所以，按照这个思路就有了以下几个方案： 使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。具体下面会介绍。 通过把纹理打包成图集来尽量减少材质的使用。 尽量少的使用反光啦，阴影啦之类的，因为那会使物体多次渲染。 Draw Call Batching 首先我们要先理解为何2个没有使用相同材质的物体即使使用批处理，也无法实现Draw Call数量的下降和性能上的提升。 因为被“批处理”的2个物体的网格模型需要使用相同材质的目的，在于其纹理是相同的，这样才可以实现同时渲染的目的。因而保证材质相同，是为了保证被渲染的纹理相同。 因此，为了将2个纹理不同的材质合二为一，我们就需要进行上面列出的第二步，将纹理打包成图集。具体到合二为一这种情况，就是将2个纹理合成一个纹理。这样我们就可以只用一个材质来代替之前的2个材质了。 而Draw Call Batching本身，也还会细分为2种。 Static Batching 静态批处理 看名字，猜使用的情景。 静态？那就是不动的咯。还有呢？额，听上去状态也不会改变，没有“生命”，比如山山石石，楼房校舍啥的。那和什么比较类似呢？嗯，聪明的各位一定觉得和场景的属性很像吧！所以我们的场景似乎就可以采用这种方式来减少drawcall了。 那么写个定义：只要这些物体不移动，并且拥有相同的材质，静态批处理就允许引擎对任意大小的几何物体进行批处理操作来降低描绘调用。 那要如何使用静态批来减少DrawCall呢？你只需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可，如下图所示： 至于效果如何呢？ 举个例子：新建4个物体，分别是Cube，Sphere, Capsule, Cylinder,它们有不同的网格模型，但是也有相同的材质（Default-Diffuse）。 首先，我们不指定它们是static的。Draw Call的次数是4次，如图： 我们现在将它们4个物体都设为static，在来运行一下： 如图，Draw Call的次数变成了1，而Saved by batching的次数变成了3。 静态批处理的好处很多，其中之一就是与下面要说的动态批处理相比，约束要少很多。所以一般推荐的是draw call的静态批处理来减少drawcall的次数。那么接下来，我们就继续聊聊draw call的动态批处理。 Dynamic Batching 动态批处理 有阴就有阳，有静就有动，所以聊完了静态批处理，肯定跟着就要说说动态批处理了。首先要明确一点，Unity3D的drawcall动态批处理机制是引擎自动进行的，无需像静态批处理那样手动设置static。我们举一个动态实例化prefab的例子，如果动态物体共享相同的材质，则引擎会自动对drawcall优化，也就是使用批处理。首先，我们将一个cube做成prefab，然后再实例化500次，看看draw call的数量。 GameObject GameObjectInstantiateprefabGameObject draw call的数量： 可以看到draw call的数量为1，而 saved bybatching的数量是499。而这个过程中，我们除了实例化创建物体之外什么都没做。不错，unity3d引擎为我们自动处理了这种情况。 但是有很多童靴也遇到这种情况，就是我也是从prefab实例化创建的物体，为何我的draw call依然很高呢？这就是匹夫上文说的，drawcall的动态批处理存在着很多约束。下面匹夫就演示一下，针对cube这样一个简单的物体的创建，如果稍有不慎就会造成draw call飞涨的情况吧。 我们同样是创建500个物体，不同的是其中的100个物体，每个物体的大小都不同，也就是Scale不同。 GameObject GameObjectInstantiateprefabGameObject transformlocalScaleVector3 draw call的数量： 我们看到draw call的数量上升到了101次，而saved bybatching的数量也下降到了399。各位看官可以看到，仅仅是一个简单的cube的创建，如果scale不同，竟然也不会去做批处理优化。这仅仅是动态批处理机制的一种约束，那我们总结一下动态批处理的约束，各位也许也能从中找到为何动态批处理在自己的项目中不起作用的原因： 批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。 如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。 不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。 统一缩放的物体不会与非统一缩放的物体进行批处理。 使用缩放尺度(1,1,1) 和 (1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1) 和(1,3,1)的两个物体将可以进行批处理。 使用不同材质的实例化物体（instance）将会导致批处理失败。 拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。 多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。 预设体的实例会自动地使用相同的网格模型和材质。 所以，尽量使用静态的批处理。 物理组件 曾几何时，匹夫在做一个策略类游戏的时候需要在单元格上排兵布阵，而要侦测到哪个兵站在哪个格子匹夫选择使用了射线，由于士兵单位很多，而且为了精确每一帧都会执行检测，那时候CPU的负担叫一个惨不忍睹。后来匹夫果断放弃了这种做法，并且对物理组件产生了心理的阴影。 这里匹夫只提2点匹夫感觉比较重要的优化措施： 1.设置一个合适的Fixed Timestep。设置的位置如图： 那何谓“合适”呢？首先我们要搞明白FixedTimestep和物理组件的关系。物理组件，或者说游戏中模拟各种物理效果的组件，最重要的是什么呢？计算啊。对，需要通过计算才能将真实的物理效果展现在虚拟的游戏中。那么FixedTimestep这货就是和物理计算有关的啦。所以，若计算的频率太高，自然会影响到CPU的开销。同时，若计算频率达不到游戏设计时的要求，有会影响到功能的实现，所以如何抉择需要各位具体分析，选择一个合适的值。 2.就是不要使用网格碰撞器（meshcollider）：为啥？因为实在是太复杂了。网格碰撞器利用一个网格资源并在其上构建碰撞器。对于复杂网状模型上的碰撞检测，它要比应用原型碰撞器精确的多。标记为凸起的（Convex）的网格碰撞器才能够和其他网格碰撞器发生碰撞。各位上网搜一下mesh collider的图片，自然就会明白了。我们的手机游戏自然无需这种性价比不高的东西。 当然，从性能优化的角度考虑，物理组件能少用还是少用为好。 处理内存，却让CPU受伤的GC 在CPU的部分聊GC，感觉是不是怪怪的？其实小匹夫不这么觉得，虽然GC是用来处理内存的，但的确增加的是CPU的开销。因此它的确能达到释放内存的效果，但代价更加沉重，会加重CPU的负担，因此对于GC的优化目标就是尽量少的触发GC。 首先我们要明确所谓的GC是Mono运行时的机制，而非Unity3D游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。搞清楚这一点，你也就明白了GC不是用来处理引擎的assets（纹理啦，音效啦等等）的内存释放的，因为U3D引擎也有自己的内存堆而不是和Mono一起使用所谓的托管堆。 其次我们要搞清楚什么东西会被分配到托管堆上？不错咯，就是引用类型咯。比如类的实例，字符串，数组等等。而作为int，float，包括结构体struct其实都是值类型，它们会被分配在堆栈上而非堆上。所以我们关注的对象无外乎就是类实例，字符串，数组这些了。 那么GC什么时候会触发呢？两种情况： 首先当然是我们的堆的内存不足时，会自动调用GC。 其次呢，作为编程人员，我们自己也可以手动的调用GC。 所以为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity3D引擎的那些资源，所以GC的优化说白了也就是代码的优化。那么匹夫觉得有以下几点是需要注意的： 字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收。 尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24Bytes的垃圾。那么循环10次就是240Bytes。 不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag(“human”))。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。 使用“池”，以实现空间的重复利用。 最好不用LINQ的命令，因为它们会分配临时的空间，同样也是GC收集的目标。而且我很讨厌LINQ的一点就是它有可能在某些情况下无法很好的进行AOT编译。比如“OrderBy”会生成内部的泛型类“OrderedEnumerable”。这在AOT编译时是无法进行的，因为它只是在OrderBy的方法中才使用。所以如果你使用了OrderBy，那么在IOS平台上也许会报错。 代码？脚本？ 聊到代码这个话题，也许有人会觉得匹夫多此一举。因为代码质量因人而异，很难像上面提到的几点，有一个明确的评判标准。也是，公写公有理，婆写婆有理。但是匹夫这里要提到的所谓代码质量是基于一个前提的：Unity3D是用C++写的，而我们的代码是用C#作为脚本来写的，那么问题就来了~脚本和底层的交互开销是否需要考虑呢？也就是说，我们用Unity3D写游戏的“游戏脚本语言”，也就是C#是由mono运行时托管的。而功能是底层引擎的C++实现的，“游戏脚本”中的功能实现都离不开对底层代码的调用。那么这部分的开销，我们应该如何优化呢？ 1.以物体的Transform组件为例，我们应该只访问一次，之后就将它的引用保留，而非每次使用都去访问。这里有人做过一个小实验，就是对比通过方法GetComponent&lt;Transform()获取Transform组件,通过MonoBehavor的transform属性去取，以及保留引用之后再去访问所需要的时间： GetComponent = 619ms Monobehaviour = 60ms CachedMB = 8ms Manual Cache = 3ms 2.如上所述，最好不要频繁使用GetComponent，尤其是在循环中。 3.善于使用OnBecameVisible()和OnBecameVisible(),来控制物体的update()函数的执行以减少开销。 4.使用内建的数组，比如用Vector3.zero而不是new Vector(0, 0, 0); 5.对于方法的参数的优化：善于使用ref关键字。值类型的参数，是通过将实参的值 复制到形参，来实现按值传递到方法，也就是我们通常说的按值传递。复制嘛，总会让人感觉很笨重。比如Matrix4x4这样比较复杂的值类型，如果直接复制一份新的，反而不如将值类型的引用传递给方法作为参数。 好啦，CPU的部分匹夫觉得到此就介绍的差不多了。下面就简单聊聊其实匹夫并不是十分熟悉的部分，GPU的优化。 GPU的优化 GPU与CPU不同，所以侧重点自然也不一样。GPU的瓶颈主要存在在如下的方面： 填充率，可以简单的理解为图形处理单元每秒渲染的像素数量。 像素的复杂度，比如动态阴影，光照，复杂的shader等等 几何体的复杂度（顶点数量） 当然还有GPU的显存带宽 那么针对以上4点，其实仔细分析我们就可以发现，影响的GPU性能的无非就是2大方面，一方面是顶点数量过多，像素计算过于复杂。另一方面就是GPU的显存带宽。那么针锋相对的两方面举措也就十分明显了。 减 少顶点数量，简化计算复杂度。 压 缩图片，以适应显存带宽。 减少绘制的数目 那么第一个方面的优化也就是减少顶点数量，简化复杂度，具体的举措就总结如下了： 保持材质的数目尽可能少。这使得Unity更容易进行批处理。 使用纹理图集（一张大贴图里包含了很多子贴图）来代替一系列单独的小贴图。它们可以更快地被加载，具有很少的状态转换，而且批处理更友好。 如果使用了纹理图集和共享材质，使用Renderer.sharedMaterial 来代替Renderer.material 。 使用光照纹理(lightmap)而非实时灯光。 使用LOD，好处就是对那些离得远，看不清的物体的细节可以忽略。 遮挡剔除（Occlusion culling） 使用mobile版的shader。因为简单。 优化显存带宽 第二个方向呢？压缩图片，减小显存带宽的压力。 OpenGL ES 2.0使用ETC1格式压缩等等，在打包设置那里都有。 使用mipmap。 MipMap 这里匹夫要着重介绍一下MipMap到底是啥。因为有人说过MipMap会占用内存呀，但为何又会优化显存带宽呢？那就不得不从MipMap是什么开始聊起。一张图其实就能解决这个疑问。 _ _ 上面是一个mipmap 如何储存的例子，左边的主图伴有一系列逐层缩小的备份小图 是不是很一目了然呢？Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。因为存了主图和它的那些缩小的复制品，所以内存占用会比之前大。但是为何又优化了显存带宽呢？因为可以根据实际情况，选择适合的小图来渲染。所以，虽然会消耗一些内存，但是为了图片渲染的质量（比压缩要好），这种方式也是推荐的。 内存的优化 既然要聊Unity3D运行时候的内存优化，那我们自然首先要知道Unity3D游戏引擎是如何分配内存的。大概可以分成三大部分： Unity3D内部的内存 Mono的托管内存 若干我们自己引入的DLL或者第三方DLL所需要的内存。 第3类不是我们关注的重点，所以接下来我们会分别来看一下Unity3D内部内存和Mono托管内存，最后还将分析一个官网上Assetbundle的案例来说明内存的管理。 Unity3D内部内存 Unity3D的内部内存都会存放一些什么呢？各位想一想，除了用代码来驱动逻辑，一个游戏还需要什么呢？对，各种资源。所以简单总结一下Unity3D内部内存存放的东西吧： 资源：纹理、网格、音频等等 GameObject和各种组件。 引擎内部逻辑需要的内存：渲染器，物理系统，粒子系统等等 Mono托管内存 因为我们的游戏脚本是用C#写的，同时还要跨平台，所以带着一个Mono的托管环境显然必须的。那么Mono的托管内存自然就不得不放到内存的优化范畴中进行考虑。那么我们所说的Mono托管内存中存放的东西和Unity3D内部内存中存放的东西究竟有何不同呢？其实Mono的内存分配就是很传统的运行时内存的分配了： 值类型：int型啦，float型啦，结构体struct啦，bool啦之类的。它们都存放在堆栈上（注意额，不是堆所以不涉及GC）。 引用类型：其实可以狭义的理解为各种类的实例。比如游戏脚本中对游戏引擎各种控件的封装。其实很好理解，C#中肯定要有对应的类去对应游戏引擎中的控件。那么这部分就是C#中的封装。由于是在堆上分配，所以会涉及到GC。 而Mono托管堆中的那些封装的对象，除了在在Mono托管堆上分配封装类实例化之后所需要的内存之外，还会牵扯到其背后对应的游戏引擎内部控件在Unity3D内部内存上的分配。 举一个例子： 一个在.cs脚本中声明的WWW类型的对象www，Mono会在Mono托管堆上为www分配它所需要的内存。同时，这个实例对象背后的所代表的引擎资源所需要的内存也需要被分配。 一个WWW实例背后的资源： 压缩的文件 解压缩所需的缓存 解压缩之后的文件 那么下面就举一个AssetBundle的例子： Assetbundle的内存处理 以下载Assetbundle为例子，聊一下内存的分配。匹夫从官网的手册上找到了一个使用Assetbundle的情景如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263IEnumerator DownloadAndCache // Wait for the Caching system to be ready whileCachingready yield return // Load the AssetBundle file from Cache if it exists with the same versionor download and store it in the cache usingLoadFromCacheOrDownloadBundleURLversion yield return//WWW是第1部分 error throwExceptiondownload errorerror AssetBundle bundleassetBundle//AssetBundle是第2部分 AssetName InstantiatebundlemainAsset//实例化是第3部分 InstantiatebundleAssetName // Unload the AssetBundles compressed contents to conserve memory bundleUnloadfalse // memory is freed from the web stream (www.Dispose() gets calledimplicitly) 内存分配的三个部分匹夫已经在代码中标识了出来： _ Web Stream_ ：包括了压缩的文件，解压所需的缓存，以及解压后的文件。 _ AssetBundle_ ：Web Stream中的文件的映射，或者说引用。 ** 实例化之后的对象 ：**就是引擎的各种资源文件了，会在内存中创建出来。 那就分别解析一下： LoadFromCacheOrDownloadBundleURLversion 将压缩的文件读入内存中 创建解压所需的缓存 将文件解压，解压后的文件进入内存 关闭掉为解压创建的缓存 AssetBundle bundleassetBundle AssetBundle此时相当于一个桥梁，从Web Stream解压后的文件到最后实例化创建的对象之间的桥梁。 所以AssetBundle实质上是Web Stream解压后的文件中各个对象的映射。而非真实的对象。 实际的资源还存在Web Stream中，所以此时要保留Web Stream。 InstantiatebundlemainAsset 通过AssetBundle获取资源，实例化对象 最后各位可能看到了官网中的这个例子使用了： usingLoadFromCacheOrDownloadBundleURLversion 这种using的用法。这种用法其实就是为了在使用完WebStream之后，将内存释放掉的。因为WWW也继承了idispose的接口，所以可以使用using的这种用法。其实相当于最后执行了： //删除Web Stream Dispose OK,Web Stream被删除掉了。那还有谁呢？对Assetbundle。那么使用 //删除AssetBundle bundleUnloadfalse","link":"/blog/2019/05/17/Unity优化/深入浅出聊Unity3D项目优化：从Draw-Calls到GC/"},{"title":"详解Unity-Profiler内存分析问题","text":"在使用Unity开发游戏的过程中，借助Profiler来分析内存使用状况是至关重要的。但许多开发者可能还对Profiler中各项数据表示的含义不甚明确，今天我们Unity官方的技术工程师柳振东，将针对Profiler内存分析相关的问题及解答，与大家进行分享。 要想完全发挥Profiler内存分析的威力，首先要做的就是了解Profiler展示的数据所表达的含义，以及到底哪些模块所使用的内存才会被统计到Unity的Profiler中。Profiler涉及到的知识点还有很多，今天先从中挑选一些大家常有的疑问来作解答。 在Unity的Profiler中看到的总内存使用和我使用其它工具看到的系统内存占用不太一样，这是为什么呢？ Profiler中看到的内存是通过Unity自身引擎的内存分配，凡是引擎分配和释放的内存，引擎均有记录，所以我们可以给出确切的引擎内存占用信息。但是，仍有其他内存我们是无法获知的。 比如，如果引擎使用了第三方库，那么库分配的内存我们是无法进行统计的。另外，在移动设备上大家看到的内存，其实都要比Profiler大很多，这是因为不管是通过Xcode的Instrument还是通过Android的USS，其记录的真实物理内存都包括两部分，一个是真实使用（Used）的物理内存，另一个则是缓存的（Cached）的物理内存。 这是由系统所决定的，Android和iOS系统在资源不使用时均不会立即将其进行回收，而是将其放在缓存的物理内存中，以便下次再用时，可以快速地加载。当系统发现App的内存不够用时，才会在底层调用一个MemoryKiller线程来轮询缓存物理内存，进而为App清理内存。 而UnityProfiler记录的则是目前真实使用的物理内存，即上述所说的第一部分。因此，当游戏运行时间越长，Profiler分配内存和通过其他软件获得的系统内存差距会越大。 因此，只要所使用的第三方库不存在内存泄露问题，我们一般都建议只需要查看Profiler即可，只要Profiler中的内存可以保证正常升高和回落，那么引擎这边分配的内存就是没有问题的。 我们做项目的时候发现有时Profiler中System.ExecutableAndDlls这项占用很多，有什么解决办法吗？ “System.ExecutableAndDlls”该项显示的是执行文件和所调用的库（物理、渲染、IO等系统库）的总和。请不用担心该选项的数值，因为很多Application均在共用这些库，并且它对于真实游戏的内存压力非常小，而且也不会导致系统因为该内存来Kill掉游戏。 为什么在Profiler中的Simple模式下，Used Total的数值不等于其右边各项Unity, Mono, GfxDriver,FMOD与Profiler总和呢？ 其实在Unity中，Used Total的计算公式为Used Total = Unity + Mono + GfxDriver + Profiler +additionalUsedMemory。公式中的additionalUsedMemory项在Profiler中并没有显示，因为这一项一般情况下都为0，只在某些特殊发布平台下才会有数值（一般Android，PC和IOS都为0）。因此一般情况下UsedTotal的值就是除FMOD之外各项的总和了。当然，这个规则对于Reserved Total是同样适用的。 我们项目的资源主要使用AssetBundle动态加载资源，发现Profiler中Detailed模式下PersistentManager.Remapper一项占用时多时少，这一项主要是做什么的呢？ Remapper主要提供文件的持久化存储，包括各种序列化的Asset，项目的设置文件等，维护文件系统的中的文件与内存中数据的对应关系。 那么如果项目大量使用AssetBundle的话，在对AssetBundle进行Unload之前都会需要占用Remapper的内存的。而Remapper本身的实现使用内存池，其数值只会增大，那么为了使Remapper占用的内存保持在一个稳定的数值上，我们需要每次在加载一定数量的AssetBundle之后进行Unload操作，而不要一次性把所有AssetBundle都加载后才调用Unload。（这样的操作对维持整个MonoHeap的大小也是至关重要的，因为Mono Heap本身也是只增大不减小的。） 我们在Editor中调试项目的时候发现纹理的内存大小是其本身大小的两倍，是因为Unity把内存和显存的大小都计算进去了吗？ 其实并不是这个原因，因为Editor本身会保有纹理的一份内存，在Editor下进行Profiler会把Editor本身所使用的纹理大小也计算进去，因此会有内存变为两倍的情况。我们官方并不建议在Editor下对项目进行性能调试，而是务必要在真机上跑编译好的项目，然后连接Profiler进行调试，只有这样才能得到真正精确的测试数据。 总结 ：一般情况下只需UnityProfiler在手，就能窥测到游戏中各项内存使用状况，当然前提是需要对Profiler各项数据所表达的含义了然于心。并且尽量使用真机调试结合Profiler，这样才能了解到游戏运行的真实内存占用数据。","link":"/blog/2019/05/17/Unity优化/详解Unity-Profiler内存分析问题/"},{"title":"调整画质（贴图）质量","text":"当我们在Unity中，使用图片进行2D显示时，会发现显示出来的画面有明显的模糊或者锯齿，但是美术给的原图却十分清晰。 要改善这一状况实际上很简单。 造成这样的原因，是Unity在导入图片（或者纹理）时会自动进行压缩，以便减少运行时游戏的内存占用率，提供性能。 注意： 下面实例使用的Unity版本为4.3.4。版本不同的话可能某些显示不完全相同，但关键点是一样的。 我们以下列背景图为例（大小为2048*640）： 当我们把它作为背景显示时，在Game界面会看到下面的效果： 可以发现，上面的画质不怎么尽如人意，例如左上角的帆船和右上角的皮球，有明显的模糊和锯齿。 观察该图片对应的Inspector面板（注意这里的纹理类型是Sprite），如下所示： 其中对画质有影响的部分，已经用红框圈出。根据官网文档的解释，其含义分别如下： Filter Mode 当该纹理由于3D变换进行拉伸时，它将如何被过滤插值。共有三种选择： Point单点插值，纹理将变得块状化（blocky up close）； Bilinear双线性插值，纹理将变得模糊（blurry up clos）； Trilinear三线性插值，类似Bilinear，但是纹理还会在不同的mip水平之间（between the different miplevels）进行模糊； Max Size导入的纹理的最大尺寸。因为美术人员往往喜欢使用较大的纹理进行创作，所以可以使用这个选项来选择我们游戏中适合的尺寸。 Format该纹理使用的内部表现格式。这是在大小和质量之间的权衡。共有三种格式： Compressed压缩的RGB纹理。这是漫反射贴图最长江的格式。每个像素占4bits（一张256*256大小的纹理将占用32KB大小的内存）； 16 bit低质量的真彩（truecolor）显示。每个像素占16bits； Truecolor真彩。这是最高的质量。一张256*256大小的贴图占用256KB（是Compressed的8倍，即每个像素占32bits）。 我们可以从Inspector面板的最下方查看当前纹理的大小、格式和内存占用率。如下所示，当前纹理大小为1024*320，将占用160KB内存。 如果我们把FilterMode改为Point，可以看到画面明显变得锐化了。仔细观察图像中每个物体的边缘，由原来的模糊变为块状化了。但画质依然不好，可以看出有明显的锯齿。 我们将Filter Mode重新置回Bilinear。前面提到原图的大小为2048*640，而默认支持的MaxSize是1024，这意味着Unity自动压缩了图片。我们把MaxSize改为2048，并点击Apply后，可以看到画质得到了明显改善，锯齿和模糊都有了变化： 而此时的内存占用也提高到了0.6MB，比之前大了很多： 最后，我们尝试把Format调整为Truecolor。得到效果如下： 可以看出来，画质变化不大。但是内存占用却又提高了很多（3.8MB）： 至此，我们可以认为适合该纹理的设置为Filter Mode为Bilinear，Max Size为2048，Format为Compressed。 上述得到的结果是适合例子中的图片。在实际应用中，不同的图片要得到最好的效果设置可能不一样。下面是几点提示： 当Max Size大于图片的实际大小时，仍会使用原图片的大小，所以如果想都使用原图大小，可以直接都设置为4096。 如果游戏中有大量较大的图片的是Truecolor格式，那么会非常影响内存占用率。所以，当选择Compressed和Truecolor效果基本相同时，尽量选择Compressed。 我们可以为不同的平台设置不同的MaxSize和Format。例如，在Android平台上，由于性能不如IOS，可以选择较低的画质，而在IOS平台上可以设置为最高画质。","link":"/blog/2019/05/17/Unity优化/调整画质（贴图）质量/"},{"title":"2D-Toolkit","text":"2D Toolkit插件在2D中的地位，犹如UI中NGUI对UnityGUI一样：虽然官方原生的2D还不错，但这是最近1年新版本才有的功能，2年前Unity 2D的王道还是得用插件的，故《2DToolkit》就成了目前商业不错的选择。 在上周刚开始看的时候，就给自己提了3个问题 (1周后，自己给自己尝试做了回答)： 2D Toolkit是类似NGUI的东西吗？ 答：是的，类似NGUI；2D toolkit是第三方插件，广泛用于2D的游戏开发；其还包括了UI，可不用NGUI就能进行不错的UI开发。 对比Unity Native 2D，2D Toolkit是否优势已经丧失；或者是类似UGUI和NGUI关系？ 答：这个目前不得知。 粗浅的看，Unity Native 2D比较简单，开发起来便捷，毕竟和Unity无缝集成的，且原生，另外还省钱；但是2DToolkit都演变到2.5.2版本了，商用应该比较成熟，如其tk2dCamera简直无敌了–能自适应各种屏幕、大大节约了编码。 2D Toolkit能够和Unity Native 2D同存否？ 答：目前不知道。应该可以吧，2D toolkit已经于2015.5.24 发布2.5.2版本，声明支持Unity 5了。 2D ToolKit简历 2D ToolKit是第三方2D插件，能处理图集打包(Atlas Package)、精灵渲染(Sprite)、2D动画(SpriteAnimator)、2D UI，目前中文资料少得可怜。 2DToolkit简称为TK2D，其功能据说是2D下最强大的，assetstore的下载点评竟然超过1200个，这个数据非常惊人，要知道售价价格要75美金呢。其插件提供了C#代码，源码之内，了无秘密。 TK2D的厂家是Unikron SoftwareLtd，官方网站为http://unikronsoftware.com TK2D在assetstore的”编辑器扩充/2D与图片管理”分类下，排名第一。 我摘录了部分官方官网assetStore点评： low draw calls pixel perfect camera：Unity 4.6 pro sprite package get a response with 24 hours manages multiple resolutions of sprite images (1x, 2x, 4x) Very nice package greatly sped up my animating process. really streamlined my workflow. organise all your sprites how you like in collections. It’s fast at updating and rendering too.– opitimization The best support、comunity other：spline、NGUI 其点评大多集中在以下几个方便 降低了DC 正版的售后服务好 图集打包很爽 2D下效率高 正文开始–本文就官方教程《Whack aMole》进行小结： 注：因为官方问答截图、文字描写清楚，我这里为节约大家时间，不会写的很细，请先预览一下官方教程。 官方提供的Whack a Mole材质下载地址 步骤1：了解官方文档对TK2D做的系统概括： Tk2D在编辑期间生成脚本–Assets目录 Tk2D运行脚本生成对象–场景 上面这张图包含了TK2D的7个知识点 (术语) 的6个（除了Tilemaps外） Sprite Collections: 精灵(2D下的图片)集合，用于组织图片，一般同z轴值的放在一起，效率高。 Sprites：精灵，任何需要在Scene显示的均需要精灵组件，目前包含4种Sprite Static Sprite Batcher：静态化精灵–不参与碰撞的，可明显减少DC Sprite Animations：动画精灵 Fonts：字体 Text Meshes:显示文本 Tilemaps 步骤2：tk2d camera 自动布局的摄像机 删除新建Unity 2D工程的Main Camera，添加tk2dCamera，并设置tag为“MainCamera”。 修改tk2dCamera参数如下： Native Resolution ：1024*768 Projection：Orthographic Type：Pixels Per Meter Pixels Per Meter：1 Origin：Bottom Left pixel per meter – so 100×100 world units = 100×100 pixels from the bottom left tk2dCamera实际上是对Unity的Camera进行了扩展，这里有详细的对比说明和tip技巧。 步骤3：精灵集合(Sprite Collections)、精灵(Sprite )、静态精灵批处理(Static Sprite Batcher)要使用图片，则需要首先添加Sprite Collections，它有3个作用： 1 把图片组织管理起来–如果你有上百个图片就会发现它的价值。 2 同z轴的组织起来，方便Unity引擎优化降低DC 3 自动进行图集打包–减少图片占用空间 为什么要用Sprite Collection？ 我认为比Unity Native2D的默认能生成精灵而言，多了2个步骤。 要添加精灵，需要先Check out–如我这里使用Perforce源码管理。 添加精灵很简单，选择、拖放即可： 针对当前Sprite Collection，进行Settings，然后一定要记得Commit： 注意：这里的Size和Pixels Per Meter，需要和上面的tk2DCamera保障一致。Settings最下面有Platforms的设置，这个我没有看明白： 网上搜了一段代码，好像是为了适应不同屏幕的全局设置： 点击Commit后，就生成1了文件夹，包含3个文件：.prefab 、.png、*.mat。 使用Sprite就简单多了，添加Tk2D Sprite对象或者添加TK2D Sprite组件，选择Collection和Sprite即可：如果有n个Sprite，需要组织管理起来，默认会想到空的对象(EGO), 如果不参与碰撞等动态监测，可使用Static Sprite Batcher。选择需要静态化的Sprite，拖放为Batcher的子物体，在Inspator视图点击Commit，即可完成处理。 有2点 神奇 之处： 1 原来n个Sprite变为1个了，即仅仅是Static Sprite Batcher可见，其子物体消失了(点击Edit即可编辑) 2 明显的减少了DC。 步骤4： 代码实现 Clipped Sprite Clipped Sprite是Sprite的一种，可动态实现隐藏、可见。 通过动态设置Clipped Sprite的ClipRect的y值（y值范围0.0~1.0f之间）同时调整其localPostion的y轴，可模拟图片的隐藏、显示效果。 另外，这个思想也挺有趣的，使用n个returnnull代替waitforSecond. 123456789101112131415161718192021222324252627282930313233private IEnumerator WaitForHit() { float time = 0.0f; while (!whacked &amp;&amp; time &lt; timeLimit) { time += Time.deltaTime; yield return null; } } 步骤5：精灵动画（Sprite Animation） Sprite Animation也是基于Sprite Collection的。 显示动画，需要用Sprite With Animator组件，下面这张图一览无余： [本文的整理到这里就结束了，完整的请参阅官方教程–《](http://www.xifarm.com/wp-content/uploads/2015/05/image52.png)Whack aMole》 注，本文使用的开发环境： Unity 4.6.3 2D toolkit 2.4.0 转载请注明转自《 C#程序员整理的Unity 3D笔记（二十）：2D Toolkit之官方教程《Whack aMole》》","link":"/blog/2019/05/17/Unity插件/2D-Toolkit/"},{"title":"DoTween对UI进行DoFade操作存在问题及解决办法","text":"Unity版本：5.2, 5.4 当使用this.GetComponent&lt;Image().material.DOFade(0,2).SetEase(Ease.InBounce);来对UGUI的Image进行褪色操作的时候本质是对UI的Graphic对象（Text，Image等都为Graphic的子类）的material进行操作,下例是对Text组件进行褪色操作：Transform.GetComponent().material.DoFade(0,1)。虽然脚本只挂在一个Text组件的物体上，但1秒之后发现，整个UI界面全部变为透明。 （我也很纳闷，cube01.GetComponent&lt;Renderer ().material.color =Color.black;这样的代码照理说是这样执行的（&lt;http://www.jianshu.com/p/ababf547d992）： Material lastMat = cube01.GetComponent&lt;Renderer ().material Material m = Instantiate(lastMat) as Material cube01.GetComponent&lt;Renderer ().material = m m.color = Color.black 应该是最自己持有的material进行操做。。。 ） 经测试发现，所有使用缺省material的组件都是使用的默认的material，而这个material只存在一份，所有UI组件使用的默认material都只是该material的引用，在DoTween对其进行褪色操作之后，该material的alpha值保持为0不变，且游戏重新开始也不会将其alpha值重置为1。 解决办法: 导入DoTween后请确保Setup DoTween， Tools/DoTween Utility Panel/SetupDoTween…。导入后就可以使用Image.DoFade了。 使用Unity自带的Graphic.CrossFadeAlpha(float alpha, float duration, boolignoreTimeScale)函数来操作 自己扩展DoTween的方法，下面是我扩展的一个例子,可以参考DoTwen官网的Creating custom pluginsexample 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/ DoFadeTest.cs / Project: GUITest / Created by zhiheng.shao / Copyright 2016年 zhiheng.shao. All rights reserved. / Description using UnityEngine; using System.Collections; using DG.Tweening; using UnityEngine.UI; using DG.Tweening.RickExtension; public class DoFadeTest : MonoBehaviour { // Use this for initialization Start() { .GetComponent&lt;Image().DOFade(, ).SetEase(Ease.InBounce); } } namespace DG.Tweening.RickExtension { public static class DOTweenExteion { public static Tweener DOFade( Image image, float endValue, floatduration) { Debug.Log(&quot;CustomDoFade&quot;); return DOTween.To(image.AlphaGetter, image.AlphaSetter,endValue, duration); } private static float AlphaGetter( Image image) { return image.color.a; } private static AlphaSetter( Image image, float alpha) { Color oldColor = image.color; oldColor.a = alpha; image.color = oldColor; } } } 附：DoTween官网","link":"/blog/2019/05/17/Unity插件/DoTween对UI进行DoFade操作存在问题及解决办法/"},{"title":"FX-Maker","text":"插件介绍 FXMaker是一款制作特效的工具，它专为移动操作系统做了优化。包括300种Prefab特效，300种纹理结构、100种网格、100种曲线效果。支持英文和韩文，由开发商IGSoft提供。是UNT3D中一款强大的粒子特效制作工具。 概述 FX Maker包含300个特效Prefabs。 已经为移动设备进行了优化。FX Maker是用来产生特效的工具（创建、查看、分析、测试）。 支持BuildSprite功能，可以把数百个三角形转化为仅仅2个三角形。 支持Mesh、Legacy和Shuriken粒子系统。 粒子大小调节（Transform.Scale） 调整速度（Mesh, Legacy, Shuriken） 适用于Unity 4.3.4或更高版本（支持Unity5）。 包含的资源：300个特效，300个纹理，100个Mesh，100个曲线动画。 FX Maker是Unity3d一款非常流行的效果制作插件。不但有超过300种效果预制体， 还可以自己制作效果。包含Mesh Effect和Particle Effect。 优点：资源库大，可以将消耗资源非常多的粒子效果转换为帧动画效果。当然也可以直接用不转帧动画的效果，这种效果是画面最好的，但是对显卡开销大。帧动画显卡开销小，占内存大，适合移动平台。FxMaker还能自动保存。 使用步骤: 一:导入包 http://jingyan.baidu.com/article/cb5d6105fda595005d2fe068.html 二:打开主场景sceneFXMaker 三:运行 运行界面如下，注意不要选全屏运行，要在运行时至少同时有Game界面和Inspector界面。 当前运行的效果对应 _CurrentObject下面的物体。既可以对下图左侧的UI界面操作，亦可以对Hierarchy下面的物体进行直接操作。 EffectMesh 网格动画，主要是平面的网格动画，Mesh_Ring和Mesh_Virtical有特殊形状的形状片的动画。 EffectParticle 粒子效果，其中最后的Shuriken里包含的是新的Shuriken粒子系统，其他全是旧的粒子系统。 EffectSample 效果样例展示 Resources 包含一些资源，其中最重要的是Animation的曲线效果 和 Mesh下的网格 四:做简单的帧动画效果 1.选第一个Project文件夹，新建一个空效果 2.从已有的效果拷贝物体过来 已有效果，对着FX Maker UI里的物体点击右键，Copy 3.运行看看效果 4.做成帧动画(精灵动画) 先点击Sprite 在出现下图左侧的Build Sprite界面时，用鼠标滚轮调整视口，如右侧红框，使之刚好涵盖效果区域。 接着可以直接点“Build Sprite”按钮 之后就生成了新的效果,名字是 原名+_1 之类的,就在原效果旁边。 对着新效果点右键，Export。 之后就生成了一般的Unity Package。 包括了所有这个效果需要用到的资源。 五:使用导出的效果 直接导入使用即可。效果路径和原工程下的路径完全一样。 六 加入其他东西Build Sprite 并不一定要FxMaker的效果才可以拿来Build Sprite。任何东西，只要相机看得见就可以放进去BuildSprite。并且可以和FxMaker的混合Build。 将东西加到效果下，这里是将Unity包里的Constructor放到效果 NewEffect1里。 正常Build Sprite Build好后把新效果里的NcBillboard去掉，或者NcBillboard里的Front Axis设置为 Axis_Back。不然方向会颠倒。 由于使用的是Particle下的Addictive Shader,所以是与背景混合的半透明效果。 所以只适合拿来做效果。 至于真实物体的3D转2D,有兴趣的朋友可以自己去研究。 帧数起码要在FPS20以上，否则卡顿感太明显。 帧动画虽然不消耗显卡，但是贴图占内存还是比较大的。所以用完一定要释放内存。","link":"/blog/2019/05/17/Unity插件/FX-Maker/"},{"title":"FingerGestures","text":"FingerGestures是一款强大的手势识别插件，支持鼠标和触控。跨平台，最新的3.0版本支持自定义手势识别。 其中CustomGestures的识别还是挺准的。测试画个一笔五角星，能被容易的识别。 直接解压包，里面还有samples和对playerMaker拓展 2个子包。 二.导入Sample包在搜索栏里输入 t:scene, 然后全选场景并拖入Build Setting里的Scenes in Build 把’Sample Browser’场景调整到第一个场景 也可在player setting里把屏幕设置为600x400 [三.基本识别GestureRecognizers(检测用户输入并发送事件)](http://photo.blog.sina.com.cn/showpic.html#blogid=471132920101hlwt&amp;url=http://s14.sinaimg.cn/orignal/47113292gd94359d9fddd) 场景里必须只有一个FingerGestures组件示例。它相当于Manager。 (1)直接新建GameObject起名Manager，并加FingerGestures脚本 (2)直接新建GameObject起名Gestures，并加TapRecognizer脚本 直接新建TapTutorial.cs 并放到Gestures上 Gestures里TapRecognizer面板下，点”Copy Event To Clipboard”把对应代码拷贝到粘贴板上，并在TapTutorial脚本里粘贴代码。 当recognizer检测对应输入到后， 会在obj上发对应的SendMessage消息。但是SendMessage开销大，可以自己实现开销更小的delegate-based events. (5)打输出debug信息的代码 123456789101112131415161718192021using UnityEngine; using System.Collections; publicclass TapTutorial : MonoBehaviour OnTap(TapGesture gesture) Debug.Log( &quot;Tap gesture detected at &quot; + gesture.Position + &quot;. It was sent by &quot; + gesture.Recognizer.name ); 识别单击物体 (1)创建球，确保有collider或者trigger,位置(0,1,0),缩放(4,4,4) (2)Gesture物体上加 ScreenRaycaster 当Ray Thickness为0时 可以是collider或者trigger， 当Ray Thickness不为0时 必须是collider， 可以模拟厚手指的操作。 (2) 脚本变为 12345678910111213141516171819202122232425using UnityEngine; using System.Collections; public class TapTutorial : MonoBehaviour OnTap( TapGesture gesture ) ( gesture.Selection ) Debug.Log( &quot;Tapped object: &quot; + gesture.Selection.name ); Debug.Log( &quot;No object was tapped at &quot; + gesture.Position ); 之后就能检测到点击物体了，并且被点击的圆球同样的收到同名事件 识别2手指Tap3下 设置 Required Finger Count为2 设置 Required Taps为3 如果是电脑运行，用鼠标左右键同时按模拟 四.FingerEventDetector 检测单手指的按下 松开 经过 移动 静止，与GesturesRecognizers类似，发消息，用ScreenRaycaster与物体互动。 FingerEventDetector是抽象类，各种finger event detectors继承自它。 也可以提供finger index跟踪某指定手指。 (1)新场景，加FingerGestures管理 (2)新物体起名FingerEvent，并加FingerDownDetector (3)新建脚本FingerEventTutor.cs, 并从FingerDownDetector拷贝粘贴脚本 123456789101112131415161718using UnityEngine; using System.Collections; public class FingerEventTutor : MonoBehaviour OnFingerDown(FingerDownEvent e) Debug.Log( e.Finger + &quot; Down at &quot; + e.Position + &quot; on object:&quot; + e.Selection); 点击运行，即可检测任何手指按下的事件。 每个手指事件都要添加对应的detector 1234567891011121314151617181920212223242526272829303132333435using UnityEngine; using System.Collections; public class FingerEventTutor : MonoBehaviour OnFingerDown(FingerDownEvent e) Debug.Log( e.Finger + &quot; Down at &quot; + e.Position + &quot; on object:&quot; + e.Selection); OnFingerUp( FingerUpEvent e ) // time the finger has been held down before being released float elapsedTime = e.TimeHeldDown; Debug.Log( e.Finger + &quot; Up at &quot; + e.Position + &quot; on object:&quot; + e.Selection); 五.自定义手势识别3.0后可以用PointCloudRecognizer来识别自定义手势。算法使用的是$P recognizer. 现在只支持single-stroke(单手指单次画)，将会支持multi-strokes. PointCloudRecognizer将会对比一些gesture模板并返回最接近的 匹配图形，并返回分数和距离值。 PointCloudgestures手势，和缩放以及画的方向无关。但是图形的旋转必须是固定的，例如一个正着摆放的三角形你必须画正的，你画一个倒着摆放的三角形它是不能被识别的。 绘制PointCloud (1)在Assets栏下，创建 PointCloud Gesture Template,起名MyPCGesture (2)点击Edit,绘制图形，然后Apply 使用PointCloud (1)新场景，加FingerGestures管理 (2)创建新的物体起名Gestures Gestures加 PointCloudRecognizer 组件。 Max Match Distance 用户画的图形distance必须在该值之下， 设定得越小，画得就必须越精确。 Sampling Distance 两个连续手指位置的最小间距。越小表示越精确，但更多的采样 Gesture Template List 要去匹配的图形库 MyPCGesture加至 Gesture Template List (5) 创建PointCloudTutorial.cs脚本并添加至Gestures物体下 1234567891011121314151617181920212223242526 using UnityEngine; using System.Collections; public class PointCloudTutorial : MonoBehaviour OnCustomGesture( PointCloudGesture gesture ) Debug.Log( &quot;Recognized custom gesture: &quot; +gesture.RecognizedTemplate.name + &quot;, match score: &quot; + gesture.MatchScore + &quot;, match distance: &quot; + gesture.MatchDistance ); PointCloudGesture. RecognizedTemplate 对应画出的图形模板 PointCloudGesture. MatchScore 匹配百分比，1代表完美匹配 PointCloudGesture. MatchDistance 与图形有多接近 当然也可以从代码绘制PointCloudGestureTemplate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 Awake() PointCloudGestureTemplate triangle =ScriptableObject.CreateInstance&lt;PointCloudGestureTemplate(); triangle.name = &quot;Triangle Gesture Template&quot; triangle.BeginPoints(); triangle.AddPoint( , , ); triangle.AddPoint( , , ); triangle.AddPoint( , , ); triangle.AddPoint( , , ); triangle.EndPoints(); PointCloudGestureTemplate square =ScriptableObject.CreateInstance&lt;PointCloudGestureTemplate(); square.name = &quot;Square Gesture Template&quot; square.BeginPoints(); square.AddPoint( , , ); square.AddPoint( , , ); square.AddPoint( , , ); square.AddPoint( , , ); square.AddPoint( , , ); square.EndPoints(); PointCloudRegognizer recognizer =gameObject.AddComponent&lt;PointCloudRegognizer(); recognizer.AddTemplate( triangle ); recognizer.AddTemplate( square ); AddPoint的第一个参数代表第几画，但是现在只支持一笔画出来的图形，所以该值只填0。当EndPoints()被调用的时候，所有点都会被单位化至(0,1)的范围。","link":"/blog/2019/05/17/Unity插件/FingerGestures/"},{"title":"Strumpy-Shader-Editor入门教程","text":"对于3D游戏来说，有很多绚丽的效果，都是靠shader（着色器）来实现的。不过很多朋友估计都不会编写shader，阿赵我自己也只是看了个入门，明白了它的原理，很多具体的效果都写不出来的。这次来介绍一个Unity3D的第三方shader编辑器：Strumpy。这个编辑器是完全可视化编辑，使用起来相对简单一点。 先来看看我们这次需要做的例子： 我们需要使用Strumpy，编辑出这样一个shader：包括了漫反射通道、法线通道、高光通道，以及在模型的边缘运动的光效。 很显然，Unity3D自带的shader没有能直接实现这样的功能的，最多也只能使用法线和高光通道而已。 由于这个例子稍微复杂，所以我们先来做一个更简单的例子，来熟悉一下strumpy的界面和基本操作。首先肯定是要先下载Strumpy插件了。在Asset Store里面有，免费下载的。我这里使用的是4.0a版本。 下载完之后导入，会看到多了一个选项： 选择之后打开了Strumpy的编辑窗口： Flie的功能很直观，新建，读取，保存和导出的功能，我们可以先看看读取功能 插件自带了一些已经编辑好的范例，有兴趣的朋友可以逐个看看，会有很大的收益。 然后我们来正式开始做这个简单的例子，我们准备了一张带有透明通道的贴图（拿斩首大刀的阿赵），接下来我们做一个shader，把这张贴图显示在一个面片上面，使它实现漫反射通道和透明通道的显示。 我们新建一个着色器编辑： 注意看，新建时，在Settings的标签是红色的，然后ShaderName也是红色的，这是提醒我们，每一个shader必须要先有一个名称，而这个名称就是以后你在材质栏里面选择的材质名称了。比如你可以用“myshader/test”，这样test材质会出现在myshader下面。 输入材质名词之后，我们先来Inputs里面，新建一个输入。这个输入，就是我们平常在Unity自带的材质球里面看到的输入通道了。假如我们需要它能调节颜色，那么就要新建一个颜色的输入，假如需要调用贴图，就要新建一个贴图的输入。这里我们新建一个Unity预设的MainTexture。熟悉用脚本替换材质贴图的朋友估计很熟悉这个标签的含义了。 新建之后，我们可以看到，出现了一个贴图选择的通道，就像我们平常操作的自带材质球一样。 接下来我们会新建一些节点，然后对他们进行编辑。 创建节点的方式有两种： 第一种是在Nodes里面选择相应的节点： 第二种是在节点编辑的窗口鼠标右键单击，选择相应的节点。 我个人比较习惯第二种方法。 我们选择了一个Sampler2D的输入 刚生成的时候，这个节点是红色的，因为我们没有指定输入的来源。想起刚才我们新建的Input了吧？那个MainTexture指定在这里。 在选中该节点的情况下，来到Node的标签，会看到提示错误了 我们选择_MainTex 这时候，节点就不再是红色了，而是出现了两项输出，分别是2D采样和UV信息。节点名称里面，也会相应的显示出_MainTex，也就是我们刚才新建的Input的名称。 接下来我们新建一个Tex2D方法节点。 然后像上图一样，用鼠标把他们之间连起来。 这时候，把我们预先准备好的贴图指定在贴图通道里面 点击预览窗口的Update Preview，会看到预览的物体上面出现了我们的贴图 为了便于观察，我们选择一个片面模型。这时候，漫反射通道已经完成了，接下来我们继续做透明通道。 如上图一样，把A连接到Alpha通道。 然后来到Settings，按上图设置一下。 打开背景显示，会看到透明通道已经生效了。 在完成了以上的小例子之后，我们正式来解释一下Strumpy各个部分的意思吧。 在master里面，分别是各个通道的最终输出。 节点是通过有方向性的线条来连接的，分为输入端和输出端，上图是一个单向输入输出的例子。 再来是一个运算的例子，Add是相加的操作，这里是两个输入端进入了相加，然后输出一个结果。 在这里要说明一下的是，这些操作很大一部分都是数学运算的方法，比如加减乘除、sin、cos之类，各位在学习之前最好要先理解他们的意思。比如相加就是互相叠加，两张图相加会整张图都变得更亮。相乘是波峰波谷的叠加，两张图相乘，会使亮的地方更亮，暗的地方更暗。其他的方法请各位自行百度去查阅了，就不一一说明。 再来看看设置的选项 如果曾经自己写过shader的朋友，对于这些选项应该是很熟悉的。比如很多朋友问的双面显示，其实就是把CullMode选择为Off就行。 介绍完基本功能，我们正式的来做这次的目标例子了。 这里我们准备了一个模型。 模型带有了漫反射贴图和法线贴图。 首先新建一个着色器编辑，然后给shader起名为：myShader 按照第一个例子的操作，我们完成了漫反射通道。 为了应用在我们的模型上，我们需要先生成一个shader。选择导出（Export As） 给shader起一个文件名。这个名称没有太大的意义。 导出之后，我们来到材质球选择的地方，会看到了我们新建的myShader，选择它。 然后指定漫反射贴图，我们的模型变成了上图的效果。 接下来，我们在Inputs里面新建一个凹凸贴图的输入 然后完成法线通道节点的编辑。由于需要使用法线贴图，所以需要加入一个UnPackNormal的节点。 这时候，我们会发现输入通道处多了Normalmap通道，我们把法线贴图赋予上去。模型变成上图的效果。 我们再新建一个颜色输入，作为高光的颜色。 完成高光通道和光泽强度的节点编辑。 这里我用了一个Multiply（相乘），目的是让光泽强度范围的对比度更大，显得高光会更尖锐一点。高光颜色直接连接到Specular通道。 现在我们的模型已经拥有了一定的质感了。由于模型原来是没有法线贴图的，我拿了漫反射贴图来直接转换，所以效果差了点，有兴趣的朋友可以自己做法线贴图增强效果。 接下来做有动画效果的光。 我们新建了几个输入：发光颜色（_LightColor），一个发光颜色的遮罩贴图（_Light），一个浮点（_dir）作为光运动的方向，一个范围选择（_RimPow）作为发光强度的控制。 这张是发光遮罩贴图，是一张黑白的梯度图。 这一个步骤的节点编辑有点复杂，基本的思路是将颜色和遮罩贴图混合在一起，并用时间控制UV动画： 1、遮罩贴图我用了ViewDirection和Fresnel结合控制显示方向，并用_RimPow作为显示方向的次幂控制显示强度。 2、为了让光会随着时间自己做动画，我是用来Time和_dir相乘，这样可以控制动画的速度和方向。 3、为了让UV移动做动画，我用了UV_Pan。记得UV_Pan需要选择输入的轴，这里我选择了Y轴。 4、最后，我把发光颜色和遮罩运算的结果相乘，达到叠加波峰改变颜色的目的。 最后，发布shader，根据需要选择相应的遮罩贴图，指定发光的颜色、强度和方向，我们的例子就完成了。 补充说明几点： 1、可能很多功能自带的shader都有，不过有时候你就是会需要一些功能特殊一点的shader，具体需要什么输入通道，和怎样的操作，请根据实际情况考虑。 2、关于即时镜面反射的shader，估计很多朋友都很感兴趣。不过我这里不打算详细介绍，因为unity没有直接即时反射运算的shader。 简单说明一下其原理： 在自带的水面和愤怒机器人场景里面，我们都看到了类似镜面反射的效果，其实这都是一种欺骗。做法不算复杂，其实是根据了当前摄像机的位置，新建了一个相对角度的反射摄像机，并把反射摄像机看到的内容渲染成RenderTexture。最后把RenderTexture和位置矩阵输入到普通材质的贴图通道，达到好像即时反射的效果。水面的例子做法会傻一点，因为它是针对水面物体自己生成了一个反射摄像机，所以的反射效果只会对水面本身有效果，每个可以反射的面，都要单独生成。而愤怒机器人里面的例子会聪明很多，它会在摄像机的脚本里面根据预先选择的可反射的图层，统一生成了一张RenderTexture，并让所有可以反射的shader使用。 结合着即时反射这个例子，可以看出实际上很多特殊的效果，都不是单独的shader能直接实现的，还需要到其他的脚本去配合。","link":"/blog/2019/05/17/Unity插件/Strumpy-Shader-Editor入门教程/"},{"title":"Unity-AssetBundle可视化构建工具","text":"Unity 全球技术支持部门制作了一些实用的小工具免费供大家使用，此前已为大家推荐了用于批量处理资源文件的AssetAuditing。今天要给大家推荐的是一款名叫AssetGraph的插件，可以帮助开发者方便地定制AssetBundle构建规则并进行可视化的管理。 项目介绍在Unity5.x中构建AssetBundle的流程已经比4.x时代大大简化，开发者不用在资源的依赖关系上花费太多时间，但是在实际大型项目中，开发者可能会发现仅靠引擎自带的功能对AssetBundle进行管理还有不太方便的地方。例如：如果希望为不同平台对AssetBundle的构建设置不同的规则（包括打入AssetBundle内的资源，资源的导入设置等），那么开发者可能会在两套不同方案的切换中花费不少的时间，或者需要自己编写一套对应于项目需要的AssetBundle打包工具。鉴于此我们开发了AssetGraph，让开发者可以根据实际需求可视化地定制AssetBundle打包规则并有效地进行管理。 使用方法 添加节点 打开AssetGraph窗口，在AssetGraph的画布上点击鼠标右键会弹出可以添加的节点列表，每个添加的节点都可以在其Inspector中设置对应的属性值。而首先要添加的是Loader节点，这个节点用来指示哪个文件夹下的Assets会作为Output输送给接下来的节点以进行设置或过滤直至最后打入AssetBundle中。 ** ** 连接节点 当创建了两个以上的节点时，可以通过点击并拖动节点上的小圆点到另一个节点上来创建两个节点之间的link，这时一个节点的Output即成为另一个节点的Input。通过点击link，我们可以在link的inspector窗口中实时查看此时通过此link的Asset。 ** ** 设置节点属性 通过点击一个节点，你可以在其inspector窗口中设置你所需要的AssetBundle构建规则属性。例如Filter节点允许你设置Asset的过滤规则，而Importer节点则允许你设置需要应用到这个节点的InputAssets上的导入设置。 ** ** 构建AssetBundle 最后只要点击AssetGraph上的Build按钮，就能构建出基于你所设定规则的AssetBundle了。如此，AssetGraph让你可以简单方便地管理不同的构建需求并通过可视化界面实时验证结果是否正确。 节点介绍 Loader Loader定义了Asset的最初源头，你可以指定一个根目录（也可以指定Assets/外部的目录） IN: 无 OUT：指定目录下的所有Asset ** ** Filter Filter用于过滤输入的Asset，你可以在inspector窗口中设置多条过滤的规则。 IN: 上个节点输出的Asset OUT：符合过滤规则的Asset ** ** Importer Importer可以重载输入Asset的导入设置（注意只是在构建AssetBundle的时候改变了导入设置，原来的导入设置其他时候仍然生效） IN：上个节点输出的Asset OUT：应用了所设导入设置的Asset ** ** Grouping Grouping可以根据设定的关键字把输入的Asset进行分组，而“*”星号可以作为关键字的一个通配符。 IN：上个节点输出的Asset OUT：根据关键字设置的Asset分组列表 ** ** ** ** Prefabricator Prefabricator可以把输入的Asset创建成Prefab。可以通过扩展AssetGraph.PrefabricatorBase类来定制自己的Prefab创建方式，具体代码示例请参见项目GitHub说明页面。 IN：上个节点输出的Asset OUT：包含了新生成的Prefab的Asset（Prefab被分配在对应的group中） ** ** Bundlizer Bundlizer用来把输入的Assets指定到特定的AssetBundle中并设置AssetBundle的命名，其中“*”星号可以适配Grouping节点的通配符。 IN：上个节点输出的Asset OUT：包含了输入Asset的AssetBundle ** ** BundleBuilder BundleBuilder用于实际构建AssetBundle。通过使用Bundlizer和BundleBuilder,你可以同时构建带有不同设置的AssetBundle（比如说压缩及非压缩）。 IN：上个节点输出的AssetBundle OUT：构建出来的AssetBundle文件 ** ** Exporter Exporter可以把输入的AssetBundle或Asset文件保存到指定的文件夹中（可以指定Assets/外部的目录）。 IN：上个节点输出的Asset或AssetBundle文件","link":"/blog/2019/05/17/Unity插件/Unity-AssetBundle可视化构建工具/"},{"title":"Unity3D插件之DoTween","text":"官方下载地址：http://dotween.demigiant.com/download.php 1、把下载到压缩包中的DOTween文件夹拷贝到项目文件中 2、安装DOTween：菜单栏——》Tools——》DOTween Unility Panel——》Setup DOTween… 配置DOTween（全局配置） 全局参数说明： Safe Mode：勾选时，间补动画平滑度会稍稍下降，但可以防止出现目标体被销毁，tween还在运行的情况 Editor Report：勾选时，当DOTween运行结束后会输出一份运行情况报告 Log Behaviour：调试日志输出类型，ErrorsOnly、Verbose（详细的）、Default Settings Location：菜单文件存放目录 Recyle Tweens：勾选时，间补动画不会被销毁，会缓存到对象池中，等待启用；（建议不勾选） AutoPlay：运行时自动播放类型，None/Auto play Sequence（自动播放Sequence）/Auto playTweener（自动播放Tweener）/All Update Type：动画每帧更新类型，正常Normal，固定帧更新Fixed，晚于正常帧更新Late TimeScale Independent：独立Tween时间缩放控制 Ease：动画缓动类型（linear（线性的）；OutQuad（前快后慢）…具体参考：http://easings.net/zh-cn） Ease Overshot：后偏移缓动值 Ease Period：前偏移缓动值 AutoKill：是否自动释放内存，后面需要重新启用的可以单独设置.SetAutoKill(false) Loop Type：循环类型，Restart（重新启动），Yoyo（来回循环），Incremental（增量循环） 因为NGUI中已经有UITween了，可是UGUI中是没有这样的Tween的。我看过UGUI的Demo它的实现方式是用Animator来做的，这样每一个需要移动的对象就要挂上一个AmimationController并且还要去编辑动画。。想想都恐怖，我觉得真没必要那么做。。 我强烈建议新项目使用DoTween。&lt;http://dotween.demigiant.com/网址要翻墙，不然打不开。不要紧后面我把下载地址提供出来。（目前DoTween还是测试版本）DoTween的文档写的非常详细，所以我就简单的只写两句代码，为大家抛砖引玉一下即可。 不得不说的是，因为在做游戏暂停的时候通常会使用Time.Scale ＝ 0 ，可是暂停的时候UI如果需要继续有动画怎么办呢？在DoTween中只需要设置tweener.SetUpdate(true); 即可。意思就是这个Tween是忽略TimeScale，如果不写的话 tweener.SetUpdate 是false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using DG.Tweening; //不能少了这个命名空间。Start//让TimeScale = 0timeScaleImage imagetransform&quot;Image&quot;GetComponentImage//调用DOmove方法来让图片移动Tweener tweenerimagerectTransformDOMoveVector3//设置这个Tween不受Time.scale影响tweenerSetUpdate//设置移动类型tweenerSetEaseLineartweeneronCompletedelegateDebug&quot;移动完毕事件&quot;imagematerialDOFadeonCompletedelegateDebug&quot;褪色完毕事件&quot; Tween的移动类型有很多种，比如匀速运动、加速运动、减速运动，等等。如果你拿捏不准你需要用什么移动类形式。 &lt;http://www.robertpenner.com/easing/easing_demo.html你可以在这里预览一下那种移动类型更佳适合你。 最后是DoTween的类库，如果你没有翻墙就下载我的吧， 是最新的。 欢迎大家在留言处和我一起讨论，加油！Fighting! &lt;http://pan.baidu.com/s/1o6qiefC 官方文档链接：http://dotween.demigiant.com/documentation.php#globalSettings 普通版下载地址：http://dotween.demigiant.com/download.php pro版下载地址：http://pan.baidu.com/s/1dEzTQkL (pro版提供DOTween Animation和DOTween Path这两个组件，支持可视化编辑) 移动类型：http://robertpenner.com/easing/easing_demo.html DOTween真的比iTween好很多： 1.编写方面更加人性化 2.效率高很多，其中有一点是因为iTween使用的是unity内置的SendMessage DOTween一般的样子是这样滴： 1234using DG.Tweening;transform.DOMoveX(45,1).SetDelay(2).SetEase(Ease.OutQuad).OnComplete(MyCallback); 好了，正式开始！ 一些名词： Tweener ：补间动画 Sequence ：相当于一个Tweener的链表，可以通过执行一个Sequence来执行一串Tweener Tween： Tweener + Sequence Nested tween ：Sequence中的一个Tweener称为一个Nested tween 主要的方法(就是最常用的)： 1.以开头的方法：就是的方法。例如：transform.DOMoveX(,) 2.以 Set 开头的方法：设置补间动画的一些。例如：myTween.SetLoops(, LoopType.Yoyo) 3.以开头的方法：补间动画的 回调 方法。例如：myTween.OnStart(myStartFunction) DOTween初始化与全局设置： 当你第一次创建一个Tween时，DOTween就会自动初始化(只初始化一次)，使用缺省值。 当然，也可以使用DOTween.Init方法进行自定义，但要在第一次创建一个Tween前。所有创建的Tween都会受DOTween.Init方法的影响。 但之后，你也可以通过DOTween类的一些静态方法或者变量来修改全局设置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static LogBehaviour DOTween.logBehaviour static DOTween.showUnityEditorReport staticfloat DOTween.timeScale static DOTween.useSafeMode static DOTween.SetTweensCapacity( maxTweeners, maxSequences) static DOTween.defaultAutoKill static AutoPlay DOTween.defaultAutoPlay staticfloat DOTween.defaultEaseOvershootOrAmplitude staticfloat DOTween.defaultEasePeriod static Ease DOTween.defaultEaseType static LoopType DOTween.defaultLoopType static DOTween.defaultRecyclable static DOTween.defaultTimeScaleIndependent static UpdateType DOTween.defaultUpdateType static DOTween.Init(bool recycleAllByDefault = false, bool useSafeMode =true, LogBehaviour logBehaviour = LogBehaviour.ErrorsOnly) recycleAllByDefault ：如果为true，则当Tween完成时就会被回收，放到一个池中；否则就会被destroy useSafeMode ：效率会稍微降低，但更安全 logBehaviour ：默认值为只打印错误信息 创建Tweener(有三种方法)： static DOTween.To(getter, setter, to, float duration) 以DOTween.To(() = myVector, x = myVector = x, Vector3(3, 4, 8),1);为例，就是对myVector进行插值，目标值为Vector3(3, 4, 8) 123456789transform.DOMove( Vector3(2,3,4), 1); rigidbody.DOMove( Vector3(2,3,4), 1); material.DOColor(Color.green, 1); 对于unity内置的一些组件，都可以通过”.+DO开头的方法”的方式创建补间动画 以transform.DOMove(new Vector3(2,3,4), 1)为例，newVector3(2,3,4)是最终值，意思是用一秒的时间运动到Vector3(2,3,4) 而transform.DOMove(new Vector3(2, 3, 4), 1) .From()，就是从Vector3(2,3,4)运动到当前位置 1234567891011121314151617181920212223static DOTween.Punch(getter, setter, Vector3 direction, float duration,vibrato, float elasticity) static DOTween.Shake(getter, setter, float duration, float/Vector3 strength,vibrato, float randomness, ignoreZAxis) static DOTween.ToAlpha(getter, setter, float duration) static DOTween.ToArray(getter, setter, float duration) static DOTween.ToAxis(getter, setter, float duration, AxisConstraint axis) static DOTween.To(setter, float startValue, float endValue, float duration) 创建Sequence： Sequence可以包含Sequence，当执行一个Sequence时会 顺序执行Tweener ，可以使用Insert方法实现同时执行。 Sequence的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static DOTween.Sequence() Append(Tween tween) AppendCallback(TweenCallback callback) AppendInterval(float interval) Insert(float atPosition, Tween tween) InsertCallback(float atPosition, TweenCallback callback) Join(Tween tween) Prepend(Tween tween) PrependCallback(TweenCallback callback) PrependInterval(float interval) // Grab a free Sequence to use Sequence mySequence = DOTween.Sequence(); // Add a movement tween at the beginning mySequence.Append(transform.DOMoveX(1, 1)); // Add a rotation tween as soon as the previous one is finished mySequence.Append(transform.DORotate( Vector3(0, 180, 0), 1)); // Delay the whole Sequence by 1 second mySequence.PrependInterval(1); // Insert a scale tween for the whole duration of the Sequence mySequence.Insert(0, transform.DOScale( Vector3(3, 3, 3),mySequence.Duration())); 等同于： 123456789101112131415161718Sequence mySequence = DOTween.Sequence(); mySequence.Append(transform.DOMoveX(45, 1)) .Append(transform.DORotate( Vector3(0, 180, 0), 1)) .PrependInterval(1) .Insert(0, transform.DOScale( Vector3(3, 3, 3),mySequence.Duration())); 上面我们提到了全局设置，这里我们再说一说针对Tweener和Sequence的局部设置 1234567891011121314151617181920212223242526272829float timeScale SetAs(Tween tween \\ TweenParams tweenParams) SetAutoKill( autoKillOnCompletion = SetEase(Ease easeType \\ AnimationCurve animCurve \\ EaseFunction customEase) SetId(object SetLoops( loops, LoopType loopType = LoopType.Restart) SetRecyclable( recyclable) SetUpdate(UpdateType updateType, isIndependentUpdate = false 注意的一点是SetUpdate方法可以让目标忽略timeScale 回调方法： 123456789101112131415161718192021222324252627282930313233OnComplete(TweenCallback callback) OnKill(TweenCallback callback) OnPlay(TweenCallback callback) OnPause(TweenCallback callback) OnRewind(TweenCallback callback) OnStart(TweenCallback callback) OnStepComplete(TweenCallback callback) OnUpdate(TweenCallback callback) OnWaypointChange(TweenCallback&lt; callback) 还有一些针对部分Tweener的特殊的局部设置： 注意SetOptions方法必须紧跟Tweener ，就好像这样： 12DOTween.To(()= myVector, x= myVector = x, new Vector3(2,2,2),1).SetOptions(AxisConstraint.Y, true); TweenParams： 就是可以将一些参数应用到多个Tweener中 1234567891011121314151617// Store settings for an infinite looping tween with elastic ease TweenParams tParms = TweenParams().SetLoops(-1).SetEase(Ease.OutElastic); // Apply them to a couple of tweens transformA.DOMoveX(15, 1).SetAs(tParms); transformB.DOMoveY(10, 1).SetAs(tParms); 操作Tweener(有三种方法)： 1.DOTween静态方法 123456789101112131415161718192021// Pauses all tweens DOTween.PauseAll(); // Pauses all tweens that have &quot;badoom&quot; as an id DOTween.Pause(&quot;badoom&quot; // Pauses all tweens that have someTransform as a target DOTween.Pause(someTransform); 2.Tweener方法 1myTween.Pause(); 3.部件.+以DO开头的方法 1transform.DOPause(); 以上的是Pause方法，以下的是其余的操作方法。上面三种方式中，DOTween和Tweener都有以下的操作方法，而部件的话，要在前面加上”DO”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130CompleteAll/Complete() FlipAll/Flip() GotoAll/Goto(float andPlay = false KillAll/Kill( complete = PauseAll/Pause() PlayAll/Play() PlayBackwardsAll/PlayBackwards() PlayForwardAll/PlayForward() RestartAll/Restart( includeDelay = RewindAll/Rewind( includeDelay = TogglePauseAll/TogglePause()////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// using UnityEngine; using System.Collections; using DG.Tweening; publicclass Test : MonoBehaviour { public RectTransform rt; private isIn = false // Use this for initialization Start () //修改的是世界坐标 //Tweener t = rt.DOMove(Vector3.zero, 0.3f); //修改的是局部坐标 Tweener t = rt.DOLocalMove(Vector3.zero, 0.3f); //默认动画播放完成会自动销毁 t.SetAutoKill(false t.Pause(); public OnClick () (!isIn) //将开始该物体的所有Tweener rt.DOPlayForward(); rt.DOPlayBackwards(); isIn = !isIn; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using UnityEngine; using System.Collections; using DG.Tweening; using UnityEngine.UI; publicclass Test2 : MonoBehaviour { public Transform t; public Text text; // Use this for initialization Start () //Vector3.zero是绝对位置，表示从Vector3.zero移动到当前位置 //t.DOMove(Vector3.zero, 2).From(); //默认为false //Vector3.forward是相对位置，表示从Vector3.forward加当前位置移动到当前位置 t.DOMove(Vector3.forward, 2).From( //逐字显示 text.DOText(&quot;宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥宏哥” 1.如何对变量进行动画（dotween控制的变量改变动画） 1234567891011//对变量做一个动画（通过差值的方式去修改一个值得变化）//当前值 把修改的值（当前值到目标值的差值）赋值给myVvalue（unity计算好的） 目标值 变化时间//前两个参数（委托类型的变量）实为两个方法 DOTween.To(()=myValue,x=myValue=x,new Vector3(10,10,10),2); DOTween.To(()=myValue2,x=myValue2=x,10,2); 2.控制cube和UI面板的动画（应用到实际物体上） 123456789public RectTransform taskPanelTransform; //taskPanelTransform.position=myValue;//世界坐标 taskPanelTransform.localPosition=myValue; 3.动画的快捷播放方式DOMove，动画的前放和倒放 123456789101112131415161718192021222324////播放它时有一返回值Ttweener,Tweener对象保存这个动画的信息，每次调用都会创建一个tweener对象，这个对象是dotween来管理 //Tweener tweener=taskPanelTransfrom.DOLocalMove (new Vector3 (0, 0, 0),0.5f);//播放此动画时会创建一个动画，默认播放完成后即销毁，所以回放无效 //tweener.SetAutoKill(false);//使动画不被销毁.但造成的后果是每次都会创建耗费性能.解决方法，将其放入start方法中 taskPanelTransfrom.DOPlay();//只会播放一次 taskPanelTransfrom.DOPlayForward();//与下方的成对.播放对象身上所有动画 taskPanelTransfrom.DOPlayBackwards (); tweener.Pause();//为使初始不播放动画，暂停动画 4.From Tweens 1234567891011121314//cubeTransform.DOLocalMoveX(5, 1); //cubeTransform.DOLocalMoveX(5, 1).From(); //默认是从当前位置运行到目标位置，加上from方法后表示从目标位置移动到当前位置。from可被所有动画使用 cubeTransform.DOLocalMoveX(5,3).From(true);//默认为false。加上true后为相对坐标（相当于从当前坐标加上5运行到当前位置） 5.动画的属性设置（动画曲线和事件函数） 6.动画的生命周期和生命周期函数 1234567891011121314151617181920212223242526272829Tweener tweener = this.transform.DOLocalMoveX (0, 3); //tweener.SetEase (Ease.InBack);//先远离目标位置再快速的到达目标位置 //tweener.SetEase(Ease.InBounce); //tweener.SetEase(Ease.OutBounce); //tweener.SetLoops(2);//循环播放的次数 tweener.OnComplete(OnTweenComplete);//动画播放完成后调用什么事件 void OnTweenComplete() Debug.Log (&quot;动画播放完成后”); 7.对话框文字动画，屏幕震动效果 12345678910111213text.DOText(&quot;设计模式 设计模式 设计模式&quot;,2,true);//内容设置，时间，是否使用富文本 //只是camera随机振动，最后还会回到原地 //transform.DOShakePosition (1);//随机振动。时间 强度（0-1的值 或者 位置向量&lt;震动向量） transform.DOShakePosition(1,new Vector3(3,3,0)); 8.颜色和透明度动画 12345text.DOColor (Color.red, 2);//颜色渐变 text.DOFade (1,3);//修改alpha值 9.DOTween官方网站 DO开头 开启动画 Set 设置属性 10.动画的组件可视化创建方式DOTweenAnimation 11.DOTweenPath路径编辑器 （1）Tween Options.Loops -1 循环播放 （2）Path Tween Options.Path Type路径类型（折现，圆滑） .Close Path起点终点相连 .Orientation朝向 （3）Path Editor Options.Relative相对的，勾选后路径相对于对象，随对象移动。单个节点移动无碍 .Handles Type路径节点图标类型 .Handles Mode指向下一个点的模式（3d or 2d） （4）Button 点击事件控制动画的播放，DOTweenPath.DOTooglePause动画播放按钮（播放时点击可暂停，暂停时点击可播放）","link":"/blog/2019/05/17/Unity插件/Unity3D插件之DoTween/"},{"title":"Unity做项目事半功倍的插件","text":"MTE (Mesh Terrain Editor) 地形编辑器基于模型的地形转换、编辑工具。 就不详细介绍了，大家看帖。 中文论坛帖： Mesh TerrainEditor，基于模型的地形编辑器，T4M的替代品 英文论坛帖： Mesh Terrain Editor, a mesh-based terrain converter andeditor 大家可以尝试下 免费版，如果感觉需要的话，请支持专业版，谢谢！ 另外，推荐ConsoleE，增强版的Unity3D控制台。 有很多好用的功能，个人觉得最方便的是 1. 双击打开堆栈某一行的代码（免费版只能打开前两行） 2. 可逐行复制log内容 大家不妨试试！ http://u3d.as/5YZ Qhierarchy 你管理一个有几千物体的场景，点击单个物体，关掉它显示，或者修改它的static方式之类的根本就是噩梦，用Qherarchy的话，稍微点击下小眼睛关闭就好，对我来说是必备插件，而且可以很容易查找到物体是否有attachscript，以及脚本是否出错，非常好使。 我知道很多人是用Hierachy2 的，那个的功能和Qhierarchy类似，但是当时在unity4-5的版本升级里面出很多bug,而且功能我觉得有些太复杂，反而不如Qhierachy便宜好用 Haste Pro unity内的everything,场景东西多到死，资源乱到想跳楼，要查找某个特定的物体或者component感觉整个人都要不好了，这时候使用本插件药到病除，不知不觉就买了正版。 Asset hunter 啊西坝，混蛋美术塞了五千个材质球在asset里面啊！！，基本都没用过啊！！ 选择材质时候冒出来满屏幕！！ 怎么破！ 用asset hunter轻松分辨场景是否有使用到此asset,一键删除，世界恢复了和平 跟 Build report tool功能有点像，大多数情况下asset hunter用着更爽利 Legacy 2 PBR Unity4项目升级到unity5了，材质还是那个老味道….难道一个个改么，，， 这时候Legacy 2 PBR一键拯救你 其他的就不是每个项目都需要用了，动画用默认，特效用默认就好，（可以买几个滤镜）有些东西如finalK shaderforge,A* project,CameraDirector等等等等等等等都是极好的，不过那些插件玩一下就都要付出很多精力时间了，不是项目需要就别入坑了，何况这些东西任何一个都足够写一大篇长文来分析和赞美了。 我推荐上面几个的理由是，unity插件应该是在某种使用的思路下被统合起来的，否则不如不用，而上述几个主要是加速你的工作效率，所以尽可大胆使用。 另外，稍微有点经济实力的还是应该购买正版，不要问我任何求插件问题，拉黑你哦！ 常用的 Unity 插件 Advanced PlayerPrefs Window 用来管理 PlayerPrefs 数据，超好用 JsonDotNet JSON 的序列化/反序列化插件。这个插件是支持 iOS, Android, WP8等多平台且 Bug 最少的一个。 iOS，Andoird 统一插件 Prime31 的 IAP Combo，AdMob Combo 插件。同时支持 iOS 和 Android 平台。 UMeng 统计插件，TalkingData 统计插件，两者其实都差不多。 PrefabEvolution Prefab 嵌套插件。其实也就那样，设计阶段好好规划一下Prefab的结构，用嵌套的地方其实不多。 NGUI，曾经的 UI 不二之选。现在换 UGUI 了就不再用了。 2DTookit，用得不多。虽然 Unity 已经支持2D，但这个软件依然有很多方便的地方。 iTween, DoTween, LeanTween, 对象动画类插件，其实都差不多。挑一个用就行。 AssetBundle Manager可以在不build、部署AssetBundles的情况下，就用editor模拟加载本地、远程AssetBundles，支持AssetBundleVariants，让测试、编辑AssetBundle的工作变得非常方便。 uFrame用unity做游戏实质上就是用轮子组系统的过程，无论抵制轮子还是造轮子，支持插件还是反对插件，都不重要。重要的是整体的框架是否健壮合理，中间的焊缝是否严实。 推荐uFrame，你的代码结构和质量飞速上升。项目必备，一群天才的插件，有一个健康的社区讨论。 playmaker如果做游戏的过程中需要编程，并且你的编程能力并不是非常强大的话，强烈推荐playmaker，主打『visualscripting』，方便轻松并且方便能很高效率的通过脚本实现各种游戏功能（包括特效），asset store常年best seller ，好评飞起。 价格有点小贵，不带学生折扣45磅左右，如果是学生的话可以通过edu邮箱在官网申请打折扣，便宜100多好像？对于不是编程或者CS背景，偏3D建模和视觉设计的人（比如我）来说，做游戏真的简单了一万倍，简直就是把小格子连来连去…… 然而， 也有许多经验丰富的老工程师 表示最好不要用，比如这位： [Should you use Playmaker inproduction?](https://link.zhihu.com/?target=http%3A//va.lent.in/should-you-use-playmaker-in-production/) 理由太长了请自己看。 然而， 不是经验丰富的老工程师， 又需要高效率的实现游戏功能， 没有丰富夯实的CS基础又想要看上去吊炸天的小特效， 完全推荐playmaker。 JumpCommand我一直在用自己写的小工具JumpCommand。只要给函数添加一行代码，就能用命令行来调用该函数，拿来调试或测试用的，很方便。 Mesh Baker项目开发的时候经常会大量使用大规模的Mesh，导致Draw Call过高。而MeshBaker扮演了网格烘焙器的角色，其工作原理是将网格和材质合并，从而降低渲染的Draw Call。 SimpleLOD比较适合大规模场景的制作开发。在处理多人在线的项目（如MMO游戏）时，按照我们以往的优化方法是尽可能降低DrawCall和减少渲染消耗，在远处使用低级LOD，在Run-time时根据相机距离切换合适的LOD，使得在手机性能有限的情况下尽量渲染更多的角色，达到更好的效果。 而SimpleLOD恰好可以满足这一点，除了同样拥有Mesh Baker所具有的Mesh合并、Atlas烘焙等功能，它还能提供Mesh的简化（MeshBaker无法提供），并对动态蒙皮网格进行了很好的支持。该插件可在Run-time和Editor中都可以使用，同时开放了源码，大家可以根据项目的实际情况而作修改。 具体的使用方法大家可以参阅：好插件让你事半功倍！【资源篇】 FairyGUI一个游戏大部分的工作量是在制作UI。无论是NGUI，或者是UGUI，都只是一个基础的UI制作工具，制作过程需要程序员全程参与，而且很多功能也只能通过写代码完成，非常不友好。 FairyGUI是不同于NGUI和UGUI的一个独立的UnityUI系统，他最大的特点是提供一个对美术、策划都友好的UI编辑器，不需要编码就能实现绝大部分UI制作的需求。使用FairyGUI使Unity的UI制作进入标准化时代。FairyGUI编辑器非常简单易用，都是纯2D的操作，不需要理解相机、网格等复杂的3D概念。FairyGUI编辑器还同时提供了支持Starling/Egret/Laya的SDK，这意味使用FairyGUI可以使你的UI资产以及UI技能在3D主流引擎、页游主流引擎，H5主流引擎上零成本迁移。 使用FairyGUI，解决了Unity制作UI的很多痛点，例如多国语言支持，可视化编辑UI动画，图文混排（包括文字和动画混排），虚拟列表（数量巨大的列表数目也不卡顿）、循环列表，像素级点击检测、3DUI，VR UI（轻松制作出曲面UI）, 内置手势库，更带有自动生成代码的功能。 使用FairyGUI可以大大提供Unity UI制作UI的效率，减轻了程序员的负担，同时也为企业节约了成本。","link":"/blog/2019/05/17/Unity插件/Unity做项目事半功倍的插件/"},{"title":"Unity实用小工具：Asset-Auditing","text":"Unity Global Support部门制作了一些实用的小工具免费供大家使用，今天要推荐的就是用于批量处理资源的小工具：Asset Auditing。 Unity GlobalSupport部门主要负责对使用Unity引擎的企业级VIP客户提供技术支持，大中华区已实现全面覆盖，目前包括腾讯，网易，巨人，完美世界等公司已属于Unity的企业级VIP客户。 Asset Auditing主要用于执行各资源的审核工作，比如导入贴图时按照统一既定格式进行批次设置，简单易用，且具有高度可扩展性。 今后Unity中国区Github也会免费提供一些常用的开发工具。 项目介绍在开发Unity项目的时候，很多开发者都会遇到资源管理的问题。比如因为一些疏忽，你可能忘记把一张超大的4096分辨率的贴图设置成压缩格式，另外也有可能不小心把Mesh文件设置成了Read/Write模式。靠人工来检查资源的导入设置往往是不靠谱的，因此我们开发了一个小工具，你可以用它来监督所有资源的导入设置，减少因为不正确的导入设置带来的问题。 导入设置在Unity中，所有要导入到引擎的资源都有各种不同的导入选项。这些选项用来调整资源的属性、导入精度、以及压缩方法等等。某些设置还会包含一些重要的平台相关的选项。比如在iOS平台，你所使用的纹理有可能需要和Android平台使用不同的设置，如果使用手工来管理这些设置会是非常困难的，可能会导致很多错误。因此，通过自动化的管理工具来执行这些操作是一个非常必要的方式。 如下图所示，这是一张纹理的导入设置： 实现方法Unity引擎提供了资源导入的回调函数，这些回调函数是通过AssetPostprocessorAPI来实现的。AssetPostprocessor中的这些函数会按照一定的顺序执行，它们的执行顺序如下： OnPreprocess是导入过程中最早执行到的，你可以在这里重新指定新的导入设置。我们在工具中会设置相同类型的资源使用统一的设置就是在这里完成的。 一旦模型和材质导入完成之后，引擎会根据资源内的数据创建GameObject层级。每个GameObject会拿到它对应的MeshFilter、MeshRenderer、MeshCollider组件等等。在把材质赋值给MeshRenderer之前会调用OnAssignMaterialModel 函数。 在GameObject初始化MeshRenderer和用户数据之后，OnPostprocessGameObjectWithUserProperties 会被调用。这会在它的子GameObject生成之前调用。 如果前面没有禁止动画生成设置的话（请查看ModelImporter.generateAnimation），接下来会生成SkinnedMesh和Animation。如果可能的话，Avatar也会被创建出来并且执行GameObject的层级优化，然后会调用OnPostprocessModel 函数。 对SpeedTree资源来说会调用 OnPreprocessSpeedTreee 和 OnPostprocessSpeedTree函数，这和OnPreprocessModel以及OnPostprocessModel函数是类似的。 使用方法正确使用该工具，大致分为以下步骤； 一、将AssetAuditing工具导入到工程。 二、创建资源导入格式文件。 点击Unity编辑器的Assets/Create Asset Auditing Rule菜单，在编辑器的Project窗口里会创建一个New AssetRule文件。如下图所示： 在上图中，Asset Rule Type包括Any，Texture，Mesh三个选项。TEXTURESETTINGS下属内容对应贴图属性信息，即所有对应的Texture都将应用该面板中的属性设置。例如勾选下方的Generate MipMaps则表示所有的Texture都将生成Mip Map。MESHSETTINGS下属内容对应网格的属性信息，即所有对应的Mesh都将应用该面板中的属性设置。 相应信息设置完毕后，只要点击Apply按钮就会对相应的资源类型执行相关的设置。 如果希望对该功能进行扩展，可以对Editor目录下的AssetRuleInspector脚本进行简单修改，以达到实际需求。 三、设置导入参数。 导入格式文件跟其所在的文件夹相对应，如下图所示，Texture目录下对应的贴图都会统一采用Texture Rule格式文件所设置的属性信息： 同理，如果需要设置模型数据的导入格式，则如下图所示，只需要在模型文件所处的文件夹下存储一份格式文件即可： 设置完参数后请点击Apply按钮，然后工具会自动化处理相关的资源文件，将他们的导入设置按照配置文件的内容进行统一设置，并且重新导入资源文件。","link":"/blog/2019/05/17/Unity插件/Unity实用小工具：Asset-Auditing/"},{"title":"Unity资源清理工具Asset-Cleaner","text":"Unity Global Support部门制作了一些实用的小工具免费供大家使用，前面已经分享过了批量处理资源的AssetAuditing，今天继续为大家推荐用于批量清理资源的小工具：AssetCleaner。 Unity GlobalSupport部门主要负责对使用Unity引擎的企业级VIP客户提供技术支持，大中华区已实现全面覆盖，目前包括腾讯，网易，巨人，完美世界等公司已属于Unity的企业级VIP客户。Asset Cleaner主要用于查找并删除没有被引用的资源，简单易用，且具有高度可扩展性。 项目背景在Unity项目中，我们习惯将所有的资源统称为Asset。Asset一般存放在Assets目录及其子目录。随着项目的研发进度，Asset数量也会爆发式地增长，资源管理面临很大的挑战。如何查找并区分有效和无效的资源，是很多项目管理者非常重视的事情。本文介绍的这个工具可以自动分析查找项目中未使用到的资源，在选择删除的时候还可以将这些文件打包备份，确保资源的安全性、提高项目管理的效率。 实现原理该工程只有四个CS文件，需存放在Editor目录下。 FindUnusedAssets是这个工具的主要入口，实现了编辑器的扩展菜单及其内部调用。 AssetCollector是总的工具类，用来收集所有的asset文件 ClassReferenceCollection用来收集所有的.cs脚本文件。 ShaderReferenceCollection用来收集所有的Shader文件。 AssetCollectorAssetCollector实现了这个工具的核心代码，点击菜单时会调用定义在它内部的Collection函数。AssetCollector中声明了两个变量，useCodeStrip和saveEditorExtensions。useCodeStrip用来控制要不要删除未使用的脚本文件，saveEditorExtensions用来控制检测资源是否被Editor脚本引用。工具中提供了三个菜单项，分别是onlyresource、unused by editor、unused bygame。这三个菜单项执行的代码就是通过设置useCodeStrip和saveEditorExtensions为不同的值来控制过滤的方式。 资源搜集Collection函数内实现了各种类型资源文件的搜索过滤。 Directory.GetFiles()获取“Asset”目录及其子目录下所有相关资源的名字,通过Linq语法进行过滤，获取需要的文件类型。 依赖关系获取 通过AssetDatabase.GetDependencies获取当前有效的场景文件及场景依赖文件。 使用介绍首先我们要保证当前工程中存在有效的场景文件，因为Asset资源的有效性依赖于是否被场景引用。 使用时需要找到这个菜单项Assets-&gt;Delete Unused Assets,如下图所示。 Delete Unused Assets下有三个选项，分别是删除未使用的资源文件（only resource），删除编辑器未使用的Asset（unusedby editor）和删除游戏未使用的Asset（unused by game）。 使用方法在开始使用该工具时，要保证有效的EditorBuildSettings.scenes 选择Delete Unused Assets下“only resource”选项，弹出对应的删除列表。如下图所示： 显示在删除列表中文件。单击“Delete”，列表中的文件从项目中移除，工具会把这些文件作为一个UnityPackage导出到“../BackupUnusedAssets/”。这个包作为被删除文件的备份，如果后期发现有资源丢失，可以从这个包内找到对应的资源文件重新导入。 上面简单介绍了Asset Cleaner工程的工作原理及使用方式。在实战中，我们可以根据需求自定义查找文件的格式。","link":"/blog/2019/05/17/Unity插件/Unity资源清理工具Asset-Cleaner/"},{"title":"Unity酷炫特效脚本插件","text":"上周为大家介绍了AssetStore中非常受欢迎的不同游戏类型的完整模板，今天则分享一些脚本插件，用来实现各类酷炫的特效，包括爆炸、闪电及天空盒等。 Exploder 看名字就知道了，Exploder就是用来在Unity中实现各种爆炸效果的脚本插件。它可以实时分解网格，在几毫秒内将任意对象分崩离析。由于是实时计算，所以不需要预定义游戏对象作为碎片，所有过程仅需调用一行代码即可瞬间完成。 该插件带有强大的网格切割器，会查找游戏对象上的网格将其切割为小碎片，在游戏对象上添加Rigidbody组件再设置好加速度即可实现爆炸效果。出于性能的考虑，这些小碎片会存放于预先分配的对象池中，以尽可能减少创建及初始化游戏对象的次数。 使用Exploder非常简单，正如之前所说，仅需一行代码即可完成。首先，将插件Prefabs目录下的Exploder预制件拖拽至层级视图。然后从检视面板中调整爆炸相关的参数，例如碎片的数量等等。这一步也可以使用代码完成。为需要爆炸的目标对象添加ExploderOption脚本。接下来只需在任意脚本中调用ExplodeObject函数即可。 Exploder还提供了FPS游戏示例场景，包含了FPS游戏的基本机制如瞄准、换武器及扔手榴弹等等。该插件同样支持移动平台，但建议针对不同机型使用不同的配置。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/9771 TENKOKU Dynamic Sky TENKOKU DynamicSky是用于实现高度精确天气系统的插件，可以按照24小时循环实时动态设置天空场景。支持动态调整大气属性，例如白天与夜晚的天空亮度、雾效距离、云层密度、灰蒙程度、降雨、降雪及彩虹等等，几乎所有天气相关的属性都可以直接进行设置。 TENKOKU Dynamic Sky提供了很方便的编辑面板，所以不需编写代码也能轻松使用该插件。首先将Prefabs目录下的TenkokuDynamicSky预制件拖拽至场景，放置于(0,0,0)的位置，然后在相机上添加特效脚本Tenkoku Fog等，还可以根据实际需求加入其它的特效脚本。 TENKOKU所有的核心代码都位于TenkokuModule脚本中，上述提到的各种天气属性也可以通过脚本进行修改。但请注意，该插件暂不支持移动平台。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/34435 Procedural Lightning (2D and 3D) Procedural Lightning用来实现各种闪电特效，当然也可以生成游戏所需的普通线性特效。该插件比较简单，仅需一个DrawCall即可完成所有的淡入淡出、生长及发光等效果。整个渲染在GPU上完成，相比CPU渲染效率更高，并且支持一些配置较低的移动设备。 使用该插件也非常简单，将插件核心脚本LightningBoltScript加入场景中的对象，设置好闪电及发光的材质，指定起始位置与结束位置，调整一些闪电属性，剩下的就交给ProceduralLightning来完成。LightningBoltScript提供了非常多的属性设置，包括闪电路径数量等等都是可以预先设置的，调整这些参数让闪电达到理想的效果。 Procedural Lightning同时支持2D及3D，其中也提供了19种不同的示例，除了常见的2D闪电，还演示了立体闪电特效。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/34217","link":"/blog/2019/05/17/Unity插件/Unity酷炫特效脚本插件/"},{"title":"VR效果神器，Unity精品相机插件","text":"今天向大家推荐几款强大易用的相机插件，可以用于录制高清VR游戏视频、实现各种炫酷的相机特效，甚至有便利实现移动VR环境的移动解决方案。 Helios Helios是用于录制高清流畅视频的插件，不但支持普通的2D视频、3D视频，而且有适用于VR环境的全景视频，还可以同时录制音频。Helios利用特别设计的着色器来获取场景截图，并将这些图片转换为适用于各种3D及全景视频平台所需的视频格式。 目前Helios仅支持在Unity编辑器模式下使用。相比其它的全景视频解决方案，Helios功能更加完善，而且支持主流的VR头盔包括Oculus、GearVR、HTC Vive、GoogleCardboard。同时，全景视频平台如Facebook和YouTube。Helios可以直接导出6种不同质量的视频，最高支持90FPS的8K全景视频。当然，它还可以导出高清的GIF、JPEG或PNG图片。 使用Helios也非常简单，其中已经内置好了用于录制不同视频的预制件（Prefab），并包含所有必需的脚本，只需将这些预制件添加到场景中，再简单进行一些设置即可。以录制3D视频为例，只需将Helios3D预制件拖拽至场景，然后在检视面板中设置Helios脚本的参数，以选择视频类型、质量、特效及存储目录等。剩下的就等Helios自动完成即可。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/63643 Camera Transitions CameraTransitions可用来实现一系列的相机变换特效，适用于各种画面切换效果，包括缩放、盒式切换、渐变、闪现、翻转、翻页、折叠、抖动、线性模糊等等。CameraTransitions几乎可以满足所有的全画面变换需求。 Camera Transitions需要硬件GPU支持Shader Model3.0及以上版本，基本上只要是2009年以后面世的GPU就没有问题。有些效果在移动设备上可能消耗比较大，例如翻页。类似的注意事项都已标示在插件网页上，使用时可以作为参考。 使用Camera Transitions首先需要在场景中新建一个空GameObject，然后为其添加Camera Transitions脚本。CameraTransitions脚本会对所有特效做全局设置，如自动或手动切换、更新频率、特效的范围等。 针对所有特效的使用代码，作者也给出了示例，只需调用一句代码即可。以圆圈扩散特效为例，只需调用DoTransition函数即可，其参数分别表示变换类型、原始相机、目标相机、变换时间以及一些可选的传入参数： 上面的代码可实现如下效果： 而除了代码调用外，还可以利用CameraAssistantTransitions组件直接在检视面板中进行设置，免去手动编写代码的步骤。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/36055 Mobile VR Movement Pack Mobile VR MovementPack提供了5种移动VR环境下的移动方案示例，包括路径点系统、导航网格、摇杆控制、自动行走及视线控制（向下看行走，向上看停止）几种方式。每个都提供了示例场景，可以支持GearVR、Google VR、Cardboard及Daydream平台。 使用Mobile VR Movement Pack非常简单，插件提供了代表不同移动方式的预制件，只需将这些预制件拖拽至场景，然后删除场景中的其它相机即可。 插件还包括一系列用于实现各种不同效果的简明脚本。例如，添加了VRWalkableSuface脚本的对象会被导航网格视为“可通过的”，以便找到正确的路径。VR Waypoint脚本则用来设置路径点。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/69041","link":"/blog/2019/05/17/Unity插件/VR效果神器，Unity精品相机插件/"},{"title":"三款Unity插件带您玩转人脸识别与模拟","text":"若想让游戏或电影中的虚拟角色表现得更加真实，面部表情是至关重要的。人脸识别技术则借助真人表演来为虚拟角色赋予丰富的表情与面部动作，小至皱眉带动眼部肌肉的抽动，大致对话时嘴唇的张合，均可通过人脸识别技术来实现。 本文为大家介绍三款在Unity中实现人脸识别的插件，再结合Unity引擎的实时渲染功能，轻松定制出次世代的虚拟角色。 NaturalFront 3D Face Animation Plugin Pro 如果想要构建三维人脸模型，却没有Kinect这类动作捕捉硬件，别担心，Unity可以用一张照片帮助您实现人脸模型构建。NaturalFront 3DFace Animation PluginPro可以帮您以FBX格式导出自定义的高质量3D头部模型及逼真的动画，能为动画设计师与爱好者们节省大量建模和动画制作的时间。 整个建模、生成动画及导出FBX文件的过程均可在Unity编辑器中完成。您也可以根据需求快速调整面部表情及唇部动作。虽然功能如此强大，但构建模型的过程并不复杂。首先需要上传一张人脸的照片，按照参考图选定人脸的标志点，例如眼角、嘴角、鼻翼等。接下来就是等待计算的过程，您会得到一张如下图所示的人脸模型。 所有步骤仅需动动鼠标或滑动建模工具栏的滑块即可完成，实现自定义表情与嘴型，无需进行骨骼绑定、设置关键帧或动作捕捉。 下载链接： https://www.assetstore.unity3d.com/en/#!/content/82488 Cloud Face Detection 这是一款免费的AI脚本插件，它非常适用于刚接触Unity人脸识别，想在短时间内完成一些好玩应用的开发者。Cloud FaceDetection包括两个易学易用的人脸识别Demo，可以直接应用到您自己的Unity工程中。 该插件不仅可以检测人脸，Demo中还包括了性别、年龄和微笑程度评估。这个功能的意义在于，您可以有根据地在运行时调节游戏进度，追求最佳的用户体验。它支持多人脸识别模式，甚至支持识别侧脸。该插件使用了MicrosoftAzure 的识别服务，同时支持Unity Personal个人版与Unity Pro专业版。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/54489 Fruit With Faces 3D Pack 如果您想为自己的游戏塑造一些可以引起玩家共鸣的角色，就需要对游戏角色的面部表情下功夫。Fruit With Faces 3DPack这款插件为您提供了37种常见水果与蔬菜Q版模型，以及12种可爱的表情动画，包括困惑、快乐、古怪、生气、震惊、悲伤等常见的人类表情。 _ _ 以苹果为例的12种表情动画 模型虽然小巧精致，但也极具灵活性，您可以根据需求任意组合，甚至上传其他自制的模型，为它们赋予特定的表情。因为水果模型与表情模型是相互独立的预制件，使用起来也十分方便。 _ _ 独立的表情模型和蔬果模型，便于分开使用 素材具有1024x1024的精美手绘纹理，且提供.blend文件便于您的再次编辑。 快来试用一下，一起来打造拟人化的游戏角色吧！ 下载地址： https://www.assetstore.unity3d.com/en/#!/content/34854 总结其实本文所介绍的人脸识别与模拟插件有很大的延展空间，您可以借助它们为自己的应用增加崭新的内容与炫目的效果，还可以在此基础上进一步完善与修改，与现有的项目进行集成。借助上述插件，您可能实现属于自己的人脸模型和人脸识别解决方案，或者塑造拟人化的模型。 如果您有好的案例，不妨成为AssetStore资源商店的发布者，将您的创意与来自世界的开发者分享，为您的游戏开发提供动力。您可以点击【阅读原文】进入Unity官方中文社区(forum.china.unity3d.com)了解更多相关内容和精品插件。","link":"/blog/2019/05/17/Unity插件/三款Unity插件带您玩转人脸识别与模拟/"},{"title":"你的项目和大作只差一个插件的距离","text":"The Amazing Wireframe Shader 在开发中我们常常希望通过非真实感渲染达到一些有趣的效果。在此，我们为大家介绍这款效果不错的插件：The Amazing Wireframe Shader。 如上图所示，它能做出线绘制和原始的实体之间过渡的效果。它不需要DX11支持，同时，它可以在Mobile上进行高效地渲染，并且支持Skinned Mesh，Anti-atlasing，Lightmap和Shadow等功能。大家可以轻松在插件中调整参数来调整最终的美术效果。 Realistic Effects Pack 眼下，大家的游戏在移动设备上的画面愈发精美华丽，不少已经媲美端游。那么是否也有一些高效的工具能为我们提供这样的效果呢？在此，我们推荐RealisticEffects Pack给大家，该功能在移动端上表现非常高效。 下图是一些最终效果图： 1、 背景扭曲的效果，我们测试后在红米2上能顺利跑到50帧以上。 2、 火焰喷射的效果，同样，红米2上能顺利跑到50帧以上。 其他效果： 美术设计师可以根据需要发挥更多想象力，实现不同的绚丽效果。 See-Through System 该插件能协助开发者高效便捷地改变物体被遮挡时的透明度，实现透视效果。这在RPG、策略类、射击类游戏中非常受用，因为我们希望能在画面中看到敌人若隐若现的身影。 以上从左往右分别为：透视效果、线绘制效果和红外图效果图。 Aspect and Resolution Master 由于移动设备种类过多，要手动调整画面的分辨率显就得过于繁琐，而该插件就能帮助开发者在Editor去调整Revolution和它的界面。XARM目前支持100多款主流的机型，将移动设备的分辨率贴合一起。如下图，开发者不用发布到真机，就能直接在Editor下查看效果，特别是在查看UI的时候非常方便。 该插件提供以下两大功能： 1、 1:1px 设备的物理真实分辨率尺寸。方便开发者查看内容布局、特别是UI在不同分辨率上是否有问题，查看项目的内容是否清晰，是否会出现拉扯纹理等问题。 2、 适配效果缩略图 。方便开发团队快速找到出现问题的UI。 ** ** Texture Overview Pro 通过该插件我们可以看到项目中每个纹理的具体使用信息。其中最为主要的是内存使用情况、打包后的纹理占据的大小、运行的时候各个纹理在内存中的大小，以此来检测纹理的格式、尺寸是否有问题，而不需要在Profiler里每一帧查看。 ** ** ** ** Build Report Tool 我们在项目开发中经常会在前期导入大量的资源，那我们如何能主动去检测并剔除这些多余的资源呢？该插件恰好能满足我们的需求，其原理是项目在编译的时候，会在Editor里有个Log，该插件能够读取该Log并分析哪些用了或没用。 如下图是个该插件对项目的整体情况，包括编译的时间，大小，包含的内容，Top10等信息。开发团队可以直接在发布选项中查看用了哪些资源，被引用在哪里，没用使用的资源还有多少等，并进行选择、删除等操作，一目了然。","link":"/blog/2019/05/17/Unity插件/你的项目和大作只差一个插件的距离/"},{"title":"借助Unity特效插件创造史诗级大作","text":"本文为大家推荐几款Asset Store资源商店中流行的特效插件，帮助大家改善特效制作流程，提高开发效率，让您的作品脱胎换骨，成就史诗级大作。 游戏的特效表现对整个用户体验有着至关重要的影响，除了需要炫酷的视觉效果之外，还得保证整个特效的流畅度。游戏开发过程中，特效制作会涉及到美术与程序之间的磨合，讲究的是质量与效率的平衡。以下三款插件十分适合用于制作特效，一起来看看吧。 SE Natural Bloom &amp; Dirty Len 该插件简称为SENBDL，是一款用于在Unity中实现散光及脏镜头特效的插件，可以模拟相机镜头内部的表面对光的散射，渲染出逐像素的脏镜头效果。请注意，该特效不支持移动设备。 现实世界中根据光照亮度不同，散射光也会有差别，但SENBDL采用了另外的做法，让散射光与光照亮度无关。SENBDL通过在场景中生成一些大型的，完美而流畅的高光，以便明亮物体可以被更明晰地呈现出来。这种做法也要比常规的散光特效带来的消耗更小。 SENBDL适用于线性颜色空间的HDR场景，也能完美结合基于物理的着色。该插件生成逐像素的特效，并且对场景中所有可见对象均生效，无关场景复杂度。SENBDL包含16个高清的脏镜头纹理，指定光在表面的不同散射方式。还包含一些自发光与粒子着色器，用于创建无与伦比的高光效果。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/17324 Camera Filter Pack Camera FilterPack是用于Unity项目的相机滤镜特效合集，可以简单理解为供游戏使用的“美图秀秀”。每个特效均以脚本形式提供，使用方式非常简单，只需将所选特效脚本绑定到场景中的主相机上，即可即时改变整个场景的视觉效果。 该插件现已包含300多种全屏后处理特效，因为都是脚本，所以也便于开发者自行调整，在原有基础上打磨出适合自己场景的特效。其中部分特效包括：3D矩阵、3D扫描、3D雨雪、3D黑洞、铅笔画、复古电视机等。轻轻松松就能让游戏呈现出电影大片即视感。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/18433 Volumetric Fog &amp; Mist 这是一款用于在Unity中制作体积雾的插件，支持定义各种浓度的逼真雾特效，来衬托场景的氛围。该插件以视觉特效及灵活性为重，可以借用光照及发光特效来调整雾效区域及云层。 Volumetric Fog &amp;Mist提供了大量预置配置，方便开发者快速设置雾效，其中包括：薄雾、带风的薄雾、低云、云海、地表雾、湖面雾、浓雾、烟雾及沙尘暴等特效。另外还可以自定义雾效的各种属性，例如浓度、噪声强度、规模、透明度及反射度、颜色、阈值及强度、风速与方向、湍急气流等等。 体积雾可以指定雾效出现的区域，并自动改变雾效的透明度。该功能在游戏中非常实用，可以根据玩家靠近目标地点的距离来实时控制雾效显示或隐藏。该插件利用Unity标准着色器来控制雾效的透明度及渐变渲染，支持与透明物体共同渲染而不影响对象层次。还支持基于深度的模糊来加强场景光照的散射效果。 该插件提供了10多个示例场景，可以通过这些场景来了解插件的具体功能。使用插件的方式也很简单，只需在场景主相机上添加VolumetricFrog脚本，然后在检视面板中调整雾效的各个属性即可。 下载地址： https://www.assetstore.unity3d.com/en/#!/content/49858 总结本文为大家推荐的几款特效插件均为全屏效果，比较适用于大型游戏场景，但不建议用于移动设备。有了这些特效插件的帮助，美术设计师可以轻松调整出适用于游戏场景的特效，也便于开发者进行进一步优化。这三款特效插件也是AssetStore资源商店中久经大多数开发者实战考验的插件，希望对大家有用。我们还会在Unity官方中文社区（forum.china.unity3d.com）为大家分享更多加快Unity项目开发流程的优秀插件，请保持关注。","link":"/blog/2019/05/17/Unity插件/借助Unity特效插件创造史诗级大作/"},{"title":"好插件让你事半功倍！","text":"Mesh Baker我们在项目开发的时候经常会大量使用大规模的Mesh，导致Draw Call过高。而MeshBaker扮演了网格烘焙器的角色，其工作原理是将网格和材质合并，从而降低渲染的Draw Call。 下面，我们就来谈谈使用方法： Texture Packing 我们常常会遇到角色网格相似，但是纹理繁杂细碎的情况。这时我们需要把纹理合并在同一张图上。纹理拼合的操作面板如下图所示：选择不同的网格来拼合，TextureBaker自动分析其Shader，Size等属性，最后点击Bake Material Into Combined Material，即可完成拼合。 Mesh Batching 在纹理拼合后已经形成为一张图片了，这时候我们需要进行Mesh拼合，即使用MeshBaker来烘焙网格。在此，我们新建一个新的GameObject，点击Bake就把3个Mesh烘焙在一个Object上了。 同时，在进行了这两步之后，我们会发现Draw Call上的变化。 合并前 ** ** 合并后 不难发现，合并前12个Draw Call，合并后只有2个，从而在一定程度上降低渲染压力。 对Skinned Mesh进行拼合 Unity引擎无法原生支持蒙皮网格的Draw Call Batching，而Mesh Baker能将多个Skinned mesh合并。 经过合并后，人物的材质已经相同，所以我们能在上图中看到这些角色只产生了一个Draw Call。同理，即使再加入更多的角色也能合并成非常少的DrawCall，从而减少渲染耗时。 除此之外， Mesh Baker还支持将Mesh Renderer与Skinned MeshRenderer一起合并。比如开发中常用到的道具如帽子、剑等，使得角色在换装时也只产生一个Draw Call，非常实用。 在使用skinnedmesh时有几个注意点： 合并后将原始模型的Bone保持Active； Disable原始模型的Skinned Mesh Renderer； 确保原始的Animation始终在运行； 如果需要Mesh Rendering与Skinned Mesh 一起合并，则需要保证在其在同一张Texture Atlas和Mesh容器中。 SimpleLOD 除了MeshBaker，另一个插件SimpleLOD也比较适合大规模场景的制作开发。在处理多人在线的项目（如MMO游戏）时，按照我们以往的优化方法是尽可能降低DrawCall和减少渲染消耗，在远处使用低级LOD，在Run-time时根据相机距离切换合适的LOD，使得在手机性能有限的情况下尽量渲染更多的角色，达到更好的效果。 而SimpleLOD恰好可以满足这一点，除了同样拥有Mesh Baker所具有的Mesh合并、Atlas烘焙等功能，它还能提供Mesh的简化（MeshBaker无法提供），并对动态蒙皮网格进行了很好的支持。该插件可在Run-time和Editor中都可以使用，同时开放了源码，大家可以根据项目的实际情况而作修改。 ** ** 我们拿以下原始模型来举例： 打开插件后有如下一些选项：点击Merge child meshes 我们知道Unity支持的网格顶点数不能超过65536，但是当我们把很多物体合成一个Mesh时很可能会超过这个限制。而这个插件会针对这种情况进行自动处理，可以看到下图中的两辆车Merge后成Mergedpart1和Merged part2 。 烘焙Atlas 下图是Texturepacking，根据模型的Material自动把不同类型的Texture分类显示出来，在合并的时候，会自动把同类型的Texture合并。 合并之后的效果对比：Draw Call数量由原来的136降至24个。 选择了模型之后，点击Simplify mesh，它会尽可能在保持原样的基础上简化网格。如下图，汽车模型的网格面片数从六万多顶点数减少到了两万七。 同时，它也能自动生成不同级别的LOD。这里有6层LOD（从大到小），点击BakeLOD后它会自动计算，不需要大家手动操作。我们可以通过更改脚本达到希望的效果。 如下就是使用了SimpleLOD后的效果。该插件最大的特色即是对Skinned mesh动画角色网格提供了很好的支持。 以上是我们今天推荐的插件，但愿能在资源优化中祝你一臂之力。今后我们将会结合以往的行业服务经验，为您推荐更多高效的开发利器，尽情关注！","link":"/blog/2019/05/17/Unity插件/好插件让你事半功倍！/"},{"title":"在Unity中使用UFPS创建第一人称射击游戏","text":"Unity Asset Store资源商店中总有很多功能强大的插件让开发者事半功倍，例如UFPS : UltimateFPS因其具备的平滑控制、流畅实时生成的相机和武器动作的功能，而受到广大开发者的欢迎。本文由Unity大中华区技术经理马瑞为大家介绍一下UFPS :Ultimate FPS这款插件对创建第一人称射击游戏的贡献。 UFPS: Ultimate FPS是什么？UFPS，即 Ultimate FPS，是由Opsive(FPS)开发的模板项目，这个项目对初级或中级开发者来说是必不可少的，因为它可以帮助您提高FPS游戏运行效率。它是Unity AssetStore中维护时间最长的资源之一, 在整个生命周期中，得到了来自开发者的诸多好评。已经有很多游戏使用了这个模板，例如： Time Rifters Slender: The Arrival Rambo (the mobile game) Shark Attack Deathmatch 2 Gone Home Tacoma Grave Reflections Ascend Surviving Pangea 强大的功能UFPS: Ultimate FPS有一些很有用的功能： 基于物理的动画 — 让流畅的枪击和相机抖动等动作更加真实 鼠标平滑和加速 — 您可以选择不同的鼠标移动模式，这样在为不同类型的角色，如机甲，士兵等开发角色控制器时，可能会很方便。 支持本地Oculus VR — 在日益增长的VR市场环境下，开发者将VR结合进来是被很多人看好的。 拥有机械动画播放器的全身感知 —含有一个全身模型和动画。生成地形(Terrain)或可步行空间后，您可以指定曲面的材质，并将不同的声效和粒子分配给不同的材质。 手榴弹，爆炸系统和掩护(Cover)支持 — 大多数现代FPS游戏允许玩家使用手榴弹。您可以借助UFPS创造全新爆炸型手榴弹并且在躲在墙后以免受伤。 具有方向攻击指示器和血液飞溅效果的HUD — 当玩家受到伤害时，这个HUD会变得“血腥”。此外，箭头可以帮助我们辨别我们在哪个方向被攻击。 地震、冲击波、Boss挑战和相机反馈 —UFPS为开发者提供了一套漂亮的相机抖动。他们被某些事件触发，例如：玩家从高处跌落，或者附近有一个强烈的爆炸/地震。 库存和物品捡起系统。 高级表面碰撞系统 — 如果您射击沙子或草地，会发现有不同的粒子产生。 Spawnpoint系统与智能障碍检测。 基于键盘，鼠标或触摸屏的UFPS输入管理器 — 允许在运行时重新绑定控制器。 拆除系统 — 玩家销毁的对象(Object)将被新对象(Object)替换。 交互系统 —门，平台，触发器，开关，抓取和投掷东西的交互。 表面系统允许通用和强大的物理模拟 高级移动平台支持 慢动作模式 — 像Max Payne游戏中让时间变慢 支持Unity Pro专业版图像FX 支持反欺诈工具箱ObscuedTypes 完整且良好注释的C＃代码 100多页详细的在线学习手册 下载地址： https://www.assetstore.unity3d.com/en/#!/content/2943 演示场景下面我们介绍几个演示场景，包括简单场景和完整项目，以便更清晰地了解UFPS的功能。 Clean Scene 这个场景不太复杂，含有地形(Terrain)和第一视角摄像机控制器。您可以尝试跌落悬崖，看看相机如何对这个事件做出反应。 ** ** Demo Scene 1 这个场景包含很多例子。第一个例子演示了在使用UFPS时可以实现多少不同的效果。您可以轻松实现西部牛仔风格的游戏、现代FPS、太空宇航员、炮塔、狙击步枪、甚至控制机甲！如下图所示。 第二个示例为您展示了可以实现的不同的相机抖动，比如地震，Boss挑战，进攻的炮兵和撞毁的飞机。它们其中的任何一个事件将带来不同的相机抖动。您可以在后面即将介绍的SkyCity演示中了解到：当您在玩家的附近投掷手榴弹时，看到类似的效果如下图所示。 每种类型的游戏需要的鼠标控制方式略有不同。例如使用手枪相对于使用狙击步枪时，可能想要实现不同的效果。从下面的例子中您可以了解到如何实现不同的鼠标模式，并在游戏视图中看到不同的效果。 您可以改变持有的武器风格，比如Old School和Modern Shooter等，如下图所示。 ** ** Demo Scene 2 这个场景的目的是展示基于物理的摄像机动画如何对不同的事件作出反应，如掉下屋顶，从高处跳跃等。我们很期待看到当玩家附近发生爆炸以及当玩家用他的头撞到墙上等情况发生时，相机会作何反应。 ** ** Demo Scene 3 这个演示场景看起来更像一个完整的项目。您可以收集武器，用步枪、手枪或者替换其他武器进行射击，爆炸的对象可能会造成损害，并降低您的生命值。您还可以在场景周围抓取和移动对象，销毁一些对象。当您进入白色气泡，就会切换为慢动作模式，时间将减慢几秒钟，产生Matrix/Max Payne效果。 ** ** Sky City 最后的演示是一个完整的项目。在这个场景中，你将围绕建筑物攻击敌人的塔楼。玩家可以藏在墙后面躲避子弹。您可以在猎枪，步枪，手枪和手榴弹之间切换，体会到在一个完整的FPS游戏中，不同的系统是如何协同工作的。 总结如果想要建立第一视角射击游戏，UFPS是一个非常好的起点。它的一系列有用的元素可以被用来构建游戏，例如将UFPS作为坚实的框架，并添加游戏特定的逻辑和资源后，就可以变成一个完整的游戏。不过请记住，插件本身不是最终产品，您仍然需要在资源和代码方面之下一些功夫，来完善您的游戏。想要了解更多技术相关内容，请访问Unity官方中文社区(forum.china.unity3d.com)。","link":"/blog/2019/05/17/Unity插件/在Unity中使用UFPS创建第一人称射击游戏/"},{"title":"实用资源报告工具Unity-AssetsReporter","text":"Unity Global Support部门制作了一些实用的小工具免费供大家使用，此前已为大家介绍过批量处理资源的AssetAuditing以及批量清理资源的小工具AssetCleaner， 今天要给大家推荐的是一款名叫AssetsReporter的插件，可以辅助开发者管理几类Asset的导入设置并发现可能存在问题，另外还提供了AssetBundle的资源与依赖查看功能。 项目介绍Unity对导入项目的资源如Texture、Model和Audio等都要根据其导入设置生成新的资源文件，以供之后打包使用。开发者一般需要根据发布平台的性能、内存、包体占用等方面的需求，对资源采取特定的导入设置，因此，保证所有资源的导入设置都正确配置是比较重要的一环。 AssetsReporter提供了对Texture、Model和Audio这几种常用资源的导入设置进行检查的功能，其生成的网页报告可以在浏览器端通过勾选特定的设置选项来搜索某类资源，以确定资源是否都正确配置。另外对于Resources文件夹及AssetBundle资源也提供搜索检视功能（鉴于Resources对SplashScene时间影响较大，Resources检视功能主要方便让开发者完全使用AssetBundle来取代其）。 使用方法 点击菜单栏Tools-&gt;AssetsReporter，弹出AssetsReporter窗口，然后点击对应类型资源名称下的Report按钮生成报告（每次对资源进行修改后需要重新生成报告），点击Open可以打开上次生成的报告，报告会以网页的形式在浏览器端展现。 报告类型 Texture Reporter 此报告管理Texture的导入设置，设置好搜索条件后点击Search后会出现符合条件的资源，可以预览图片并展示此Texture的一些常用属性。较常关注的设置包括压缩格式是否适合以及分辨率是否2的N次幂等。 Model Reporter 此报告管理Model的导入设置，可以显示搜索结果的各种常用属性，包括顶点数，动画类型及包含的动画列表等。较常关注的设置包括mesh是否优化，Rig设置以及mesh是否Read/WriteEnable等。 Audio Reporter 此报告管理Audio的导入设置，可以预览音频并展示常用的属性。较常关注的设置包括压缩格式是否适合，加载方式是否适合等。 AssetBundle Reporter 此报告提供AssetBundle的可视化检视界面，可通过资源名称搜索包含其的AssetBundle文件，并查看AssetBundle中打入的资源以及依赖的文件或者其他AssetBundle。 Resources Reporter 此报告主要根据勾选的资源类型来搜索并显示项目中Resources文件夹中的资源，方便开发者确认是否仍存在无需放入Resources文件夹的资源。由于Resources中文件需要构建的内存映射结构对SplashScreen的时间影响较大，除了常驻在项目内存中的资源，Unity建议开发者仅仅把Resources文件夹作为方便制作demo的工具，项目打包的时候还是要使用AssetBundle来做资源的动态加载。","link":"/blog/2019/05/17/Unity插件/实用资源报告工具Unity-AssetsReporter/"},{"title":"屏幕特效插件分析","text":"FxPro: Bloom&amp;DOF, Mobile-Ready FxPro是一款历史比较悠久的特效插件，从大部分开发者的反馈来看为当前功能较全、性能较好Unity屏幕特效插件之一。FxPro支持多种常见的屏幕特效，例如Bloom、景深（Depth-of-Field）、色差效果（Chromatic Aberration）、镜头形变等。 FxPro的使用是通过Component-&gt;Image Effects-&gt;FxPro为需要的摄像机添加FxPro组件。 FxPro集众多特效于一身，具有非常多的可调参数。我们这里选取一些重要的设置选项和某些特效的参数进行简单说明： 1. Quality FxPro允许我们为不同的目标平台设置不同等级的画面质量，支持High、Normal、Fast、Fastest四种等级。 2. Half Resolution 当我们选择了Fast或Fastest等级时，就会出现该选项。如果在移动设备上仍然有性能问题，可以选择开启该选项来降低计算特效使用的分辨率，进一步提高效率。 3. Bloom Visualize：调试模式，勾选该选项可以让我们看到场景中的哪些部分会被Bloom。 Bloom Tint：Bloom时使用的颜色。 BloomThreshold：设置计算Bloom时的阈值，当屏幕像素的亮度超过该值时就会把该像素加入到Bloom的计算中。因此该值越小，屏幕看起来就越“梦幻”。 Bloom Intensity：Bloom的强度。注意，不同设备上的真实强度会有所不同，我们可能需要根据当前设备在脚本里手动设置该值的大小。 Bloom Softness：调整Bloom效果的渐变程度。该值越高，模糊程度越大。 4. Depth-of-Field Visualize：调试模式，勾选该选项可以让我们看到会聚焦到场景的有哪些部分。 Blur COC：在物体的边界处增强效果。 Auto-Focus：让摄像机自动对焦到屏幕中央的物体。需要注意的是，我们需要为可以对焦的物体添加碰撞体（Collider），否则自动对焦功能无法实现。当勾选了自动对焦后，还可以设置对焦时的Layer和对焦速度。 Target：当没有开启自动对焦时，可以把需要对焦的物体拖拽到该选项上。 Focal Length Multiplier：设置焦距长度的系数。 Depth Compression：压缩深度缓冲。 DOF Strength：调整景深模糊的半径大小。该值越高，非对焦区域的模糊程度越大。 Double Intensity：让景深效果更加明显。该选项在开启时对性能会有影响。 真机测试手机：三星 Galaxy S4, iPhone 6 测试场景：如下图，Quality选择最低等级Fastest，并勾选HalfResolution降低分辨率。我们测试了单独开启Bloom和景深效果时的真机性能。 ** ** 下图是三星 Galaxy S4上只开启Bloom特效时的Profiler截图： ** ** ** ** 下图是iPhone 6上只开启Bloom特效前后的GPU Report： 使用前 ** ** 使用后 ** ** 下图是三星 Galaxy S4上只开启景深效果时的Profiler截图： ** ** ** ** 下图是iPhone 6上只开启景深效果前后的GPU Report： 使用前 ** ** 使用后 可以看出，分辨率对性能的影响非常重要。开启了Half Resolution的两种特效在真机上表现都还不错，可以考虑在中高端设备上选择开启部分特效。 Beautify Beautify是一个轻量级的屏幕特效插件，它的主要功能是加强细节表现（原理是在深度纹理上进行边缘检测后进行锐化操作），此外还提供了对饱和度、对比度和亮度的调节功能。 该插件的使用方法非常简单，直接在Camera上添加Beautify组件即可： Beautify提供的参数有： 1. Quality 共两种选项，Mobile和Desktop，区别是Desktop会采样每个像素周围4个额外的像素点（上下左右），而Mobile只会采样额外两个（上下）。因此Mobile在性能上要比Desktop更高。 2. Preset Preset中提供了4个提前调好效果的参数设置集合：Soft、Medium、Strong和Exaggerated。我们可以在此基础上自定义（Custom）参数或关闭效果（Disable）。 3. Sharpen 画面细节的锐化程度。Beautify提供了4个参数来进一步调整锐化效果： Min/MaxDepth：定义了效果作用的深度范围，任何不在该深度范围内的像素都不会受到锐化效果的影响。这个范围允许我们实现一些类似于景深的效果，即只在特定物体周围加强细节。 Depth Threshold：当某个像素周围的深度差超过这个值时，锐化效果会减弱。 Luminance Relax：类似上面的DepthThreshold，当某个像素周围的保护度差超过这个值时，锐化效果会减弱，从而保护那些具有较高饱和度的像素不会被过分锐化。 Clamp：定义像素颜色的调整范围。 4. Dither 控制Dither程度，Dither可以用于移除由于渐变产生的一些明显的渐变带问题。 Min Depth：只会移除深度值超过该值的像素产生的渐变带。比如当我们只想移除天空盒子上的渐变带问题时，可以把该值设置0.99。 5. Saturate 调整画面饱和度。 6. Contrast 调整画面对比度。 7. Brightness 调整画面亮度。 真机测试手机：三星 Galaxy S4，iPhone 6 测试场景：和之前相同的测试场景，Quality选择最低等级Mobile。 三星 Galaxy S4使用插件后的Profiler截图： iPhone 6使用插件前后的GPU Report（Xcode） 使用前 ** ** 使用后 根据如上真机测试，目前我们建议只考虑在高端iOS机上选择使用该插件，而不在Android机上使用。","link":"/blog/2019/05/17/Unity插件/屏幕特效插件分析/"},{"title":"插件改造Unity为建模利器","text":"随着许多优秀开发者的大力支持，积极地将优质内容发布到Unity资源商店上，AssetStore俨然已经成为一座宝库。我们前面已经为大家分享多种类型的插件资源以及编辑器扩展工具，包括脚本编程工具等。今天继续为大家介绍三款建模工具，通过它们，您可以直接把Unity当作Maya或3DMax来用了。 Realtime CSG RealtimeCSG用于在Unity中快速创建3D环境。由于是在Unity编辑器下直接进行的操作，所以可以很方便的进行迭代调整。通过它能够进行基本3D建模工具的大部分操作，例如创建及编辑几何体、自动为几何体添加碰撞体、网格对齐及旋转、导出为FBX等等。 将Realtime CSG插件导入Unity中，即可看到Scene视图变为下图的样子： 这就是Realtime CSG的操作界面了。Edit Modes包含了RealtimeCSG提供的5种编辑模式，每一种模式都有单独的操作，显示在左下角。界面下方的工具栏按钮用来控制Unity网格是否显示，网格是否按X、Y、Z轴对齐，对齐的方式与角度，是否以线框模式渲染场景，是否显示辅助面以及最后的重做场景按钮。 为了更符合建模师的操作习惯，可以首先将Unity编辑器视图切换为4 Split模式，同时显示4个窗口： 然后您可以按照自己的操作习惯，分别设置四个视图的视角与渲染模式。对于正交模式的2D视图，可以关闭一些特效渲染： 使用Realtime CSG自带的线框模式，可以将场景切换为如下显示效果： 基本操作就是这些了，下面来看看实际建模的效果： 下载地址：https://www.assetstore.unity3d.com/en/#!/content/69542 BuildR Procedural Building Generator 这是一款专门用于在Unity编辑器中生成建筑的插件。BuildR简化了很多操作，基本上只需点击按钮，即可利用插件的生成功能直接创建出高楼大厦。 导入BuildR插件后，依次点击菜单项GameObject &gt; Create New BuildRBuilding新建一个建筑对象，在层级视图选中新建的对象，可以看到检视面板的脚本如下： 这个脚本涵盖了所有的创建操作，点击其中一个按钮，即可新建地板或建筑。下面就进入了编辑模式，此时脚本显示如下： 看到这里就您应该就明白了，真的只需要点击就能直接生成并编辑建筑，包括添加或移除墙壁、顶点等。上面的一排按钮分别用来调整建筑结构、纹理、表面贴花、屋顶设计、建筑细节、建筑内景及设计，还有生成及导出设置。BuildR支持将建筑数据以XML形式导出。 下载地址：https://www.assetstore.unity3d.com/en/#!/content/7292 ProBuilder Advanced ProBuilder同样是用于Unity编辑器中的建模工具。该工具最早于2012年发布，历经多次迭代，现在的版本已经非常成熟。迄今为止已有不少使用该插件制作并已成功的上线游戏，包括《Tinertia》、《SUPERHOT》及《Republique》等等，都是在Steam上广受好评的游戏。 ProBuilder同样支持快速创建，并直接点击播放按钮来预览效果，能够自动生成碰撞体和UV，还支持一些高级操作如UV展开、光照贴图设置及优化等。依次点击Tools ProBuilder &gt; ProBuilder Window打开ProBuilder编辑器，界面如下： 使用方式也很简单，点击条目，即可对选中的对象进行相应的操作，过程清晰明了。以楼梯为例，点击New Shape或者使用快捷键Ctrl/Cmd +K，新建一个可以供ProBuilder编辑的Cube。ProBuilder已经内置了一系列常见的形状，选中Cube后打开ShapeEditor，在下拉列表中选择Stair即可创建楼梯： 下面来看看使用ProBuilder创建大型建筑内景： 另外ProBuilder还有免费版插件Probuilder Basic，包含一些基本的几何体操作，有兴趣的朋友可以先试用免费版尝鲜。 下载地址：https://www.assetstore.unity3d.com/en/#!/content/3558","link":"/blog/2019/05/17/Unity插件/插件改造Unity为建模利器/"},{"title":"新手必备的12款Asset-Store插件","text":"AssetStore中有不少来自Unity官方及其它发行商的优秀资源，无论是新手还是经验丰富的开发者，都可从中找到非常不错的选择。今天我们就为大家分享经过精心挑选的12款插件，其中有游戏开发教程、动画脚本插件、编辑器扩展工具以及着色器特效等等，帮助初窥门径的Unity新手快速上手游戏开发。 游戏开发教程Unity官方提供了大量示例教程，相关的资源以插件形式发布在AssetStore，免费供所有开发者下载并自由使用。这里为大家介绍几款非常适合新手学习的Unity官方插件资源。 Mecanim ExampleScenes是由Unity发布的一款免费资源，旨在指导开发者如何使用Unity的Mecanim及角色动画系统，项目中包含11个示例场景，分别演示了动画状态机、混合树、集群模拟、多层次IK、目标匹配、处理武器、跟随、预测及导航网格集成等。 另外还有一些大家都已经比较熟悉的游戏示例教程，提供了完整可玩的游戏，并且在官网也有详实的视频教程。这些教程包括Survival Shooter、2DPlatformer及2D UFO Tutorial。其中Survival Shooter需要Unity 4.7.1及以上版本，2D UFOTutorial则需要Unity 5.4.1及以上版本。大家可以从这三个资源中了解不同类型游戏的制作过程，搭配官网视频教程一起学习，效果更佳。 脚本插件看完游戏示例教程，了解游戏项目的基础架构之后，接下来就要学会并掌握游戏的各个细节技术点了。下面就先介绍一些简单易用的动画及网络脚本插件。 DOTween与iTween这两个免费的动画插件相信大部分开发者都比较熟悉，两个插件均以轻量级、高度优化且简明易用，而广受开发者喜爱。它们都可用于实现游戏对象的几乎所有动画效果，相对来说DOTween的功能则更加丰富。DOTween还支持组合动画、支持富文本动画、支持搭配协程一起使用等等。如果仅需简单的常见动画效果，iTween即可满足要求。 Photon也是非常成熟且受众广泛的网络插件，Pro版拥有更高级的功能，其免费版很适合初学者的入门学习及满足简单需求的使用。PhotonCloud的性能与可靠性结合Unity自带的网络系统，二者组合让开发者可以轻松实现游戏中的多人联网。该插件提供与UnityNetworking非常类似的PUN API， 非常容易上手。借助Photon Cloud也让游戏可以更方便地吸引来自全球各地的玩家。 EmeraldAI可用于实现游戏AI行为，利用其清晰的行为系统，可以设置AI为胆小、积极、攻击或防御等不同类型。该插件拥有简单易用的编辑器，开发者可以很便利地实现自定义AI模型。它还支持动态生成路径点，AI会按照这些路径点在适当的半径范围内执行相应的追击及巡逻等行为。EmeraldAI需要使用Unity 5.0.2及以上版本，支持第一人称及第三人称的相机类型。 编辑器扩展工具接触了游戏基本框架，也知道如何实现动画及网络等模块之后，接着就希望能帮助各位加速开发流程。借助AssetStore中大量优秀的编辑器扩展工具，Unity菜鸟可以有效加快项目开发及迭代速度。 Fungus是一款检视面板自定义工具，主要帮助标志不同角色对话在检视面板上显示的颜色，以更好更清晰地实现游戏角色之间的对话逻辑。该插件需要Unity5.0及以上版本，无需编写代码。Fungus能以标签来触发对话过程中的事件以及各种条件与逻辑处理，并且支持本地化，对相机、Sprite及音乐音效的控制。更重要的是它还集成了一些流行的动画插件，包括上面介绍的iTween及骨骼动画插件Spine。 Playmaker也是AssetStore中非常流行的编辑器扩展插件，支持可视化编程，可以用于快速创建游戏原型、AI行为、动画系统及交互式对象等等。使用了该插件并已上线的优秀游戏包括《炉石传说》、《Inside》及《DreamfallChapters》等等。使用过程中，无需任何撰写代码。其完全可视化的工作流程对设计师及开发者都非常友好。 ProBuilder Basic是在Unity编辑器中直接创建3D模型的工具，是此前介绍过的ProBuilderAdvanced的简化版，拥有创建基本几何体及一些复杂集合体的功能。 着色器为了让游戏画面与特效更加生动，最后向大家推荐一款着色器插件。 UBER - Standard ShaderUltra包含大量炫酷的着色器特效，支持视差映射技术，支持曲面细分、基于DICE模型的半透明、顶点混合绘制等等，还可用于实现动态天气如下雨或下雪。该插件需要Unity5.1.1及以上版本。","link":"/blog/2019/05/17/Unity插件/新手必备的12款Asset-Store插件/"},{"title":"精美实用的Unity场景资源","text":"今天为大家介绍一些AssetStore中非常受欢迎的场景资源，这些资源的共同点是尽可能利用最小的开销来实现更为壮观的场景，不仅能完美适用于PC端，对于移动平台也相当友好。 Greeble Kit R2 Greeble Kit是用于在Unity中制作科幻风场景的插件，拥有细节精致的多个场景和机器，几乎涵盖了科幻类场景所有内容。Greeble KitR2在此前的基础上增加了一些基于物理的材质和纹理，并提供了示例场景和预制件（Prefab）。 该资源包完全支持基于物理的渲染（PBR），并且共有109张4K分辨率的纹理。所有资源以预制件的方式提供，整个资源包有100多个预制件，按照规模分为大中小三个类型，可以方便使用者进行自由组合并按需调整。 每个预制件也是由小零件组成，可以很方便地对零件的方向、角度及大小进行调整来实现独一无二的金属科幻风场景。其中的材质都使用Unity标准着色器，也非常便于修改。 另外Greeble Kit R2还新增了机器人和大型机械装置，相信也能为大家提供不少灵感。 下载地址：https://www.assetstore.unity3d.com/en/#!/content/27563 Low Poly Series: Landscape 介绍了重金属，下面来看看小清新。Low Poly Series:Landscape是一款低多边形风格的资源包，配色清晰，模型简单，只用很少的资源就能创建出非常壮观宏大的游戏场景，并且对移动设备也非常友好。 该资源包共有168个不同的资源，包含多种不同的树木、叶子、植被、岩石及地形等等。最厉害的是所有这些资源共用2张纹理图，并使用Unity5默认的天空盒及标准着色器。所有的模型文件都提供了3D Max源文件、导出的FBX文件以及Unity预制件，可高度自由化定制。 该资源包提供了两种光照设置示例，分别表示白天跟夜晚的场景，都是使用资源中的资源零件组合而成的大场景。材质仅有简单的着色，再加上光照的配合，就能设计出不同明暗度的场景。 下载地址：https://www.assetstore.unity3d.com/en/#!/content/69650 City Adventure beffio非常擅于制作简单却精致的场景资源，上次为大家介绍的太空游戏必备场景包Space Journey也是出自beffio之手。CityAdventure与Space Journey类似，都是低多边形模型。CityAdventure是用来制作城镇场景的资源包，所有资源同样按模块分成各种不同的预制件，非常适合顶视图的生存构建类游戏。 City Adventure包含160多个独立物体及12种自定义贴图，提供了20多个示例场景，其中有12个都是非常大型的场景，如下图： 并且如此大型的场景运行时可以保证平均帧率达到60，仅有21个SetPass Calls： 资源包中所有资源都针对游戏使用场景对三角形面数、纹理、UV图及图集等进行了深度优化，不仅适用于PC端，对于移动平台也同样使用。且该资源完全使用Unity引擎制作，能与Unity标准着色器完美结合。 除了场景资源外，CityAdventure还提供了调色插件，可以一键更改整个场景的色调。同时针对不同的色调也提供了示例场景。使用方式也非常简单，只需在主相机上添加下面的脚本并调整相应的属性即可： City Adventure提供的调色示例如下： 下载地址：https://www.assetstore.unity3d.com/en/#!/content/65307","link":"/blog/2019/05/17/Unity插件/精美实用的Unity场景资源/"},{"title":"给力的Unity脚本插件","text":"Unity的AssetStore中除了拥有非常强大的Unity编辑器扩展工具之外，还有一些让开发过程事半功倍的脚本插件。今天为大家介绍几款饱受好评的脚本插件。 Pro Camera 2D Pro Camera2D是为2D及2.5D游戏量身定制的相机插件，可以快速在Unity中为任意类型2D游戏设置合适的相机。它支持三个坐标轴方向，也支持正交及透视两种相机模式。另外该插件从制作之初就一直非常注重性能及可扩展性，所以即便是配置较低的老式移动设备也可放心使用。开发者也可以很方便地扩展该插件以适应游戏的特殊需求。 Pro Camera 2D主要分为三大块： Core：轻量级且极度优化的插件核心部分，仅关注相机的目标对象及目的地。 Extensions：包含一系列已定义好的扩展，可以很方便地增加一些相机设置如边框、镜头转换、焦点设置、边界及速度设置、抖动及缩放等等，目前共有17个。这些扩展是在Core的基础上实现的，但不包含在Core中，所以不需要的扩展可以禁用，这样也不会影响性能。 Triggers：触发器，与Extensions类似，增加相机的额外功能。触发器是独立于相机存在的，它会在相机接触到游戏中的目标物体时触发一些事件。自定义触发器也很简单。 使用Pro Camera 2D的方式非常简单，只需在场景的主相机上添加Pro Camera 2D脚本，然后进行一些简单的设置即可： Pro Camera2D支持跟踪多个目标，并且可以设置各个目标相对相机的偏移。另外所有的Extensions及Triggers都可以很方便的在检视面板中点击按钮进行启用与添加，它会自动将所需的脚本绑定到相机对象上。 下载地址：https://www.assetstore.unity3d.com/#!/content/42095 Ultimate Rope Editor 顾名思义，Ultimate RopeEditor就是用来解决游戏中所有绳索相关问题的。它能生成各种类型的绳索，并将绳索物理应用到已有的网格上。更方便的是，绳索的物理参数可以在运行时实时调整，然后复制到编辑器模式下，从而帮助节省大量的迭代时间。 Ultimate RopeEditor是一个非常轻量级的插件，它将创建绳索的过程简化到了极致。只需一个脚本就能完成所有的设置，并且具有非常逼真的物理特性。使用UltimateRope Editor只需在绳索对象上添加Utilmate Rope脚本，然后设置绳索的类型、起始点、材质及其物理属性即可。 这里可以选择三种类型的绳索： Procedural：系统自动生成绳索，包含物理特性与网格信息。 Linked Objects：链式绳索，由一个个小的部位链接。 Import Bones：从已有的骨骼信息生成绳索的物理，常用于处理头发。 下载地址：https://www.assetstore.unity3d.com/cn/#!/content/7279 Chronos - Time Control Chronos - Time Control是用于控制游戏中各种时钟的插件，也是Unity Awards2015优秀插件大奖得主。该插件小巧易用且优化过性能，可以搞定游戏中所有的时钟控制。支持时间的暂停、倒退、减速及加速，并且每个对象都有单独的时间线，还可以按区域来同时控制多个对象。 Chronos - Time Control非常简单，能够很好的应用于自定义脚本，并且完全兼容对象的物理属性，能够自动适应动画、粒子效果、Nav MeshAgent及音效。该插件主要包含三种类型的脚本： Timekeeper：追踪场景全局时钟的单例，一个场景仅需一个Timekeeper。 Clock：所有类型时钟的基类。共有三种时钟：Global Clock（全局时钟）、Local Clock（本地时钟）及Area Clock（区域时钟）。 Timeline：整合一个或多个时钟来单独控制某一个游戏对象的Delta Time和TimeScale等属性。每个需要使用Chronos控制的游戏对象都要绑定该脚本。 Chronos - Time Control适合实现一些游戏角色的特殊技能，如操控时间的魔法或科幻技能等。不论2D或3D游戏均能完美支持，且适用于任何平台。 下载地址：https://www.assetstore.unity3d.com/cn/#!/content/31225","link":"/blog/2019/05/17/Unity插件/给力的Unity脚本插件/"},{"title":"虚拟摇杆EasyTouch","text":"对于移动平台上的RPG类的游戏，我们常用虚拟摇杆来控制人物角色的行走和一些行为，相信我们对它并不陌生，之前尝试了EasyTouch2.5，发现并没有最新版的3.1好用，2.5版本的对于自适应没有做的很好，而最新版的已经解决了这一问题。当然unity也自带了摇杆Joystick，用起来也简单，但存在不少局限，不会满足普通mmo游戏的需求，比如指定显示区域或者是更改一些素材等等，而这些EasyTouch插件都已经帮你实现，不得不佩服插件的原作者，能做出这么炫酷好用的插件，当然这估计是老外开发的，关于插件的下载，你可以在AssetStore上购买，当然也可以使用free版。 我这里也提供一个3.1版本的插件下载地址： &lt;http://download.csdn.net/detail/s10141303/6962919 一、效果图 感觉很酷有木有！接下来就看一下创建的过程吧！ 二、操作步骤1.官方文档上的步骤Quick Start (C#) 1-Import EasyTouch Package. 2-Create an empty gameObject, and name it EasyTouch.(You can choose anothername) Step 1 &amp; 2 can be replace by the option menu 3-Add the EasyTouch.cs script on the EasyTouch gameObject that you justcreated. 4-Select the EasyTouch gameobject, and verifies that Broadcast messages is setto FALSE in the inspector. 5-Create a new C# script MyFirstTouch 6-Add these methods 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Subscribe to events void OnEnable(){ EasyTouch.On_TouchStart += On_TouchStart; } // Unsubscribe void OnDisable(){ EasyTouch.On_TouchStart -= On_TouchStart; } // Unsubscribe void OnDestroy(){ EasyTouch.On_TouchStart -= On_TouchStart; } // Touch start event public void On_TouchStart(Gesture gesture){ Debug.Log( &quot;Touch in &quot; + gesture.position); } 7-Create an empty gameObject, and name it Receiver. 8- Add MyFirstTouch script to the gameObject Receiver. 9- Run it in editor, and click on the screen 2.翻译一下以上的步骤1.import“EasyTouch”资源包 2.创建空物体，命名为EasyTouch(当然你也可以改成其他名字) 3.添加EasyTouch.cs脚本在刚刚创建的空物体（EasyTouch）上 4.选择改物体但不要将BroadcastMessages勾选 5.创建一个新的C#脚本，命名MyFirstTouch 6.添加这些方法 7.再创建一个空物体，命名为Receiver 8.将MyFirstTouch脚本添加到空物体Receiver上 9.运行并且点击遥感，会发现控制台打印了当前按下的坐标 3.根据官方的这些提示，自己来做一个属于自己的人物遥感控制1.导入EasyTouch3资源包 2.做好前期准备，包括人物模型、地形的创建 3.添加JoyStick实例：Hedgehog Team-Easy Touch-Extensions-Add a newJoystick。此时就会在左下角创建了虚拟遥感的实例。 4.设置遥感的相关参数 .创建脚本MoveController.cs用来接收遥感事件控制角色的移动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150using UnityEngine; using System.Collections; public class MoveController : MonoBehaviour { void OnEnable() { EasyJoystick.On_JoystickMove += OnJoystickMove; EasyJoystick.On_JoystickMoveEnd += OnJoystickMoveEnd; } //移动摇杆结束 void OnJoystickMoveEnd(MovingJoystick move) { //停止时，角色恢复idle if (move.joystickName == &quot;MoveJoystick&quot;) { animation.CrossFade(&quot;idle&quot;); } } //移动摇杆中 void OnJoystickMove(MovingJoystick move) { if (move.joystickName != &quot;MoveJoystick&quot;) { return; } //获取摇杆中心偏移的坐标 float joyPositionX = move.joystickAxis.x; float joyPositionY = move.joystickAxis.y; if (joyPositionY != 0 || joyPositionX != 0) { //设置角色的朝向（朝向当前坐标+摇杆偏移量） transform.LookAt(new Vector3(transform.position.x + joyPositionX,transform.position.y, transform.position.z + joyPositionY)); //移动玩家的位置（按朝向位置移动） transform.Translate(Vector3.forward * Time.deltaTime * 5); //播放奔跑动画 animation.CrossFade(&quot;run&quot;); } } } 几个函数的执行顺序： 6.效果图 7.创建点击按钮 点击HedgehogTeam-EasyTouch-Extensions-Create a new Button,会在屏幕右下角创建一个button 如何让有下角的按钮点击能做出我们想要的效果呢？ jump方法： 然后点击一下按钮，人物就会跳跃动作！ 其他教程： &lt;http://blog.csdn.net/janeky/article/details/17364903 &lt;http://www.newbieol.com/information/564.html","link":"/blog/2019/05/17/Unity插件/虚拟摇杆EasyTouch/"},{"title":"轻松玩转Unity编辑器菜单扩展","text":"Unity一个很强大的功能就是可扩展，你可以利用该功能创建出各种各样的工具，直接整合到Unity中使用。今天这篇文章将为大家全面介绍扩展Unity中所有菜单项的方法及各菜单项的适用场景。 介绍Unity编辑器中可扩展的菜单总览如下图： 这些菜单分别是： 编辑器顶部的内置菜单（A、B、C、D） 层级视图右键弹出菜单（B） 项目视图右键弹出菜单（A） 检视面板中点击Add Component按钮弹出的菜单（C） 编辑器顶部的新菜单项（E） 扩展菜单项，只需在静态方法前添加[MenuItem]属性声明即可，使用该属性需要引用UnityEditor命名空间。该方法是否公有、返回类型及方法名称均无关紧要。 例如，在静态方法前添加[MenuItem(“Window/Custom SubMenu/Custom Window”)]即可实现如下效果： 关于MenuItem路径参数的几点说明： 如果根目录已存在于菜单项中（如“Assets”、“Window”等），那自定义菜单项将被添加到这些菜单下（“Component”除外） 必须要指定根目录及菜单项名称 菜单及菜单项名称均支持包含空格 还可以在菜单项名称后添加某个按键代码来指定该菜单项的快捷键 子菜单没有层级限制 例如，添加以下代码： 然后依次点击菜单项GameObject &gt; Create RedBlue GameObject，就会在场景中新建名为“RedBlueGameObject”的游戏对象。 另外MenuItem还可支持多个参数： 其中参数isValidateFunction决定是否启用菜单项，设为True时，如果函数返回值为真，则菜单项启用，函数返回值为假则禁用菜单项。参数priority决定了菜单项在菜单中显示的优先级。 何时使用哪种菜单由于对菜单的使用没有严格的限制，这就需要开发者们了解各项菜单原本的目的。下面就来看看什么时候要用什么菜单。 AAssetsAssets菜单用于在项目中创建或修改资源。在项目视图中右键点击也会弹出Assets菜单。另外，如果将自定义菜单项放在“Assets/Create”目录下，点击项目视图的“Create”按钮时也会出现该自定义的菜单项。 什么情况下适合使用Assets菜单呢： 新建ScriptableObject，所有自定义的ScriptableObject都可以通过Assets &gt; Create子菜单来创建 重命名精灵图集，右键点击包含多个精灵图片的纹理，用菜单项帮助快速重命名所有精灵图片 BGameObjectGameObject菜单用于场景中与游戏对象息息相关的方法，如新建游戏对象或编辑已有对象等。右键单击项目视图也会显示GameObject子菜单，在层级视图点击Create按钮同样会显示GameObject子菜单。 如果希望自定义菜单项可以同时出现在右键弹出菜单和层级视图的Create按钮弹出的菜单中，就必须将该自定义菜单项放置在已有的菜单项中，如2DObject或UI等。如果没有合适的已有菜单项，也可以自己新建菜单项并将优先级设为50以下。 如果自定义工具是用于为游戏对象添加脚本，那最好还是放在Component菜单下。使用GameObject菜单的几种情况是： 新建预定义的游戏对象，例如预设体实例，你可以使用菜单项在新场景中设置好自定义相机 将选中的游戏对象存为预设体，该工具功能与GameObject下的Break Prefab Instance正好相反 CComponentComponent菜单下的所有菜单项都是用于为选中的游戏对象添加组件，为了加强该功能，Unity并不允许通过MenuItem向该菜单增加菜单项，而是使用[AddComponentMenu]属性，该属性直接用于自定义的MonoBehaviour类。点击菜单项会自动添加该脚本。 在脚本的类声明前添加[AddComponentMenu]属性，该脚本会同时出现在Component菜单以及在检视面板中查看游戏对象时点击AddComponent弹出的菜单中。该属性带有与MenuItem相同含义的路径参数，但不支持对自定义菜单项进行排序。 添加自定义菜单项后的Component菜单如下： DUnity、File、Edit、Window以及Help这几个菜单比较简单，其中的菜单项也不会出现在Unity编辑器的其它地方。需要打开新窗口的功能可以放在Window菜单中。需要同时修改游戏对象及资源的工具，如自定义的重复创建或重命名等，则放在Editor菜单中。Unity对此没有具体要求，你可以按照自己的习惯来布置。 E新建菜单项如果已有菜单项均不适合自定义工具的功能，也可以自己新建一个菜单项。但Unity并不推荐在多人合作或共享资源的项目中新建菜单项，这可能会导致工具栏异常混乱。 关于Unity编辑器上方工具栏各菜单的扩展就介绍到这里，后续我们再为大家介绍各个菜单项的优先级如何设置。","link":"/blog/2019/05/17/Unity插件/轻松玩转Unity编辑器菜单扩展/"},{"title":"那些你不得不用的好插件","text":"在手机上插入电影已经是当下非常普及的需求了，在比较了各种视频集成插件后，我们认为Mobile Movie Texture能实现非常不错的效果。它的特点在于： 功能比较丰富，支持播放、暂停，播放点拖动等操作。 性能非常高效。如下图，在红米2只要1.16ms即可完成整个函数的调用，非常快速。 ** ** 支持透明区域分离 。在如下的爆炸视频中，Mobile MovieTexture将Alpha通道剔除，使得视频本身能更好地和背景融合。该剔除总耗时1.86ms，即使在每帧都有个decode的情况下，总耗时基本上依然不会超过2ms。 虽然该插件目前仅支持Ogg和Ogv格式，但是我们可以通过工具把其他格式转换成Ogv格式导入Unity使用。 注意 ：和所有视频插件一样，Mobile Movie Texture也不支持URL播放，如优酷的URL是不支持的。 Dynamic Bone 为了增加角色运动的真实代入感，我们常常需要某些主体的附属物能跟随主体的运动自然地发生变化，如头发、衣服的运动等，这时候DynamicBone就能满足我们的需求，从而避免了美术设计师费时费力地重复工作，并且性能表现非常高效。该插件是源码开放的，适合移动设备。 如下图，该插件的使用非常简单，开发者只需要在此设置一些根节点等相关参数。原理也不难理解：对于每个附属物体，获取骨骼根节点和控制节点的Transform信息。根据这两个结点信息，根据设定参数将运动传播出去。 ** ** ** ** Magic Splitscreen 随着电视游戏走入寻常百姓家，两人甚至多人同屏游戏的需求已经相当普遍，如赛车、枪战类等游戏。这时候我们就希望游戏能达到自动分屏的效果，MagicSplitscreen恰能满足这点。 该插件支持多个Player分屏（图例是两个），开发者只要选定分屏的Camera、主camera以及设定TriggerDistance（距离多远的时候分屏）等参数，即可达到分屏效果。 该插件的工作原理：当镜头拉远的时候，去创建一个Camera去渲染另一个物体，比如创建了一个分相机并调整它的透视矩阵，该矩阵根据距离的远近选择合适的角度去切这个场景，将得到的结果以Mask的形式贴到原来的主Camera上，从而实现这样的效果。","link":"/blog/2019/05/17/Unity插件/那些你不得不用的好插件/"},{"title":"VR视频类型识别","text":"目前通过图像识别的方式区分视频类型，并已完成应用层的实现，识别率很高 相比通过获取视频文件特征标识的方式优点： 1.不用修改系统的MediaScanner 所以不用升级系统 2.视频文件中一般只有mp4文件有metadata 其中box和uuid之类的特征标识并没有标准行业规范 所以通过图像识别的方式没有文件格式和视频编解码的限制 缺点： 1.比获取视频文件特征标识的方式速度慢 基本思路1.对一个视频 根据播放时长平均取若干帧图像 根据每帧图像识别后 返回的类型 做加权 最后权值大于40% 则为该类型 2.判断流程： 先判断左右眼3d — true — 返回3d类型 — false — 判断上下眼3d — true — 返回3d类型— false — 判断全景 — true — 返回全景— false — 返回2d 3.判断左右眼3d：取图像最中间一列像素 作为基准线 判断该列和其右边一列是否有连续性 如果不连续 则为左右眼3d 但很多3d视频左右眼宽度不相等 所以一次判断不是 还需要多判断几次 即左右各移动两次 每次移动一列 4.判断上下眼3d：取图像最中间一行像素 作为基准线 判断该行和其下面一行是否有连续性 如果不连续 则为上下眼3d 但很多3d视频上下眼高度不相等 所以一次判断不是 还需要多判断几次 即上下各移动两次 每次移动一行 5.判断全景视频：由于全景视频是360度的 所以图像最左边一列（第0列）和最右边一列（第n-1列） 必然可以连接起来 所以判断这两列是否有连续性 如果连续则为全景视频 后面发现还存在如下问题1.视频取帧速度慢 取一帧需要几百毫秒 所以性能瓶颈不在算法的时间复杂度 而是调用系统函数取视频帧慢 2.加权阀值40% 不合适 如果取两帧 则权重阀值为0了 至少应为50% 取帧的数量会影响耗时 3.如果视频有片头或片尾 比如黑色画面 显示演员列表之类的 对于图像判断连续性及加权结果 有很大影响 4.无论左右眼还是上下眼3d 很多视频 中间会有间隙或黑线 视频分辨率越高则间隙或黑线所占像素的行列越多 所以仅仅移动像素行列两次 是没用的 5.视频画面很暗 则对判断像素的连续性 有影响 我的解决办法及优化1.跳过视频时长的前后10%的时间段 认为是片头或片尾 对视频中间的时间段取帧 2.取10帧或者取1帧 其实大部分情况下 在图像上的特征没有区别 3d视频左右或上下有对称性 全景最左和最右可以连接起来 所以只取1帧 不考虑加权耗时减少一个量级 3.在不影响识别结果的情况下 对原始的视频帧图像进行等比例压缩 减少实时的内存占用 更少的像素判断次数 耗时减少 4.每个视频文件 不用每次应用启动都进行识别 可以缓存文件的hash值和视频类型的识别结果 后面启动不需要再识别之前已经识别过的视频文件只需读取缓存过的识别结果 5.判断左右眼3d改为： 取左右眼各自区域图像的最中间一列像素 判断两列像素是否有连续性 如果连续 即说明图像对称 则为左右眼3d但很多3d视频左右眼宽度不相等 所以一次判断不是 还需要多判断几次 即右眼区域图像左右各移动两次 每次移动一列 这样就不需要判断取图像中间列即不存在有黑线和间隙的问题 6.判断上下眼3d改为： 取上下眼各自区域图像的最中间一行像素 判断两行像素是否有连续性 如果连续 即说明图像对称 则为上下眼3d但很多3d视频上下眼高度不相等 所以一次判断不是 还需要多判断几次 即下眼区域图像上下各移动两次 每次移动一行 这样就不需要判断取图像最中间行即不存在有黑线和间隙的问题 目前依然存在的问题1.视频画面很暗 则对判断像素的连续性 有影响 2.经测试 调用系统函数对视频取帧 在乐视X2和S2的安卓6.0以上 存在兼容性问题 还需要做的优化1.不用系统函数对视频取帧 改用第三方FFMPEG编解码库 并将其中取帧的部分提取出来 提高取帧速度 Q : 如何判断两列（行）像素连续性或相似性 A : 1.依次取出该列（行）的像素颜色值 对颜色值做位运算（要考虑各通道占位ARGB8888、RGB565、RGB444） 取出RGB三通道的值两列（行）相同索引像素的RGB值分别求均值（两列或行差值的绝对值累加求和/该列或行的像素数） 取RGB三通道中的最大均值 2.同上 再对RGB三通道分别求方差（（ 两列或行差值的绝对值-两列或行的均值）的平方的累加求和/该列或行的像素数） 取RGB三通道中的最大方差 3.求出的最大均值或最大方差 若超过阀值 则说明无连续性或低相似性","link":"/blog/2019/05/17/VR/VR视频类型识别/"},{"title":"如何避免虚拟现实中的晕眩","text":"大家好，今天跟大家分享一下北京理工大学翁冬冬教授，在深圳开发者大会中发表的晕眩相关研究。希望可以给相关的读者或是开发者伙伴一些信息与帮助。翁冬冬教授与他的团队在HTCVive之前已经研究虚拟现实显示设备数十年，对虚拟现实及人体的影响研究相当的丰富。 【一、晕眩的八大可能原因】 【二、晕眩的产生原理与迷思】 【三、三种不同的晕眩来源】 【四、避免虚拟现实晕眩的三种理论】 【五、改善虚拟现实晕眩的四个方向】 【六、缓解虚拟现实晕眩的七个方式】 【七、翁教授的有趣题外话！】 更多深圳开发者峰会的信息，请看这里！ https://www.htcvive.com/cn/forum …wthread&amp;tid=173 =============================================================================== 【一、晕眩的八大可能原因】 首先，翁冬冬教授明确说在前头，以下的研究内容并不是说开发者能做什么或是不能做什么，而是在体验者发生晕眩情形时，可以做为参考依据的线索与出发点。「因为VR能够达成的世界很美好，我们才更应该注意我们内容呈现的质量。」翁冬冬教授说道。 先讲简单结论，看一下使用者会晕的八大可能原因： 系统延迟（俗称的lag） 视场角(FIELD OF VIEW)越大，越容易晕 第一人称比第三人称越晕 场景细节越复杂越晕 场景越真实可能越晕 被动比主动操作容易晕（就像开车的人不会晕车） 有静态参照物（几乎不动的一个对象）会好很多（驾驶舱，甚至鼻子） 不良的视角晃动（比如说刻意营造的震动效果: 想象云霄飞车等） =============================================================================== 【二、晕眩的产生原理与迷思】 再来，我们可以更进一步深究一下晕眩的产生原理： 1. 晕眩其实是身体的保护机制，是大脑前庭受到「不良」的刺激后，警告身体的一种反应。 2. 何谓「不良」的刺激？举凡生活中的晕车、晕船、晕机；玩计算机或仿真器时的不适；以及虚拟现实装置中可能造成的运动错觉。 3. 简单来说，当视觉／感官接受的讯号，与前庭系统受到的刺激对不起来，就是「不良」的刺激，就容易晕眩。 然后，我们常常有一些对于晕眩的迷思 1. 【迷思：计算机上看不会晕，用头盔看也就不会晕？】错，不同的设备上观看的内容，眩晕与否以及程度是很不一样的。 2. 【迷思：场景越真实越不会晕？】错，场景的细节越多，越容易发生晕眩 =============================================================================== 【三、三种不同的晕眩来源】 翁冬冬教授的团队更进一步说明了三种不同的晕眩来源（动晕(motion-sickness)、仿真器晕眩、虚拟现实晕眩），以及其不同的地方： 【首先，一般的动晕症状】 像是坐车、坐船、坐飞机时因为颠簸、摇摆、旋转等任何形式的加速运动，导致大脑前庭与感官认知有所差异，以致晕眩的不适应症状（肚子不适、恶心、头晕等）。但是，持续并稳定等速的被动运动 （如火车、飞机、电梯速度稳定时），前庭的感受器会以同样的速度运动，就不会被人体所感知到。 【再来，数字媒体导致的仿真器晕眩症状】 和一般晕动症不同的是，所谓的「仿真器晕眩症状」往往是因为不牵涉任何实际运动所导致的。晕动症发生是在实际有运动的时候（船上、飞机上），仿真器晕眩症却是因为视觉上感受到有运动，实际 上却完全没有任何运动而导致。所以常见有些朋友在观看屏幕上3D画面，进行3D游戏时会有不适感。于人体的症状也跟一般动晕症稍有不同（如眼睛疲劳）。 【最后，因为虚拟现实媒体导致的虚拟现实晕眩】 由于虚拟现实所产生的独特沉浸感，加上在虚拟现实环境中，常有在身体不动的情况之下，视觉观察动态的场景，此时容易产生强制性的运动感（运动错觉）。常见症状有恶心、眼部不适、真实感减弱 、和方向障碍。虚拟现实晕眩症的症状往往比前面两种晕眩还来得严重，可能是因为虚拟现实较强的沉浸感导致，这会破坏体验者对虚拟现实的好感，使对虚拟现实失去安全感，也是限制未来虚拟现实 发展的重要障碍。 =============================================================================== 【四、避免虚拟现实晕眩的三种理论】 为了避免产生麻烦的虚拟现实晕眩症状，有三种理论可供参考 【感知冲突理论：是否违反感官的预测？】 人的感官有一种「预测」的学习能力，因此当我们习惯了重力往下，东西松开之后就会认知他将往下掉。如果把我们放到一个重力不是往下的环境，换句话说，一个环境刺激与感官习惯不同的世界，可能会引起晕眩症。 【姿态平衡理论：视觉导致的姿势改变，是否与其他感官相异？】 我们可能在虚拟现实中操控着飞机高速的转弯，视觉中告诉你需要偏动一下姿势以免被作用力甩出去，但好好坐在位置上的大脑，却什么作用力都没有感受到，感官矛盾之下可能会晕眩。一旦我们在外 界刺激之下无法保持一个稳定的姿势，可能就会因此感到不适，姿势不平衡感越强，人们就会更不舒服。这有些类似感知冲突中的感受，却因为是前庭系统无法应付的不良刺激，所以被视为更加受限的形式。 【中毒理论：虚拟现实体验是否刻意营造失去感官能力的错觉？】 由于人体长久的进化过程，晕眩变成一种身体失去感官能力时的自然警讯。当设计不合理的虚拟现实内容，让身体误以为已经摄取某种导致它失去运作能力的物质，就会自然触发晕眩、呕吐、等帮助身体排出毒素的反映。 当然，除了以上三种理论之外，还有像是显示屏幕的问题、个人的体质等，都可能有所影响 =============================================================================== 【五、改善虚拟现实晕眩的四个方向】 最后，针对虚拟现实的晕眩症状，有个简单的快速的check-list供各位朋友参考 【系统原因（软硬件整体设计不良）】 运动能力丧失 (如手机虚拟现实中，明明没有移动却在视觉中大幅度运动) 运动能力缺失 (如Virtuix Omni提供的部分移动感，却仍受限的运动能力) 运动能力不一致 (在能够自由运动之下，却和其余感官感受的不一致) 【软件原因】 屏幕显示更新率 运算性能限制 交互系统延迟 定位系统延迟 显示器视场角(field of view) 屏幕分辨率 显示器对比度 显示器亮度 瞳距 出瞳距离 头盔体积重量 头盔配戴舒适度 定位系统准确度 视觉、听觉、触觉协调性 听觉输入音量 (其中以1~4为最主要原因) 【软件原因】 细节复杂度 (越复杂 = 越频繁的眼动 = 更重的大脑负担) 环境逼真度 视角选择 (第一人称比第三人称易晕) 场景比例 (ex: 场景中人的高度与现实不一致) 主动/被动？ (被动比主动易晕，ex: 乘客vs.驾驶) 视角不良运动 (ex: 刻意营造的不合理视角晃动，身体无感/视觉有感的云霄飞车晃动) 环境特性 (ex: 不易分辨方向的狭窄黑暗环境相对易晕) 有无静物参考？ (没有静态参照物易晕，ex: hover junkers的船甲板, 射击游戏的准星) 图像色度、饱和度 环境模糊度 环境开阔度 物体动静态影响 VE与RE差异 视角与物体远近 虚拟视场角大小 参照物影响 场景复杂度 (越复杂 = 越频繁的眼动 = 更重的大脑负担) 速度、加速度影响 运动复杂度 头部转动频率 标志点影响 (其中以1~8最为主要) 【个人原因】 经验与习惯 心理因素 性别与年龄 疲劳程度 使用VR装置的频率 主视眼影响 平衡感 视觉与前庭感官健康 对新事物接受能力 (其中1~2为主要因素) =============================================================================== 【六、缓解虚拟现实晕眩的七个方式】 设计合理场景 提高硬件(画面)更新率/降低延迟/增加定位准确度/减轻头盔重量/设计合适的视角 不要在进入虚拟现实后快速移动或做一些不平稳的动作 离开虚拟世界后不要马上坐下、走动一下可以帮助回到真实世界 增加运动平台来模拟实际运动 在虚拟场景中增加静止参考元素 提前适应虚拟场景 =============================================================================== 【七、翁教授的有趣题外话！】 最后，翁冬冬教授另有一些有趣的题外话发言，在此给大家参考！ (晕眩是前庭受不良刺激) 但是人类偏偏很喜欢刺激前庭（开快车、旋转木马、云霄飞车），会带给大脑愉悦感。 VR中学会的技能，在现实生活中也是真的学会，是有科学理论基础的。 对Gear VR只有一个字：恶，尤其不规则高速转动的游戏，一定非常晕(翁教授补充：虽然我很爱玩)。 我没有拿HTC的钱，但HTC Vive确实是我研究几十年来用过最好的（VR装置）！","link":"/blog/2019/05/17/VR/如何避免虚拟现实中的晕眩/"},{"title":"GithubPage+Hexo搭建个人主页","text":"安装配置部署https://zirho.github.io/2016/06/04/hexo/ 添加评论这个主题的评论已经集成了，并不需要我们进行手工导入，要求你有多说/disqus的账号，并在跟目录的_config.yml中，删去注释#： DuoShuo duoshuo_shortname: 多说设置的名称 添加友情链接我们在主题的_config.yml中已经有设置links的了。只是没有显示出来： 修改主题的_config.yml 1234567891011121314151617181920# Links 通过links来设置友情链接links: Hexo: http://hexo.io foam | 我一直在找寻有你的世界: http://zoufeng.net/ getNway的博客: http://www.luojiawei.me/ HCLAB-环宇创意电脑工作室: http://hclab.cn/hclab/index.php/# Sidebar # 网站右边框sidebar: right # set to false if you don&apos;t want a sidebarwidgets:- category- links 发布博客，markdown文件的格式markdown文件需要添加categories进行归档区分。 相应的为： 1234567891011title: &quot;java-Map集合-HashMap&quot;thumbnail: http://XXXXXXX (或者相对路径)date: 2015-07-28 10:48:16categories: javatags: [java,Map,HashMap,Hashtable]--- thumbnail也可以在配置文件中关闭不显示 其中categories/tags的格式也可以为： 12categories/tags: - java 具体格式相应属性的设置，直接去hexo提供的文档： [Front-matter](https://link.jianshu.com/?t=https://hexo.io/zh-cn/docs/front-matter.html)，直接查看官方的文档就可以很快地知道个所以然了。 添加站长统计我们通过站长统计来及时查看我们个人网站的浏览情况。首先，我们需要进行注册：站长统计 以下参考：[添加cnzz站长统计](https://link.jianshu.com/?t=https://github.com/woheme/hexo-theme-icarus/commit/5b3da36aaffa4947cca358f40d5db09eddf3b9b8) 在theme的_config.yml中的末尾添加以下：(这部很重要，不添加web_id将无法显示出来) CNZZ id cnzz: 这里填入你在站长统计注册后的web_id 在目录：主题的layout/_partial/添加文件为cnzz.ejs，内容如下： 123456&lt;% if (theme.cnzz){ %&gt;Analyse with &lt;script src=&quot;http://s23.cnzz.com/z_stat.php?id=&lt;%= theme.cnzz%&gt;&amp;web_id=&lt;%= theme.cnzz %&gt;&quot; language=&quot;JavaScript&quot;&gt;&lt;/script&gt;&lt;% } %&gt; 最后进行显示，在路径layout/_partial/footer.ejs里面添加： 1...PPOffice&lt;/a&gt;.&lt;%- partial(&apos;cnzz&apos;) %&gt; 再次提醒注意在_config.xml中添加web_id，否则无法显示。当显示出来了，又有一个问题，那就是要填写查看密码了。 查看以下即可：【设置】如何设置查看密码？（此功能只限站长用户） 百度/谷歌验证站点为什么要验证站点了，因为要搜索引擎进行收录，说白了就是让别人更容易搜索到你的网站，仅此而已。 首先需要到百度/谷歌站长统计中注册，以及验证： Google网站管理员工具地址 百度站长工具 注册完后，进行输入相应的网站地址，然后选择html验证，将代码加入以下路径layout/_partial/head.ejs：（截取部分） 1234567891011&lt;head&gt;&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;tqvy7RDErf&quot; /&gt;&lt;meta name=&quot;google-site-verification&quot; content=&quot;hjN29-PO_KfE-dgow-7hcz75xJj0qzZ6G2OkXZ3FVd8&quot; /&gt;&lt;meta charset=&quot;utf-8&quot;&gt;.... 然后发布到github中，再进行验证即可。 发布后无法加载样式因为默认的路径的为http://uername.com/hexo-theme-icarus而你解析的路径直接为http://uername.com/导致无法加载样式，或者无法显示文章。那么，该如何进行修改呢？ 我们需要对路径进行提升，从hexo-theme-icarus到/，你可以按着Hexo使用总结中的配置进行修改_config.yml，即可。修改完后，不要着急，我的情况要等好久才回显示正常，真是郁闷。下面是个别的设置： 站点的_config.yml 1root: / theme的_config.yml 12345678Home: / Archives: /archives Categories: /categories About: /about 扩展插件的使用强大的插件供你使用，插件集合：HexoPlugins。 下面展示一个插件sitemap的使用：hexo优化–向Google提交sitemap 还必须在根目录的_config.yml加入以下配置： Extensions 这里配置站点所用主题和插件，暂默认，后面会介绍怎么修改 Plugins: https://github.com/tommy351/hexo/wiki/Plugins exclude_generator: plugins: - hexo-generator-feed - hexo-generator-sitemap 发布后显示404：查看配置文件_config.yml中的配置是否与实际情况相符： 123url: https://hcq0618.github.io/blog/root: /blog/ 在文章中插入本地图片https://cloud.tencent.com/developer/article/1019861 遇到问题 遇到没能成功显示的问题，查看网页，结果是&lt;img src=&quot;2017/02/26/2017-02-23-c/图片名.jpg&quot;&gt; 的形式，然后查看 hexo的目录，发现路径是 /public/2017/02/26/c/a.jpg。 之前在 md 文件中引用时写作： 1![你想输入的替代文字](xxxx/图片名.jpg) 改为： 1![](a.jpg) 就可以了。 创建Github Page在Github上创建一个仓库，可以新建一个source分支用于存在主页项目源码，master用于存放主页网页静态代码，然后在项目Settings里找到Github Page，选择master分支，即可创建一个github page主页url一般为： 1&lt;github用户名&gt;.github.io/&lt;项目名&gt; 然后每次都可以通过github desktop，将主页的项目源码上传到source分支依次通过hexo的命令 hexo generate或者hexo g或者hexo g -f hexo deploy或者hexo d 就会自动生成静态网页并将主页网页静态代码push到master分支（当然先会要求验证github账号密码），主页就随即更新了","link":"/blog/2019/05/18/Web/GithubPage+Hexo搭建个人主页/"},{"title":"ARKit：增强现实技术在美团到餐业务的实践","text":"ARKit：增强现实技术在美团到餐业务的实践原创： 曹宇 美团技术团队 __ 总第282篇 2018年 第74篇 前言增强现实（Augmented Reality）是一种在视觉上呈现虚拟物体与现实场景结合的技术。Apple 公司在 2017 年 6 月正式推出了ARKit，iOS 开发者可以在这个平台上使用简单便捷的 API 来开发 AR 应用程序。 本文将结合美团到餐业务场景，介绍一种基于位置服务（LBS）的 AR 应用。使用 AR的方式展现商家相对用户的位置，这会给用户带来身临其境的沉浸式体验。下面是实现效果： 图1 实现效果图 项目实现iOS 平台的 AR 应用通常由 ARKit 和渲染引擎两部分构成： 图2 AR 应用的整体架构 ARKit 是连接真实世界与虚拟世界的桥梁，而渲染引擎是把虚拟世界的内容渲染到屏幕上。本部分会围绕这两个方面展开介绍。 ARKitARKit 的 ARSession 负责管理每一帧的信息。ARSession 做了两件事：拍摄图像并获取传感器数据；对数据进行分析处理后逐帧输出。如下图： 图3 ARKit 结构图 设备追踪设备追踪确保了虚拟物体的位置不受设备移动的影响。在启动 ARSession 时需要传入一个 ARSessionConfiguration的子类对象，以区别三种追踪模式： ARFaceTrackingConfiguration ARWorldTrackingConfiguration AROrientationTrackingConfiguration 其中 ARFaceTrackingConfiguration 可以识别人脸的位置、方向以及获取拓扑结构。此外，还可以探测到预设的 52种丰富的面部动作，如眨眼、微笑、皱眉等等。ARFaceTrackingConfiguration 需要调用支持 TrueDepth的前置摄像头进行追踪，显然不能满足我们的需求，这里就不做过多的介绍。下面只针对使用后置摄像头的另外两种类型进行对比。 ARWorldTrackingConfigurationARWorldTrackingConfiguration 提供 6DoF（Six Degree of Freedom）的设备追踪。包括三个姿态角Yaw（偏航角）、Pitch（俯仰角）和 Roll（翻滚角），以及沿笛卡尔坐标系中 X、Y 和 Z 三轴的偏移量： 图4 6DoF 不仅如此，ARKit 还使用了 VIO（Visual-InertialOdometry）来提高设备运动追踪的精度。在使用惯性测量单元(IMU)检测运动轨迹的同时，对运动过程中摄像头拍摄到的图片进行图像处理。将图像中的一些特征点的变化轨迹与传感器的结果进行比对后，输出最终的高精度结果。 从追踪的维度和准确度来看，ARWorldTrackingConfiguration非常强悍。但如官方文档所言，它也有两个致命的缺点： 受环境光线质量影响 受剧烈运动影响 由于在追踪过程中要通过采集图像来提取特征点，所以图像的质量会影响追踪的结果。在光线较差的环境下（比如夜晚或者强光），拍摄的图像无法提供正确的参考，追踪的质量也会随之下降。 追踪过程中会逐帧比对图像与传感器结果，如果设备在短时间内剧烈的移动，会很大程度上干扰追踪结果。追踪的结果与真实的运动轨迹有偏差，那么用户看到的商家位置就不准确。 AROrientationTrackingConfigurationAROrientationTrackingConfiguration 只提供对三个姿态角的追踪（3DoF），并且不会开启 VIO。 Because 3DOF tracking creates limited AR experiences, you should generallynot use the AROrientationTrackingConfiguration class directly. Instead, usethe subclass ARWorldTrackingConfiguration for tracking with six degrees offreedom (6DOF), plane detection, and hit testing. Use 3DOF tracking only as afallback in situations where 6DOF tracking is temporarily unavailable. 通常情况下来讲，这么做的理由是因为 AROrientationTrackingConfiguration的追踪能力受限，官方文档不推荐直接使用。但是鉴于： 对三个姿态角的追踪，已经足以正确的展现商家相对用户的位置了。 ARWorldTrackingConfiguration 的高精度追踪，更适合于距离较近的追踪。比如设备相对桌面、地面的位移。但是商家和用户的距离动辄几百米，过于精确的位移追踪意义不大。 ARWorldTrackingConfiguration 需要规范用户的操作、确保环境光线良好。这对用户来说很不友好。 最终经过讨论，我们团队决定使用AROrientationTrackingConfiguration。这样的话，即便是在夜晚，甚至遮住摄像头，商家的位置也能够正确的进行展现。而且剧烈晃动带来的影响很小，商家位置虽然会出现短暂的角度偏差，但是在传感器数值稳定下来后就会得到校准。 坐标轴ARKit 使用笛卡尔坐标系度量真实世界。ARSession 开启时的设备位置即是坐标轴的原点。而 ARSessionConfiguration 的worldAlignment 属性决定了三个坐标轴的方向，该属性有三个枚举值： ARWorldAlignmentCamera ARWorldAlignmentGravity ARWorldAlignmentGravityAndHeading 三种枚举值对应的坐标轴如下图所示： 图5 三种枚举值对应的坐标轴 对于 ARWorldAlignmentCamera来说，设备的姿态决定了三个坐标轴的方向。这种坐标设定适用于以设备作为参考系的坐标计算，与真实地理环境无关，比如用 AR 技术丈量真实世界物体的尺寸。 对于 ARWorldAlignmentGravity 来说，Y 轴方向始终与重力方向平行，而其 X、Z轴方向仍然由设备的姿态确定。这种坐标设定适用于计算拥有重力属性的物体坐标，比如放置一排氢气球，或者执行一段篮球下落的动画。 对于 ARWorldAlignmentGravityAndHeading 来说，X、Y、Z 三轴固定朝向正东、正上、正南。在这种模式下 ARKit内部会根据设备偏航角的朝向与地磁真北（非地磁北）方向的夹角不断地做出调整，以确保 ARKit 坐标系中 -Z方向与我们真实世界的正北方向吻合。有了这个前提条件，真实世界位置坐标才能够正确地映射到虚拟世界中。显然，ARWorldAlignmentGravityAndHeading才是我们需要的。 商家坐标商家坐标的确定，包含水平坐标和垂直坐标两部分： 水平坐标商家的水平位置只是一组经纬度值，那么如何将它对应到 ARKit 当中呢？我们通过下图来说明： 图6 经纬度转换为坐标 借助 CLLocation 中的 distanceFromLocation:location方法，可以计算出两个经纬度坐标之间的距离，返回值单位是米。我们可以以用户的经度 lng1、商家的纬度 lat2 作一个辅助点（lng1,lat2），然后分别计算出辅助点距离商家的距离 x、辅助点距离用户的距离 z。ARKit 坐标系同样以米为单位，因而可以直接确定商家的水平坐标（x,-z）。 垂直坐标对商家地址进行中文分词可以提取出商户所在楼层数，再乘以一层楼大概的高度，以此确定商家的垂直坐标 y 值： 图7 高度信息提取 卡片渲染通常我们想展示的信息，都是通过 UIView 及其子类来实现。但是 ARKit只负责建立真实世界与虚拟世界的桥梁，渲染的部分还是要交给渲染引擎来处理。Apple 给我们提供了三种可选的引擎： Metal SpriteKit SceneKit 强大的 Metal 引擎包含了 MetalKit、Metal 着色器以及标准库等等工具，可以更高效地利用 GPU，适用于高度定制化的渲染要求。不过Metal 对于当前需求来说，有些大材小用。 SpriteKit 是 2D 渲染引擎，它提供了动画、事件处理、物理碰撞等接口，通常用于制作 2D 游戏。SceneKit 是 3D 渲染引擎，它建立在OpenGL 之上，支持多通道渲染。除了可以处理 3D 物体的物理碰撞和动画，还可以呈现逼真的纹理和粒子特效。SceneKit 可以用于制作 3D游戏，或者在 App 中加入 3D 内容。 虽然我们可以用 SpriteKit 把 2D 的卡片放置到 3D 的 AR 世界中，但是考虑到扩展性，方便之后为 AR 页面添加新的功能，这里我们选用 3D渲染引擎 SceneKit。 我们可以直接通过创建 ARSCNView 来使用 SceneKit。ARSCNView 是 SCNView 的子类，它做了三件事： 将设备摄像头捕捉的每一帧的图像信息作为 3D 场景的背景 将设备摄像头的位置作为 3D 场景的摄像头（观察点）位置 将 ARKit 追踪的真实世界坐标轴与 3D 场景坐标轴重合 卡片信息SceneKit 中使用 SCNNode 来管理 3D 物体。设置 SCNNode 的 geometry 属性可以改变物体的外观。系统已经给我们提供了例如SCNBox、SCNPlane、SCNSphere 等等一些常见的形状，其中 SCNPlane 正是我们所需要的卡片形状。借助 UIGraphics中的一些方法可以将绘制好的 UIView 渲染成一个 UIImage 对象。根据这张图片创建 SCNPlane，以作为 SCNNode 的外观。 **** 卡片大小ARKit 中的物体都是近大远小。只要固定好 SCNPlane 的宽高，ARKit 会自动根据距离的远近设置 SCNPlane的大小。这里列出一个在屏幕上具体的像素数与距离的粗略计算公式，为笔者在开发过程中摸索的经验值： 也就是说，假如 SCNPlane 的宽度为 30，距离用户 100 米，那么在屏幕上看到这个 SCNPlane 的宽度大约为 \\(530 / 100\\times 30 = 159) pt。 卡片位置对于距离用户过近的商家卡片，会出现两个问题： 由于 ARKit 自动将卡片展现得近大远小，身边的卡片会大到遮住了视野 前文提到的 ARSession 使用 AROrientationTrackingConfiguration 追踪模式，由于没有追踪设备的水平位移，当用户走向商家时，并不会发觉商家卡片越来越近 这里我们将距离用户过近的卡片映射到稍远的位置。如下图所示，距离用户的距离小于 d 的卡片，会被映射到 d-k ~ d 的区间内。 图8 过近卡片位置映射 假设某商家距离用户的真实距离为 x，映射后的距离为 y，映射关系如下： 这样既解决了距离过近的问题，又可以保持卡片之间的远近关系。用户位置发生位移到达一定阈值后，会触发一次新的网络请求，根据新的用户位置来重新计算商家的位置。这样随着用户的移动，卡片的位置也会持续地更新。 卡片朝向SceneKit 会在渲染每一帧之前，根据 SCNNode 的约束自动调整卡片的各种行为，比如碰撞、位置、速度、朝向等等。SCNConstraint的子类中 SCNLookAtConstraint 和 SCNBillboardConstraint 可以约束卡片的朝向。 SCNLookAtConstraint 可以让卡片始终朝向空间中某一个点。这样相邻的卡片会出现交叉现象，用户看到的卡片信息很可能是不完整的。使用SCNBillboardConstraint 可以解决这个问题，让卡片的朝向始终与摄像头的朝向平行。 图9 卡片朝向的两种约束 下面是创建卡片的示例代码： 12345678910111213141516171819202122232425262728// 位置SCNVector nodePosition = SCNVectorMake(-200, 5, -80); // 外观SCNPlane *plane = [SCNPlane planeWithWidth:image.size.width height:image.size.height];plane.firstMaterial.diffuse.contents = image; // 约束SCNBillboardConstraint *constraint = [SCNBillboardConstraintconstraint.freeAxes = SCNBillboardAxisY; SCNNode *node = [SCNNode nodeWithGeometry:plane];node.position = nodePosition;node.constraints = @[constraint]; 优化遮挡问题如果同一个方向的商家数量有很多，那么卡片会出现互相重叠的现象，这会导致用户只能看到离自己近的卡片。这是个比较棘手的问题，如果在屏幕上平铺卡片的话，既牺牲了对商家高度的感知，又无法体现商家距离用户的远近关系。 点击散开的交互方式经过漫长的讨论，我们最终决定采取点击重叠区域后，卡片向四周分散的交互方式来解决重叠问题，效果如下： 图10 卡片散开的效果 下面围绕点击和投射两个部分，介绍该效果的实现原理。 点击熟悉 Cocoa Touch 的朋友都了解，UIView 的层级结构是通过 hit-testing 来判断哪个视图响应事件的，在 ARKit 中也不例外。 ARSCNView 可以使用两种 hit-testing： 来自 ARSCNView 的 hitTest:types: 方法：查找点击的位置所对应的真实世界中的物体或位置 来自 SCNSceneRenderer 协议的 hitTest:options: 方法：查找点击位置所对应的虚拟世界中的内容。 显然，hitTest:options: 才是我们需要的。在 3D 世界中的 hit-testing就像一束激光一样，向点击位置的方向发射，hitTest:options:的返回值就是被激光穿透的所有卡片的数组。这样就可以检测到用户点击的位置有哪些卡片发生了重叠。 投射这里简单介绍一下散开的实现原理。SCNSceneRenderer 协议有两个方法用来投射坐标： projectPoint:：将三维坐标系中点的坐标，投射到屏幕坐标系中 unprojectPoint:：将屏幕坐标系中的点的坐标，投射到三维坐标系中 其中屏幕坐标系中的点也是个 SCNVector3，其 z 坐标代表着深度，从 0.0（近裁面）到 1.0（远裁面）。散开的整体过程如下: 图11 投射过程 散开后，点击空白处会恢复散开的状态，回到初始位置。未参与散开的卡片会被淡化，以突出重点，减少视觉压力。 后台聚类对于排布比较密集的商家，卡片的重叠现象会很严重。点击散开的卡片数量太多对用户不是很友好。后台在返回用户附近的商家数据时，按照商家的经纬度坐标，使用K-Means 聚类算法进行二维聚类，将距离很近的商家聚合为一个卡片。由于这些商家的位置大体相同，可以采用一个带有数字的卡片来代表几个商家的位置： 图12 聚合卡片 闪烁问题实测中发现，距离较近的卡片在重叠区域会发生闪烁的现象： 图13 闪烁 这里要引入一个 3D 渲染引擎普遍要面对的问题——可见性问题。简单来说就是屏幕上哪些物体应该被展示，哪些物体应该被遮挡。GPU最终应该在屏幕上渲染出所有应该被展示的像素。 可见性问题的一个典型的解决方案就是画家算法，它像一个头脑简单的画家一样，先绘制最远的物体，然后一层层的绘制到最近的物体。可想而知，画家算法的效率很低，绘制较精细场景会很消耗资源。 深度缓冲 ** ** 深度缓冲弥补了画家算法的缺陷，它使用一个二维数组来存储当前屏幕中每个像素的深度。如下图所示，某个像素点渲染了深度为 0.5 的像素，并储存该像素的深度： 图14 深度缓冲区 下一帧时，当另外一个物体的某个像素也在这个像素点渲染时，GPU会对该像素的深度与缓冲区中的深度进行比较，深度小者被保留并被存入缓冲区，深度大者不被渲染。如下图所示，该像素点下一帧要渲染的像素深度为0.2，比缓冲区存储的 0.5 小，其深度被存储，并且该像素被渲染在屏幕上： 图15 深度小的像素被保留 显然，深度缓冲技术相比画家算法，可以极大地提升渲染效率。但是它也会带来深度冲突的问题。 深度冲突深度缓冲技术在处理具有相同深度的像素点时，会出现深度冲突（Z-fighting）现象。这些具有相同深度的像素点在竞争中只有一个“胜出”，显示在屏幕上。如下图所示： 图16 深度冲突 如果这两个像素点交替“胜出”，就会出现我们视觉上的闪烁效果。由于每个卡片都被设置了 SCNBillboardConstraint约束，始终朝向摄像头方向。摄像头轻微的角度变化，都会引起卡片之间出现部分重合。与有厚度的物体不同，卡片之间的深度关系变化很快，很容易出现多个卡片在屏幕同一个位置渲染的情况。所以经常会出现闪烁的现象： 图17 角度变化引起的深度冲突 为了解决这 Bug 般的体验，最终决定牺牲深度缓冲带来的渲染效率。SceneKit 为我们暴露了深度是否写入、读取缓冲区的接口，我们将其禁用即可： 123 plane.firstMaterial.writesToDepthBuffer = NO; plane.firstMaterial.readsFromDepthBuffer = NO; 由于卡片内容内容相对简单，禁用缓冲区对帧率几乎没什么影响。 总结在到餐业务场景中，以 AR+LBS 的方式展现商家信息，可以给用户带来沉浸式的体验。本文介绍了 ARKit的一些使用细节，总结了在开发过程中遇到的问题以及解决方案，希望可以给其他开发者带来一点参考价值。","link":"/blog/2019/05/18/其他/ARKit：增强现实技术在美团到餐业务的实践/"},{"title":"UML系列时序图（顺序图）sequence diagram","text":"引言 用例图、类图、活动图、时序图之间是什么关系？ 时序图有什么作用？ 先来模拟一下三国演义的赤壁之战的时序图，先知道它到底长什么样子，再深入介绍： 小伙伴惊呆了，这样画战略图，一目了然，原来著名的战役是这么回事。这样看三国演义再也不会睡着了…… 再看看各个大人物的主要操作： 代码模拟各任务操作： [](file:///Applications/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0.app/Contents/Resources/common-editor-mac/mac.html# “复制代码”) 123456789101112131415161718192021222324252627282930313233public class 关羽 { public void 防守荊州();}public class 张飞 { public void 防守荆州前线();}public class 孙权 { public void 领兵相助();}public class 刘备 { public void 应战();}public class 孔明 { public void 拟定策略(); public void 联合孙权(); private void 借东风火攻();} [](file:///Applications/%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0.app/Contents/Resources/common-editor-mac/mac.html# “复制代码”) (以上为伪代码，只为说明问题，缩短文章长度)。分析一：用例图、活动图、时序图之间的关系 分析二：类图与时序图之间的关系 类图描述系统的静态结构，时序图描述系统的动态行为。 若出现了一个新的消息（不是类中的操作），则需要为类添加一个新的操作。 为类c添加k操作。如果这里不容易理解，可以参考上面的赤壁大战的时序图，你就知道该新加的操作到底是类B的还是C的。 时序图的作用用对象间的交互来描述用例。（注意是对象间的） 寻找类的操作。 时序图的概念时序图描述了对象之间传递消息的时间顺序，它用来表示用例的行为顺序。 时序图的组成 对象 对象是类的实例，对象是通过类来创建的，我们可以把类看作是创建对象的模版。 对象的符号 时序图中的每个大峡谷显示单独的列里。 对象的左右排列位置 对象的左右顺序并不重要，但是为了画图画的清晰整洁起见，通常应遵循一下两个原则： （1）把交互频繁的对象尽可能地靠拢。 （2）把初始化整个交互活动的对象（有时是一个参与者）放置在最左边。 生命线lifeline 表示对象的生存时间。生命线从对象创建开始到对象销毁时终止。 对象在生命线上的两种状态：休眠状态、激活状态。 消息 消息的概念： 对象之间的交互是通过相互发消息来实现的。一个对象可以请求（要求）另一个对象做某件事件。 消息从源对象指向目标对象。消息一旦发送便将控制从源对象转移到目标对象。 时序图中，消息的阅读顺序是严格自上而下的。 消息的类型与符号 实例：同步异步 你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。 你叫我去吃饭，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。 所以，要我请你吃饭就用同步的方法，要请我吃饭就用异步的方法，这样你可以省钱。^_^! （1）简单消息 简单消息是没有区分同步和异步的消息。 简单消息用从一对下岗的生命线指向另一个对象的生命线的直线箭头来表示，箭头上面标出消息名。 （2）同步消息 消息的发送者把进程控制传递给消息的接收者，然后暂停活动，等待消息接收者的回应消息。 你叫我去吃饭，我听到了就和你去吃饭；如果没有听到，你就不停的叫，直到我告诉你听到了，才一起去吃饭。 （3）异步消息 消息的发送者将消息发送给消息的接受者后，不用等待回应的消息，即可开始另一个活动。 你叫我去吃饭，然后自己去吃饭，我得到消息后可能立即走，也可能等到下班才去吃饭。 激活 激活的概念 当一个对象没有被激活期时，该对象处于休眠状态，什么事都不做，但它仍然存在，等待新的消息来激活它。 当一条消息被传递给对象的时候，它会触发该对象的某个行为，这就是说该对象被激活了。 当一个对象处于激活期时，表明该对象正处于执行某个动作。 激活的符号 激活用一个细长的矩阵框（在生命线上）表示。 矩形框的高度表示对象执行一个操作所经历的时间段，矩形的顶部表示动作的开始，底部表示动作的结束。 对象接收消息后可以由自己的某个操作来完成，也可以通过其他对象的操作来完成。 总结时序图到此结束，如果有需要补充的可以留言，lz定补上。 时序图还是听复杂的，遇到问题得好好分析…… 矩形框的高度表示对象执行一个操作所经历的时间段，矩形的顶部表示动作的开始，底部表示动作的结束。 对象接收消息后可以由自己的某个操作来完成，也可以通过其他对象的操作来完成。 比如下面的三张图表达的意思就不同了： 如果能把这三个图的区别搞明白了，时序图也掌握的差不多……Thinking….. 返回消息返回的消息。虚线的线性箭头表示。 自关联消息自身调用自身的方法。即自我调用的同步消息。 组合对一个交互过程的执行条件进行限定。 选择组合表明组合中的内容可能执行可能不执行，根据条件进行判断。 替换组合类似与if..else和switch，多个组合中选择一个执行。 其他组合情况下面的情况，摘自网络。 一个简单例子","link":"/blog/2019/05/18/其他/UML系列时序图（顺序图）sequence diagram/"},{"title":"图床及iPic","text":"有了图床神器 iPic，不论屏幕截图、还是复制图片，都可以自动上传、保存 Markdown 格式的链接，直接粘贴插入，够懒人吧？ 使用 Hexo | Heroku 或 WordPress 写博客、在公众号发文章、在知乎讨论、在豆瓣灌水、在论坛发帖、跨境做外贸电商 … iPic 带给你从未有过的插图体验。 当然，除了图片，你可以 上传普通文件，上传方式与图片完全相同。 上传方式图床工具 iPic 支持多种图片上传方式。下面我们来简单看下各个上传方式、以及分别适合在什么场景下使用。 1. 拖拽图片上传拖动是比较好玩的一种上传方式。只要将图片拖到菜单栏的 iPic 图标上，松手后就可以自动上传。 可以注意到，上传时菜单栏图标也会显示上传的进度。很简洁、却很实用，不再盲目等待。 使用这种方式，还可以一次性上传多张图片。图片上传后的顺序，和上传前选择的顺序一致。 2. 使用服务上传图片在 Finder 中使用 服务 上传也是很高效的方式。只要在图片上右击、然后选择服务中的 使用 iPic 上传 即可。 除了使用菜单，更高效的方式是使用快捷键。只要选中图片，然后按下 Command + U 快捷键，即可自动上传。 如果你觉得默认快捷键 Command + U 不方便，也可以在 系统偏好设置 &gt; 键盘 &gt; 快捷键 &gt; 服务 中修改 使用 iPic 上传对应的快捷键。同样，如果你的 Mac 中安装了很多程序、菜单中有很多你不需要的服务，也可以在这里进行关闭。 使用服务上传还有其他便利之处： 可以一次性上传多张图片 即使 iPic 并未运行，系统也会启动 iPic、并自动上传 注意：由于 macOS 系统更新机制的缘故，新安装 iPic 后上传服务可能未出现、或未翻译，可以等几分钟、甚至几小时后再试，iPic上传服务就会正常显示；也可以在 终端 手动更新服务菜单： /System/Library/CoreServices/pbs -update 3. 复制图片后上传iPic 会自动监测剪切板的变化，当复制图片后，该图片会出现在 iPic 菜单中 待上传区域。如果需要上传，点击菜单中该图片即可。手动上传比较适合临时上传少量图片。 除了手动点击菜单，还可以使用快捷键 Command + Shift + U 上传。当然，可以在偏好设置中修改此快捷键。 4. 上传其他 App 中的图片上述示例中主要介绍了图片文件的上传。另外，iPic 还支持支持其他程序中图片的上传。例如： 其中，对于图片格式，常见的 jpg、png、gif 等格式都是支持。 上传图片相关设置上传前压缩图片可以在 iPic 的 偏好设置 中开启「上传前压缩图片」选项，目前支持压缩的图片格式：jpg、png、gif 采用有损压缩，压缩后肉眼几乎无法看出区别，却可明显降低图片尺寸。使用压缩后的图片，既可以节省图片的存储空间，还可以加快图片加载速度、节省流量。 上传后不播放声音iPic 上传后会使用系统通知来提示。如果不喜欢该通知的声音，可进入 系统偏好设置 &gt; 通知，在左侧列表选择 iPic，然后在右侧取消「播放通知的声音」。 图床图床也即你选择存放图片的云服务。可以在 iPic 的 偏好设置 中添加你的图床： 添加后，可以在 iPic 的菜单中选择当前使用的图床： 目前 iPic支持下列图床：微博图床（即默认图床）、七牛云、又拍云、阿里云OSS 、腾讯云COS、Imgur 、Flickr 、AmazonS3 iPic 菜单Markdown 链接 这里有个很贴心的功能：切换普通链接、Markdown 格式链接时，如果粘贴板中有上一格式的内容，会转换后重新保存到粘贴板中。 图片上传记录iPic 会保存最近上传的 15 张图片，其中最后上传的 3 张图片会出现在一级菜单中，其他的则在 更多已上传图片 中。 点击已上传图片，则会复制该图片的链接。 当然，可以在 更多 菜单中清空图片上传记录。 iPic MoveriPic Mover 可以一键将已有Markdown 文件中所有图片迁移至新图床。批量上传图片、图床搬家，从未如此简单。 iPic Mover 更多介绍 其他媒体报道下载 iPic配合默认图床，可免费使用所有功能。如需使用其他图床，订阅 iPic 高级版即可。暂不支持 Windows. 如果你觉得 iPic 还不错，欢迎 到 Mac App Store 给个 5星、写点评论。当然，如果能分享给周围也需要iPic 的朋友，那就太赞了 ^_^ 商家在选择图床的时候，请慎重选择免费图床，毕竟众多免费图床网站注册条款里有禁止商用这一条，哪天关闭了图片外链或者商用，势必给用户带来很大的麻烦，很多免费图床总是好景不长，为什么呢？其实很简单，做相册站是要投入的，比如服务器、带宽、人员、技术投资、市场宣传等等！完全免费了，这些小站可能自己都难存活，所以总是不能长久使用！ 国内： 1、外链吧 有免费和收费的，100M 永久免费，收费相对便宜。不限外链、流量图片支持外链到所有网站。图片搬家、原图替换、水印、防盗链功能免费使用。 2、又拍网 付费外链，按流量和空间付费。价格比较贵 3、巴比豆 付费外链，价格和淘宝图片空间相同。 4、幻域图床 国内轻量级图床，采用国内cdn进行加速，图片加载速度快！需要注册即可上传图片，无限储存容量！ 国外： 1. 美国TripnTale – 无限免费旅游网络图片相册 美国TripnTale是一个免费旅游图片存储空间，提供无限量的存储空间，但有个要求是你上传的图片必须和旅游相关的。支持上传jpeg、gif、bmp、png格式图片，单个图片最大为6M，图片可以从flickr、picasa等中直接导入，然后给上传的图片进行注释，在地图上进行标注，最后发 布即可。 另外，还支持视频文件上传存储，单个视频最大为100M，上传速度还可以，图片能支持外链，后台能对图片进行管理，还能写日记，很适合旅游爱好者 2. 美国Tinyalbum – 无限免费相册+支持外链 Tinyalbum是一个提供免费相册空间和图片存储服务的网站，服务器位于美国亚利桑那州斯科特斯德市，界面上与Flickr有些相似，支持外链。TinyAlbum的操作上比较简单方便，上传速度也不错，能同时上传多张图片，相册能设置公开和私有。 另外，TinyAlbum对上传图片数量没有限制，单张图片限制在8M以内，但只能上传jpg、png格式的图片。在网站还能看到其他用户的相册，在后台用flash浏览自己的图片时，很好玩哦，图片会随着鼠标动，这种效果很 好. 3. 瑞士overpic – 免费无限网络相册 瑞士overpic提供免费的无限网络相册，无需注册就能上传，能支持外部链接，同时能上传10张图片，单个上传图片的大小限制为10M，支持的图片格式为：JPEG、JPG、BMP、PNG、GIF。可设置保存时间（一天、一周、一个月、三个月、六个月、永久），也能通过图片的网络地址来上传图片，但不是很稳定，上传完图片之后会自动生成一些html代码，论坛代码等方便用户复制代码进行外链 4. 美国imgplace – 提供无限的免费相册 美国imgplace提供免费的图片空间，能上传flash，图片，zip文件等，flash需要注册才能上传，其他不用注册也能上传，zip文件里面能放100张图片，但里面不能建文件夹，上传后会自动解压支持的图片格式有jpg, jpeg, gif, andbmp。上一次最多能上传50张图片，但图片加在一起的总大小不能超过100M，单个文件不能超过3M，没有带宽限制，但页面上广告很多，页面不是很好 5. 加拿大tinypic – 免费相册和视频空间 加拿大tinypic提供免费的相册和视频空间，是Photobucket旗下的一个网站，成立于2003年，由Alex Welch 和 DarrenCrystal 创办，每月有3900万的访问者，其中一半是来自美国的。 不用注册就能上传，上传的空间无限制，上传时可以改变图片的大小，有多种大小供选择，当然注册了更好，能建立自己的相册和视频空间，支持多个文件同时上传，图片上传后会产生一个很短的地址，能直接进行外部引用链接。还能对图片进行编辑，提供很多的编辑工具，基本上能满足你的要求,去体验吧，相当不错的一个空间了 6. 美国xs – 完全支持外链的图片空间 美国xs提供无限免费的图片空间，完全支持外链(以测试过），而且不用注册就能上传图片，支持上传JPG, JPEG, GIF, PNG, BMP, TIF,TIFF等格式的图片，单个上传文件最大为2Mb，能同时上传多张图片，每次上传最大数为500，只要你知道图片的网络地址也能上传图片，只要你的图片每月有一个点击量就不会删除你的图片，后台还支持FLASH相册制作，提供多种引用形式 7. Flickr – 免费相册支持外链 Flickr 是目前世界上最好的线上相片管理和分享应用程式之一。Flickr是由加拿大Ludicorp公司所开发设计。该公司于2004年2月正式推出Flickr网站。Flickr于2005年3月被雅虎收购，在6月,所有的资料都从原本位于加拿大的服务器迁入美国，使得所有的资料都受到美国联邦法的 管辖。 上传速度还不错而且还支持外链，有很多图片网站都是利用这个相册来装图片的，还能对你的图片进行特效外理以及在线图片编辑功能，每月上传空间限制在100M，但如果超过90天未登录，你帐号下的图片将会被删除。 8. Dumpt – 提供无限免费图片空间无需注册 Dumpt 是来自美国伊利诺伊州的无限免费空间，无需注册就能使用，页面很简洁，在首页就能上传，支持多文件上传，一次最多能上传10张图片，最大上传文件为3M，不但可以上传本地电脑上的图片，还可以上传URL网络图片，可以设置上传的图片为私有或公开。上传格式支持：JPEG, .JPG, .GIF,.PNG,.BMP。上传图片后可获得很多图片的外链地址，方便引用图片。 9. Pict –捷克的一个免费相册 它和别的相册不同，页面很特别，打开首页就是一个相册，你会看到有很多的很多的正方形框，上面标有“Upload images”，点击任意一个即可上传图片，允许上传JPG/PNG/GIF等格式的图片，最大上传的图片尺寸为3.5M。同时可选择多张图片上传，最多同时能上传多张不详，我曾选择过100多张图片同时上传也可以，首页会自动变长，方框会自动增多。不过上传多了，会减慢上传速度。 在网站底部会看到“Share this album”地址，通过这个网址可以链接到这个相册，图片支持外链，点击相册图片上的“Shareit”，即可出现引用地址。 10. RockYou – 无限图片上传空间+闪秀相册 RockYou是来自美国的免费网络FLASH相册网站，主要面对客户是博客使用者，现在在美国有大量的人在使用，网站提供电子相册、刮刮卡、闪闪靓字、靓字闪图、动态相册等BLOG扩展服务。目前，网站已经推出了中文版本。 你可以无限制的上传图片. 图片的格式必须为jpeg, gif, 或者 png；每张图片的大小不得超过 3M，你可以无限制的创建你的闪秀相册。想拥有多少，就拥有多少！用户可进行隐私设置。 11 . Thumbsnap – 非常简单好用的图片存储空间 Thumbsnap是来自美国乔治亚州的一个非常简单，好用的免费图片存储空间。界面简洁无广告，无需注册即可上传图片，对上传图片张数无限制，支持.jpg,.jpeg, .gif, .png格式的图片。支持的最大上传图片大小为2M。而且还支持图片外链。 上传非常简单，进入网站首页后，点击”UPLOADPhoto”按钮，选择一张图片即可自动上传，上传速度非常不错。上传完成后可获得图片的分享代码，提供4种代码。可通过点击”More LinkCodes”来获得图片的直接外链地址（Direct Link）。还可能过E-mail来分享。 12. SharePiks – 无需注册的免费图片存储空间 SharePiks是来自美国的一个免费图片存储空间，支持上传的最大图片为5M，无需注册即可上传。不允许上传违反法律的图片，图片也不可用于邮件发送、商业广告等。如上传了以上图片将会被删除，非以上图片可以永久保存。SharePiks不会公开你上传的图片，除非是你指定的人。 图片上传后会获得四种外链代码，有图片的直接外链地址、引用地址、HTML代码、论坛代码。也可通过点击”Click here to share thisimage with your friends”来将你的图片发送给你的朋友进行分享。 13. 美国imgur – 简单实用的无限外链相册 Imgur 是来自美国的一个免费网络相册，非常简单实用。Imgur由美国俄亥俄州大学的学生AlanSchaaf创建，Imgur的服务器位于美国得克萨斯州达拉斯市，其Alexa世界排名为1283，Imgur免费相册流行于美国、印度、英国、德国、加拿大、澳大利亚等国家。 使用Imgur相册时，不需要注册，Imgur不限制图片上传空间，支持图片直接外链，支持的图片格式有JPEG, GIF, PNG, TIFF, BMP,PDF, XFC (GIMP)。但TIFF, BMP, PDF,XFC格式的图片上传后会转换成PNG格式。非动画图片允许上传的最大为10M，但超过1M的图片都会被压缩成1M，允许上传的动画图片最大为2M（包括PNG、GIF），只要图片每3个月有一个浏览量，图片会被永久保存。可上传本地图片或通过图片URL地址上传。 14. 德国Imagez– 无需注册可外链的免费相册 Imagez是来自德国的一个免费相册，无需注册即可使用，且支持直接外链。支持上传jpg, jpeg, png, bmp,gif格式的图片，最大单个文件最大为5M，注册用户限制在10M，支持批量上传，还可上传zip文件。注册用户还可对相册设置密码保护。上传速度还不 错。 15. 美国Fotki– 支持FTP可外链的无限免费相册 Fotki是来自美国弗吉尼亚州的一个在线免费相册，成立于1998年，是一个比较老牌的相册了。存储空间容量不限，可创建多个相册，创建时可对相册设置访问密码。支持jpg、jpeg、png、psd、gif、bmp、tif、tiff图片格式，但上传的图片都会被转换成jpeg格式，单张图片大小限制不祥，免费注册为Fotki用户，可以使用Java、ActiveX控件、软件客户端、网页、URL网址、FTP、手机、E-Mail等多种方式上传图片。图片支持外链，可通过右键点击图片，查看属性，找到外链地址。 Fotki除提供免费相册外，还提供免费日记本、免费留言板、免费论坛等免费服务。还支持上传某些网站的视频如：youtube，但不支持国内视频网站上的视频上传。 16. 幻天图床 国外轻量级图床，采用了国外cdn加速图片缓存，操作简单方便！无需注册！即可上传图片。无需付费，空间图片无限制。","link":"/blog/2019/05/18/其他/iPic图床/"},{"title":"一图了解Google工具栈","text":"Google 一名前员工在 GitHub (1) 上分享了他在 Google 工作时日常使用的工具列表，并详细列出了这些工具列表的外界对应的替代方案。网友廖君结合现有的资料将学习笔记整理成脑图，并在原文基础上进行了一定的补充和翻译（xmind 源文件下载见链接2）。 （点击图片可以全屏缩放） 相关链接： github：https://github.com/jhuangtw-dev/xg2xg xmind 文件链接: https://pan.baidu.com/s/1iAEPf6OfC2YkG-k7TSyq8g 提取码: 6n9m","link":"/blog/2019/05/18/其他/一图了解Google工具栈/"},{"title":"两步认证技术","text":"什么是两步认证在介绍两步认证之前，首先来看下目前主流的几种认证方式。 [](https://dn-coding-net-production-pp.codehub.cn/ebc07cdb-948e-434f-ae4f-d14a81c7893d.png) 上图中的认证方式大体上可以分为三大类 1.You know ： 比如密码，这种只有我们知道的 2.You are ： 比如指纹，这种只有我们拥有的 3.You have ： 比如信用卡，这种只属于你的 了解上面所说的三大类之后，我们就很容易的理解下面几点。 什么是两步认证？两步验证，对应的英文是 Two-factor Authentication（2FA）,从名字可以看出，「两步」是 2FA 的重点，而两步就是我们上面所提到的You know + You Have ，也就是 密码 + 一次性密码（One Time Password，OTP） 为什么我们需要两步验证？传统的密码认证方式，如果在用户名密码在其他网站上泄露，任何用户都可以使用你的账号密码进行登陆做任何操作。但有了两步认证就能在一定程度上有效的避免这种情况的发生。因为在每次登录时，不仅需要输入您的帐户密码，还需输入移动设备为您生成的一次性动态验证码 OTP前面说过，2FA 中使用的是一次性密码（One Time Password，OTP），也被称作动态密码。一般 OTP 有两种策略：HOTP ( HMAC-based One Time Password) 和TOTP ( Time-based One-time Password)。目前被广泛使用的正是后者这种基于时间的动态密码生成策略。 算法大体是这样： 客户端和服务器事先协商好一个SECRET，用于一次性密码的生成过程，此密钥不被任何第三方所知道。此外，客户端和服务器都采用时间做计数器。 客户端对密钥和计数器的组合(SECRET,time/30)使用HMAC（Hash-based Message Authentication Code）算法计算一次性密码，公式如下：HMAC-SHA-1(SECRET, time/30) 各种算法加特效后成6位数字 在这里就只简要介绍该算法，如想深入了解 ==&gt; https://tools.ietf.org/html/rfc6238 基于TOTP的密码有如下特点 无需记忆，不会产生password这样的泄漏问题 动态生成,每30s生成一个，安全性大大提高 对网络无要求，离线下仍可正常使用 成本低，无需购买硬件和软件 两步认证流程 服务器随机生成一个类似于『DPI45HKISEXU6HG7』的密钥，并且把这个密钥保存在数据库中。 在页面上显示一个二维码，内容是一个URI地址（otpauth://totp/账号?secret=密钥?issuer=厂商） 客户端扫描二维码，把密钥『DPI45HKISEXU6HG7』保存在客户端。 客户端每30秒使用密钥『DPI45HKISEXU6HG7』和时间戳通过TOTP『算法』生成一个6位数字的一次性密码 两步认证的其他情况然后仅仅只是做好上面这种正常的验证流程是不够的，Coding 的两步认证在一些异常情况下做了很多处理。 生成的 OPT 应该是不能复用的，也就是用户在登陆或者危险操作时输入完一次 OPT 后，手机端 OPT 仍然未刷新时，在进行登陆或者危险操作时输入刚才的OPT是无效的，必须等待手机上OPT的刷新。 既然可以离线使用，那么怎么保证时间的差异性，我们服务端会兼容服务器时间的前后30s。从而有效的避免细微时间上差异而导致的验证失败，同时也避免了用户刚输入完 OPT 后还未做提交操作时 OPT 刷新而引起验证失败。 在遇到使用遍历所有6位数数字进行暴力破解 OPT 时，我们会对错误次数进行限制，90s 限制其错误次数能有效避免暴力破解的出现。 在开启两部认证后，其他所有登陆的客户端都会因为开启两部认证而过期，必须重新登陆。 两部认证的实现目前 Coding 采用的 https://github.com/wstrange/GoogleAuth 实现的TOTP 算法，在提供 TOTP算法之外，该库提供了可以存储用户 secret 的接口，采用的 ServiceLoader 方式，ServiceLoader方式可以通过链接了解更多==&gt;http://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html 在对外网开放的后台管理系统中，使用静态口令进行身份验证可能会存在如下问题： （1） 为了便于记忆，用户多选择有特征作为密码，所有静态口令相比动态口令而言，容易被猜测和破解； （2） 黑客可以从网上或电话线上截获静态密码，如果是非加密方式传输，用户认证信息可被轻易获取； （3） 内部工作人员可通过合法授权取得用户密码而非法使用； 静态口令根本上不能确定用户的身份，其结果是，个人可以轻松地伪造一个假身份或者盗用一个已有使用者的身份，给企业造成巨大的经济和声誉损失。本文主要介绍并实现了一种动态口令（OTP）的实现方式。 动态口令（OTP，One-TimePassword）又称一次性密码，是使用密码技术实现的在客户端和服务器之间通过共享秘密的一种认证技术，是一种强认证技术，是增强目前静态口令认证的一种非常方便技术手段，是一种重要的双因素认证技术，动态口令认证技术包括客户端用于生成口令产生器的，动态令牌，是一个硬件设备，和用于管理令牌及口令认证的后台动态口令认证系统组成。 otp从技术来分有三种形式， 时间同步、事件同步、挑战/应答。 （1） 时间同步 原理是基于 动态令牌和 动态口令验证服务器的时间比对，基于时间同步的 令牌，一般每60秒产生一个新口令，要求服务器能够十分精确的保持正确的时钟，同时对其令牌的晶振频率有严格的要求，这种技术对应的终端是硬件令牌。 （2）事件同步 基于事件同步的令牌，其原理是通过某一特定的事件次序及相同的种子值作为输入，通过HASH算法中运算出一致的密码。 （3）挑战/应答 常用于的网上业务，在网站/应答上输入 服务端下发的挑战码， 动态令牌输入该挑战码，通过内置的算法上生成一个6/8位的随机数字，口令一次有效，这种技术目前应用最为普遍，包括刮刮卡、短信密码、动态令牌也有挑战/应答形式。 使用阿里云身份宝（或者Google Authenticator）时间同步实现OTP动态口令 如上图，是一种基于时间同步的OTP计算方式，是通过客户端和服务器持有相同的密钥并基于时间基数，服务端和客户端采用相同的Hash算法，计算出长度为六位的校验码。当客户端和服务端计算出的校验码相同是，那么验证通过。 由于客户端需要存储密钥和计算校验码的载体，阿里云的身份宝（或者Google的Authenticator）提供了手机端的APP进行密钥存储和校验码计算。下面我们以这两款客户端为例，实现在应用采用OTP进行权限验证，主要流程如下图： 流程关键代码如下，（更详细代码，请Git下载:https://github.com/suyin58/otp-demo） 1 用户注册： 1.1 生成OTP密钥： 123String secretBase32 = TotpUtil.getRandomSecretBase32(64);oper.setOtpSk(secretBase32); 1.2 生成OTP扫描用字符串： 约定字符串格式如下： otpauth://totp/[客户端显示的账户信息]?secret=[secretBase32] 12String totpProtocalString = TotpUtil.generateTotpString(operCode, host,secretBase32); 1.3 将1.2中生成的字符串生成二维码，通过邮件发送给用户 1234567891011121314151617181920212223242526272829303132333435363738394041String host = &quot;otptest@wjs.com&quot;; // 自定义 String totpProtocalString = TotpUtil.generateTotpString(operCode,host, secretBase32); String filePath = f_temp; String fileName = Long.toString(System.currentTimeMillis()) +&quot;.png&quot;; try{ QRUtil.generateMatrixPic(totpProtocalString, 150, 150,filePath, fileName); }catch (Exception e){ throw new RuntimeException(&quot;生成二维码图片失败:&quot; + e.getMessage()); } String content = &quot;用户名：&quot;+operCode+&quot;&lt;/br&gt;&quot; +&quot;系统使用密码 +动态口令双因素认证的方式登录。&lt;/br&gt;请按以下方式激活手机动态口令：&lt;/br&gt;安卓用户请点击&lt;ahref=&apos;http://otp.aliyun.com/updates/shenfenbao.apk&apos;&gt;下载&lt;/a&gt;，&quot;+&quot;&lt;/br&gt;苹果手机在AppStore中搜索【身份宝】（Alibaba）。下载安装后，通过扫描以下二维码激活动态口令。&lt;/br&gt;&quot; +&quot;&lt;img src=\\&quot;cid:image\\&quot;&gt;&quot;; EmailBaseLogic emailBaseLogic = new EmailBaseLogic();// String to, String title, String content, String imagePath emailBaseLogic.sendWithPic(email,&quot;账户开立通知&quot;, content, filePath + &quot;/&quot;+ fileName); 1.4 将用户注册信息与1.1的OTP密钥存储到数据库中 数据存储代码（略） 2 客户端工具使用 2.1 下载APP 安卓用户下载地址：http://otp.aliyun.com/updates/shenfenbao.apk 苹果手机在AppStore中搜索【身份宝】（Alibaba），或者Google Authenticator 2.2 扫描二维码 使用下载的APP，扫描1.3邮件中的二维码，客户端获取密钥。APP使用密钥基于时间算出6位校验码（每分钟变化）。 1 用户登录 客户端输入登录用户名、用户密码，以及2.2客户端工具中的6位校验码。 1.1 服务端根据用户名和用户密码获取用户信息和密钥 代码参考略 1.2 服务端使用密钥基于时间算出6位校验码 12345678910111213141516171819202122232425262728293031323334353637383940414243String secretHex = &quot;&quot;; try { secretHex = HexEncoding.encode(Base32String.decode(secretBase32)); } catch (Base32String.DecodingException e) { LOGGER.error(&quot;解码&quot; + secretBase32 + &quot;出错，&quot;, e); throw new RuntimeException(&quot;解码Base32出错&quot;); } long X = 30; String steps = &quot;0&quot;; DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); df.setTimeZone(TimeZone.getTimeZone(&quot;UTC&quot;)); long currentTime = System.currentTimeMillis() / 1000L; try { long t = currentTime / X; steps = Long.toHexString(t).toUpperCase(); while (steps.length() &lt; 16) steps = &quot;0&quot; + steps; return generateTOTP(secretHex, steps, &quot;6&quot;, &quot;HmacSHA1&quot;); } catch (final Exception e) { LOGGER.error(&quot;生成动态口令出错：&quot; + secretBase32, e); throw new RuntimeException(&quot;生成动态口令出错&quot;); } 1.3 比较客户端和客户端校验码是否一致 代码参考略 其他，Demo中的例子可以使用身份 + 密码，先进行密码验证，在通过动态口令进行二次验证，使系统登录更加安全可靠。 GoogleAuthenticator是谷歌推出的一款动态口令工具，旨在解决大家Google账户遭到恶意攻击的问题，在手机端生成动态口令后，在Google相关的服务登陆中除了用正常用户名和密码外，需要输入一次动态口令才能验证成功，此举是为了保护用户的信息安全。那么，Authenticator采用了哪些算法？又是如何实现的？且看本文技术解读。 很多手机用户会使用 [Google Authenticator](https://code.google.com/p/google-authenticator/)（谷歌身份认证）来生成认证令牌，与传统单因子密码不同，其采用的是更安全的双因子（2FA two-factorauthentication）认证。FA是指结合密码以及实物（信用卡、SMS手机、令牌或指纹等生物标志）两种条件对用户进行认证的方法。只需要在手机上安装如此高大上的密码生成应用程序，就可以生成一个随着时间变化的一次性密码，用于帐户验证，而且这个应用程序不需要连接网络即可工作。 实际上Google Authenticator采用的算法是TOTP（Time-Based One-TimePassword基于时间的一次性密码），其核心内容包括以下三点： 一个共享密钥（一个比特序列）； 当前时间输入； 一个签署函数。 共享密钥 共享密码用于在手机端上建立账户。密码内容可以是通过手机拍照二维码或者手工输入，并会被进行base32加密。 手工密码的输入格式如下： xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx 包含该令牌的二维码的内容是一个URL： otpauth://totp/Google%3Ayourname@gmail.com?secret=xxxx&amp;issuer=Google 时间输入(当前时间) 输入的时间值来自于手机本身，一旦我们获得密钥后，就无需与服务器再进行通信了。但是最重要一点是务必确保手机上的时间是正确的，因为往后的步骤服务器会多次重复使用之前得到的时间值，服务器只会认准这个值。进一步说，服务器会比对所有提交的令牌以确认哪一个是你输入并提交的。 签署 签署所使用的方法是HMAC-SHA1。HMAC的全称是Hash-based message authenticationcode(哈希运算消息认证码)，以一个密钥和一个消息为输入，生成一个消息摘要作为输出，这里以SHA1作为消息输入。使用HMAC的原因是：只有用户本身知道正确的输入密钥，因此会得到唯一的输出。其算法可以简单表示为： hmac = SHA1(secret + SHA1(secret + input)) 事实上，TOTP是HMAC-OTP（基于HMAC的一次密码生成）的超集，区别是TOTP以当前时间作为输入，而HMAC-OTP以自增计算器作为输入，该计数器使用时需要进行同步。 算法 首先，要进行密钥的base32加密。虽然谷歌上的密钥格式是带空格的，不过base32拒绝空格输入，并只允许大写。所以要作如下处理： 123original_secret = xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxxsecret = BASE32_DECODE(TO_UPPERCASE(REMOVE_SPACES(original_secret))) 第二步要获取当前时间值，这里使用的是UNIXtime函数，或者可以用纪元秒。 1input = CURRENT_UNIX_TIME() 在Google Authenticator中，input值拥有一个有效期。因为如果直接根据时间进行计算，结果将时刻发生改变，那么将很难进行复用。GoogleAuthenticator默认使用30秒作为有效期(时间片)，最后input的取值为从Unix epoch（1970年1月1日00:00:00）来经历的30秒的个数。 1input = CURRENT_UNIX_TIME() / 30 最后一步是进行HMAC-SHA1运算 1234567original_secret = xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxxsecret = BASE32_DECODE(TO_UPPERCASE(REMOVE_SPACES(original_secret)))input = CURRENT_UNIX_TIME() / 30hmac = SHA1(secret + SHA1(secret + input)) 至此，2FA所需的两个因子都已准备就绪了。但是HMAC运算后的结果会是20字节即40位16进制数，应该没有人会愿意每次都输入这么长的密码。我们需要的是常规6位数字密码！ 要实现这个愿望，首先要对20字节的SHA1进行瘦身。我们把SHA1的最后4个比特数（每个数的取值是0~15）用来做索引号，然后用另外的4个字节进行索引。因此，索引号的操作范围是15+4=19，加上是以零开始，所以能完整表示20字节的信息。4字节的获取方法是： 1four_bytes = hmac[LAST_BYTE(hmac):LAST_BYTE(hmac) + 4] 然后将它转化为标准的32bit无符号整数(4 bytes = 32 bit)： 1large_integer = INT(four_bytes) 最后再进行7位数(1百万)取整，就可得到6位数字了： 123large_integer = INT(four_bytes)small_integer = large_integer % 1,000,000 这也是我们最后要的目标结果，整个过程总结如下： 12345678910111213original_secret = xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxxsecret = BASE32_DECODE(TO_UPPERCASE(REMOVE_SPACES(original_secret)))input = CURRENT_UNIX_TIME() / 30hmac = SHA1(secret + SHA1(secret + input))four_bytes = hmac[LAST_BYTE(hmac):LAST_BYTE(hmac) + 4]large_integer = INT(four_bytes)small_integer = large_integer % 1,000,000 我在这里准备了一个完整可执行的GO语言程序，感兴趣的朋友请点击点击 [这里](https://github.com/robbiev/two-factor-auth)进行查看。 英文出自： [Garbagecollected](http://garbagecollected.org/2014/09/14/how-google-authenticator-works/) 当你使用网银时，网站要求提供六位数动态口令。那么网站是如何验证这六位数是不是正确的呢？验证原理是什么？ 令牌实际相当于一个密码本，输进去AAA得到BBB，BBB是正确答案，验证通过。实际用的时候还会令牌会有一个时间有效性的问题，在不同的时间里输入AAA得到的答案是不同的，服务器端认为的正确答案是在随时间变动的，前一分钟有可能是DDD，后一分钟可能是MMM，一般在一个有效时间段（一般为一分钟）才会得到的答案BBB， 每个令牌都有不同ID，帐号先与令牌ID绑定，令牌会根据自身的特定ID与当前时间来计算出6位的随机码。服务器端程序因为有了令牌ID，所以也可以根据这个令牌的特征和当前时间来生成同样的随机码，然后你提交令牌生成的验证码，服务器会验证与它自己生成的是否一致，一致就通过，不一致就提示错误…… 动态口令牌使用唯一的128位种子将其初始化；其内部芯片每分钟都会使用一种算法，组合该种子与当前时间，生成一个随机的数字。而在认证服务器则采取和这个动态密码器同一种算法产生该随机数字，保证动态密码器和我行网银服务器的单一认证，就像每个客户都有了世界上独一无二的身份认证，保证客户使用网银的安全性。 服务器端和每个对应的“动态口令牌”都使用同样的一套算法，可以自定义计算数组的时间间隔。每批次“动态口令牌”都拥有唯一的序列号，然后服务器端和“动态口令牌”执行相同的计算程序，在设定好的相同的更新时间计算出新的数组. 其实上网输入密码服务器验证时跟这个动态口令牌没有有直接物理联系，唯一有联系就是二者根据唯一的序列号，利用公式，你算你的，我算我的。但同一时间算出的数字都是一样的，要不就会验证不能通过，这个6位阿拉伯数字的计算过程中时间是一个很重要的参数，使用时间参数时2者的时间必须要保持一致，要不就会时间不同步导致动态口令牌失效！ 对于失去时间同步的令牌，目前可以通过增大偏移量的技术（前后10分钟）来进行远程同步，确保其能够继续使用，降低对应用的影响，但对于超出默认（共20分钟）的时间同步令牌，将无法继续使用或进行远程同步，必须返厂或送回服务器端另行处理。 原理 动态密码的密码其实不是随机的，而是由规律的。当下动态密码分为两类，时间性和事件性。何为时间性动态密码?该类令牌产出动态密码是以时间为参数的，而事件性一般以使用次数为参数的。我们以时间性动态为主要说明对象。整个验证的过程如下： 1.动态密码令牌产生动态密码 以时间和种子为参数，进行迭代，得出动态密码，这里的时间一般是秒数。每个时间性动态密码令牌中会内置一个时钟芯片。 2.服务器校验动态密码。 服务器读取系统时间加上种子，以相同的迭代方法得出动态密码，然后双方进行比对。 讲到这边，可能有所怀疑难道令牌的时间和服务器的时间一定会一致吗？我的答案肯定是不一致的。那怎么能检验的过去呢？原来很简单，服务器校验是是在一个时间区间里校验的，比如现在是12：00，服务器会生成11：55-12：05中所有的动态密码，然后和令牌产生的动态密码比对，这样不就解决了时间不一致的问题了。另外服务器会把令牌和服务器相差的时间记录下来，下次检验的会先把这个偏移值记录下来，以减少动态密码迭代次数，这样就完成了另外一个比较重要的功能，偏移值自动调整。 动态口令，又叫动态令牌、动态密码。它的主要原理是:用户登录前，依据用户私人身份信息，并引入随机数产生随机变化的口令，使每次登录过程中传送的口令信息都不同，以提高登录过程中用户身份认证的安全性。 银行通常提供给用户两种动态口令:一种是固定数量的动态口令，最常见的就是刮刮卡。用户每次根据银行提示，刮开卡上相应区域的涂层，即可获得一个口令。刮刮卡成本低廉，使用方法简单，因此很多银行采用这种方法，如工商银行;另一种是硬件形式的动态口令，即电子令牌，它采用专用硬件，每次可以用自带的密码生成芯片得到一个当前可用的一次性动态密码，交通银行等就采用这种方式。一般来讲，每个客户端的电子令牌都有一个唯一的密钥，该密钥同时存放在服务器端，每次认证时令牌与服务器分别根据同样的密钥，同样的随机数和同样的算法计算出认证时的动态口令，从而确保口令的一致性和认证的成功。因每次认证时，随机数的参数不同，所以每次产生的动态口令也不同。每次计算时参数的随机性保证了每次口令不可预测，以保证系统安全。 OTP与常用认证技术比较 目前在信息系统中使用的增强型认证技术包括： 1 USBKey： 申请PKI证书。 2 动态口令卡：打印好的密码刮刮卡。 3 动态短信：使用电信通道下发口令。 4 IC卡/SIM卡：内置与用户身份相关的信息。 5 生物特征：采用独一无二的生物特征来验证身份，如指纹。 6 动态令牌：动态口令生成器和认证系统。 动态口令认证技术不足动态口令认证技术没有第3方权威机构认证，如果业务应用系统安全策略不完善的情况下，可能会受到中间人攻击。如某某银行使用时间型动态令牌受到网络钓鱼攻击。建议在应用中完善安全使用策略，划清口令使用权限，加强交易系统流程控制，用以提高系统安全性。 otpauth://totp/oa?secret=63985989418859891633&amp;period=60&amp;digits=8 secret：密钥，也就是上面生成的seed period:每60秒生成一次 digits：生成的随机码长度 Golang的实现 https://www.jianshu.com/p/e4b574be0ba6 Java服务端的实现： https://github.com/wstrange/GoogleAuth https://github.com/suyin58/otp-demo Python的实现： https://github.com/sahands/python-totp Flutter、Dart的实现： https://github.com/vubon/dart-totp 算法原理： https://blog.csdn.net/qq_29951983/article/details/80814272 Measure Measure","link":"/blog/2019/05/18/其他/两步认证技术/"},{"title":"几种常见的软件授权模式","text":"开源运动同样有自己的游戏规则和道德准则。 不遵行这些规则不但损害开源运动的健康发展，也会对违规者造成名誉和市场上的损失，更可能陷入法律纠纷和赔偿。 现今存在的开源协议很多，而经过Open Source Initiative组织通过批准的开源协议目前有58种。 我们在常见的开源协议如BSD、GPL、LGPL、MIT等都是OSI批准的协议。 什么是许可协议？ 什么是许可，当你为你的产品签发许可，你是在出让自己的权利，不过，你仍然拥有版权和专利（如果申请了的话），许可的目的是，向使用你产品的人提供一定的权限。 不管产品是免费向公众分发，还是出售，制定一份许可协议非常有用，否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作者身份，对于后者，你将不得不花费比开发更多的精力用来逐个处理用户的授权问题。 而开源许可协议使这些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可，开源许可协议还可以阻止其它人将某个产品据为己有。以下是开源界的 5 大许可协议。 以下是一些开源的软件许可协议。 强开源约束授权 GNU GPL GNU General Public Licence (GPL) 有可能是开源界最常用的许可模式。GPL保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利： 可自由复制 你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。 可自由分发 在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。 可以用来盈利 你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。 可自由修改 如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。 需要注意的是，分发的时候，需要明确提供源代码和二进制文件，另外，用于某些程序的某些协议有一些问题和限制，你可以看一下 @PierreJoye 写的Practical Guide to GPL Compliance 一文。使用 GPL 协议，你必须在源代码代码中包含相应信息，以及协议本身。 我们很熟悉的Linux就是采用了GPL。GPL协议和BSD， Apache Licence等鼓励代码重用的许可很不一样。 GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。 这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用，修改后的代码或者衍生代码)GPL协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。 这就是所谓的”传染性”。 GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 弱开源约束授权 MPL License（Mozilla Public License） 允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。 这种授权维护了商业软件的利益，，它要求基于这种软件的修改无偿贡献版权给该软件。 这样，围绕该软件的所有代码得版权都集中在发起开发人得手中。 但MPL是允许修改，无偿使用的。 MPL软件对链接没有要求。(要求假如你修改了一个基于MPL协议的源代码，则必须列入或公开你所做的修改，假如其他源代码不是基于MPL则不需要公开其源代码) *GNU LGPL * GNU 还有另外一种协议，叫做 LGPL （Lesser General Public Licence），它对产品所保留的权利比 GPL少，总的来说，LGPL 适合那些用于非 GPL 或非开源产品的开源类库或框架。因为 GPL 要求，使用了 GPL 代码的产品必须也使用 GPL协议，开发者不允许将 GPL 代码用于商业产品。LGPL 绕过了这一限制。 LGPL是GPL的一个为主要为类库使用设计的开源协议。 和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。 LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。 这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。 因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 MIT MIT 协议可 能是几大开源协议中最宽松的一个，核心条款是： 该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版权和许可提示。 这意味着：你可以自由使用，复制，修改，可以用于自己的项目。可以免费分发或用来盈利。唯一的限制是必须包含许可声明。MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。 MIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他了限制。 也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。 无开源约束授权 *BSD * BSD 在软件分发方面的限制比别的开源协议（如 GNU GPL）要少。该协议有多种版本，最主要的版本有两个，新 BSD 协议与简单 BSD协议，这两种协议经过修正，都和 GPL 兼容，并为开源组织所认可。 新 BSD协议（3条款协议）在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制。另外，该协议还禁止拿开发者的名义为衍生产品背书，但简单 BSD协议删除了这一条款。 BSD开源协议是一个给于使用者很大自由的协议。 基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 1、如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 2、如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 3、不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。 BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。 而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 Apache Apache 协议 2.0和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合（这里有一篇文章阐述这个问题）。 Apache 协议还有以下需要说明的地方: 永久权利 一旦被授权，永久拥有。 全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。 授权免费，且无版税 前期，后期均无任何费用。 授权无排他性 任何人都可以获得授权 授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。分发代码方面包含一些要求，主要是，要在声明中对参与开发的人给予认可并包含一份许可协议原文。 Apache Licence是著名的非盈利开源组织Apache采用的协议。 该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。 需要满足的条件也和BSD类似： 1、需要给代码的用户一份Apache Licence 2、如果你修改了代码，需要再被修改的文件中说明。 3、在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 4、如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。 你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。 使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 Creative Commons Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式： 署名权 必须为原始作者署名，然后才可以修改，分发，复制。 保持一致 作品同样可以在 CC 协议基础上修改，分发，复制。 非商业 作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网站，也有人认为非商业的意思是非盈利。 不能衍生新作品 你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原作者署名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。 另外 Freeware 不同于Free Software，Freeware为【免费软件】而非【自由软件】，虽然它是免费的软件，但是不见得必须要公布其源码，但看释出者的意见！这个东西与Open Source毕竟是不太相同的！此外，目前很多标榜免费软件的程序很多都有小问题! 例如假借免费软件的名义，实施窃取使用者数据的目的，所以“来历不明的软件，切勿安装”。 *Shareware * 【共享软件】，与【自由软件】有点类似的事，Shareware在使用初期，它也是免费的，但是到了所谓的“试用期限”之后，您就必须选择“付费后继续使用”或者“删除”了，通常这些【共享软件】都会自行撰写是小程序，让你在试用期使用之后就无法使用该软件了。 Close Source 程序的核心是封闭的，优点是有专人维护，您不需要去更动他；缺点则是灵活度大打折扣，使用者无法变更该程序成为自己想要的样式，此外，若有木马程序或者安全漏洞，将会花上相当长的一段时间来除虫。","link":"/blog/2019/05/18/其他/几种常见的软件授权模式/"},{"title":"手机没联网，支付宝也支付成功了，原理是什么 ？","text":"用支付宝时发现没开网络也能付款成功，原理是什么呢？有没有被破解的可能？ 事实上支付宝和微信的“当面付”产品，是一款联机在线支付产品，所以不允许双方均离线的场景下支付（这一点和公交卡圈存支付不一样，公交卡的近场支付事实上允许双方脱机）。 题目中所知的支付宝和微信没有网络，指的都是消费者客户端没有网络，而不是双方都没有网络。 严格来说，当面付产品（特指商户主动扫消费者钱包客户端上的 token 码进行支付的形态）必须要商户在线方可进行联机交易，原因有以下两点： 支付公司为了保证资金安全必须要确保每笔用户的支付行为背后都真正发生了资金扣款，所以在线联机确保支付成功是必要的。（这里解释了为什么不允许双方脱机） 商户为了确保用户的支付结果可信赖，必须要自己的终端或者系统从支付公司获得支付结果，而不能以消费者的支付结果凭证作为结论。以传统 POS 业务举例，你可以认为你的刷卡信息等同于支付宝的当面付码，商户必须要看到 POS 机打出支付成功单据后才认为支付有效，如果 POS 支付超时没有回执，光凭客户手中的银行短信通知是不会让客户走的，而是会冲正掉上一笔交易让客户重新刷一笔。（这里解释了为什么要选择商户必须联机的方案） 那么，我们来看看一个标准的当面付产品的信息流是什么样的（原谅我草草画了一下）： 我们可以看到在这个图里红色圈圈部分，商户系统和支付宝系统是对接上的，所以商户系统是联机的——而用户的手机，在展示 code的时候，我并未强调是否和支付宝服务端联机。 事实上，不论是微信还是支付宝都支持两种用户码生成模式，即在线码和离线码。 在线码其实很容易理解，用户目前是登录钱包的状态，只要点击【付款】按钮，客户端就向支付宝的服务端申请一个针对这个客户账户的支付凭证码并展现到客户手机上。 这个支付凭证码在支付宝的服务端会有一组数据库记录其与真实客户账户之间的关联，并且这份关联的有效期为60S，超过时效即便商户上送这个码，支付宝也会认为这是作废码而不予处理。 用户每次点开【付款】、等待超过 60S、主动刷新付款码，都会触发客户端向服务器申请一个新码的请求。 这个方案的好处是： 相对安全，每次码都是服务端生成。 业务灵活，即便对码的安全算法等进行较大的调整，也不用升级客户端，因为是服务端发码。 这个方案的坏处也显而易见： 用户的手机客户端必须在线联网，如果没有网络则无法获取付款码 用户即便在线，如果网络连接不好，也会出现点了付款等好久才看到码的情况，体验会不可控。 为了解决在线码方案的问题，离线码方案就出现了。 离线码的基本技术原理其实也不复杂，可以参考 @反方向的钟 的回答，比较简单的实现方式是： 用户登录后，服务端通过可信网络向用户客户端发送一个种子数据（每个客户的种子数据唯一，换用户登录后销毁原种子，重新下载种子）本地保存，当用户点击【付款】时，客户端利用这个种子数据 时间戳 + 一套安全算法可以生成一串数字，即离线码。 当用户使用离线码支付时，服务端通过一定算法校验这个码的确是来自于这个用户，随即确认用户授权完成支付。 离线码的好处不言而喻： 用户无需在线，就算在地下室等没有网络的场景一样可以使用 由于不依赖网络，所有码本地生成，所以客户体验很好，一点付款码就能出来 那离线码的劣势呢，我们看看： 用户 root/ 越狱手机后，保密存储的种子数据有可能被不法分子利用恶意程序获取到，导致离线码被随意生成用于消费。 恩……怎么说呢，毕竟现在不是发烧友主动 root 越狱的用户并不多，这是其一。 即便是 root 越狱，如果用户使用手机的习惯良好，被恶意程序攻击手机的概率也很低，这是其二。 每家公司都有自己的安全团队去保障自己客户端的数据安全，并不是说 root 的用户就只能坐以待毙了，否则微信和支付宝早被搞破产了，这是其三。 当然从我个人的角度来说，普通用户我都不建议去 root 或者越狱。 这个问题最粗暴的方案就跟反方向的钟所说的一样，监测到系统被 root 了就对用户限权（很多银行的客户端方案都是这么搞的）。 作为直接面向消费者市场且充分竞争的产品，微信支付和支付宝断然不会采用上面那个方案的。 怎么能又开放离线码给用户，又能确保用户支付安全，本身也是支付公司安全竞争力的一部分，这里就省略几万字了。 数据碰撞可能导致 A 用户的码扣到 B 用户的账户 恩，这里涉及一些算法问题，业务上就是碰了巧了 A 用户码算出来和 B 用户码一模一样且都有效（两个客户端都没作弊）。 在线码之所以可以避免这个问题是因为在线码是服务端发的，可以控幂等。 离线码是客户端自己根据算法生成的，所以没法控。 其实原因和哈希算法的数据碰撞类似，是个小概率的纯技术问题，就不展开赘述了。 解决方案：优化算法（确保碰撞概率低到一定程度甚至杜绝），如果真的出现就认栽给客户赔钱（赔多了技术部门老大就肯定痛定思痛优化算法了）。 事实上这个问题发生的概率极低极低，所以可以忽略不计。 算法调整不如在线码灵活 因为离线码生成逻辑都在客户端，所以通常来说安全算法升级会导致客户端升级，比在线码升级更影响用户一些。 分析到上面这层，各位产品经理相信应该就知道如何做方案选型了。（装个逼，事实上我觉得了解到上面那个层面是支付行业产品经理的基本素质） 后话： 我在写这个答案的时候其实都在刻意回避公司实现这些业务的具体逻辑和算法。而我个人并非当面付产品的产品经理，所以大家放心，这篇文章不算泄密。 写这个答案的目的是希望能尽量站在产品和业务角度还原业务原理，希望更多的非行业内的知友知其然，也知其所以然。","link":"/blog/2019/05/18/其他/手机没联网，支付宝也支付成功了，原理是什么 ？/"},{"title":"渐进式加载","text":"#####我们在PC端用浏览器看图片的时候,经常是先看到一张模糊图,然后再渐渐的变得清晰,这种情况在看漫画的时候尤其常见(模糊图如下),这种效果就叫做渐进式加载.渐进式加载能够大大的提升体验感,我们先来了解一下渐进式加载的原理. (图片来自网络) 1.JPEG要做到渐进式加载,我们的图片需要是JPEG格式,而JPEG格式的图片又分为两种,我们要做到渐进式加载的话,需要的是ProgressiveJPEG. (1)Baseline JPEG（标准型）这种格式的图片在保存信息的时候,是从上往下,将每一行的数据顺序的保存起来的,所以读一部分就展示的话,那么效果就会像是从上往下一点一点展示. (图片来自网络) (2)Progressive JPEG（渐进式）这种格式的图片在保存信息的时候,是一帧一帧的存储的,如果逐帧逐帧的读的话,就会先看到模糊图,然后一点一点变清晰 (图片来自网络) (图片来自网络) 2.解码如何判断是否JPEG格式的图片呢?下面引用一段Glide框架的代码1234567891011121314//ImageHeaderParser.javaprivate static final int EXIF_MAGIC_NUMBER = 0xFFD8;// JPEG.if (firstTwoBytes == EXIF_MAGIC_NUMBER) {return JPEG;} 我们可以看出,JPEG是以FFD8开头的其实JPEG是以FFD8开头,FFD9结尾,FFDA代表一个帧的开头FFD8 … FFDA … FFDA … FFDA … FFD9 1 Baseline JPEG 里面只有一个FFDAProgressive JPEG 里面含有多个FFDA比较完整的数据结构如下 (图片来自Wiki) https://en.wikipedia.org/wiki/JPEG 3.如何保存或者转换成JPEG(以下转换方法来自网络,由于非Java代码,所以没有做验证,特此说明一下) 1、PhotoShop在photoshop中有“存储为web所用格式”，打开后选择“连续”就是渐进式JPEG。 据说，需要勾选那个转换为sRGB选项，在某些浏览器下，图像设置为CMYK会出现一些问题！ ps保存为png-24且勾选交错才能把图片保存为渐进式图片 测试效果如下： 2、Linux检测是否为progressive jpeg ： identify -verbose filename.jpg | grep Interlace（如果输出None 说明不是progressive jpeg；如果输出 Plane 说明是 progressive jpeg。） 将basic jpeg转换成progressive jpeg：&gt; convert infile.jpg -interlace Planeoutfile.jpg 3、PHP使用imageinterlace和imagejpeg函数我们可以轻松解决转换问题。 1234567891011&lt;?php$im = imagecreatefromjpeg(&apos;pic.jpg&apos;);imageinterlace($im, 1);imagejpeg($im, &apos;./php_interlaced.jpg&apos;, 100);imagedestroy($im);?&gt; 4、Python123456789101112131415161718192021222324import PILfrom exceptions import IOErrorimg = PIL.Image.open(&quot;c:\\\\\\users\\\\\\biaodianfu\\\\\\pictures\\\\\\in.jpg&quot;)destination = &quot;c:\\\\\\users\\\\\\biaodianfu\\\\\\pictures\\\\\\test.jpeg&quot;try:img.save(destination, &quot;JPEG&quot;, quality=80, optimize=True, progressive=True)except IOError:PIL.ImageFile.MAXBLOCK = img.size[0] * img.size[1]img.save(destination, &quot;JPEG&quot;, quality=80, optimize=True, progressive=True) 5、jpegtran1jpegtran -copy none -progressive &lt;inputfile&gt;&lt;outputfile&gt; 6、C12345678910111213141516171819202122232425262728using (Image source = Image.FromFile(@&quot;D:\\temp\\test2.jpg&quot;)) {ImageCodecInfo codec = ImageCodecInfo.GetImageEncoders().First(c =&gt; c.MimeType== &quot;image/jpeg&quot;);EncoderParameters parameters = new EncoderParameters(3);parameters.Param[0] = newEncoderParameter(System.Drawing.Imaging.Encoder.Quality, 100L);parameters.Param[1] = newEncoderParameter(System.Drawing.Imaging.Encoder.ScanMethod,(int)EncoderValue.ScanMethodInterlaced);parameters.Param[2] = newEncoderParameter(System.Drawing.Imaging.Encoder.RenderMethod,(int)EncoderValue.RenderProgressive);source.Save(@&quot;D:\\temp\\saved.jpg&quot;, codec, parameters);} 7、C#转换 据说是如下的代码： 123456789101112131415161718192021using (Image source = Image.FromFile(@&quot;D:\\temp\\test2.jpg&quot;)) {ImageCodecInfo codec = ImageCodecInfo.GetImageEncoders().First(c =&gt; c.MimeType== &quot;image/jpeg&quot;);EncoderParameters parameters = new EncoderParameters(3);parameters.Param[0] = newEncoderParameter(System.Drawing.Imaging.Encoder.Quality, 100L);parameters.Param[1] = newEncoderParameter(System.Drawing.Imaging.Encoder.ScanMethod,(int)EncoderValue.ScanMethodInterlaced);parameters.Param[2] = newEncoderParameter(System.Drawing.Imaging.Encoder.RenderMethod,(int)EncoderValue.RenderProgressive);source.Save(@&quot;D:\\temp\\saved.jpg&quot;, codec, parameters);} 8、java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*** 转换图片为 流式加载* @author zhaosx**/public class ProgressiveJPEG { public static void main(String[] args) throws Exception { File file=new File(&quot;Z:/2.jpg&quot;); BufferedImage image = ImageIO.read(file); Iterator&lt;ImageWriter&gt; it =ImageIO.getImageWritersByFormatName(&quot;jpeg&quot;); ImageWriter writer=null; while(it.hasNext()) { writer=it.next(); break; //System.out.println(it.next()); } if(writer!=null) { ImageWriteParam params = writer.getDefaultWriteParam(); params.setProgressiveMode(ImageWriteParam.MODE_DEFAULT); //params.setCompressionQuality(0.8f); ImageOutputStream output = ImageIO.createImageOutputStream(newFile(&quot;Z:/22.jpg&quot;)); writer.setOutput(output); writer.write(null,new IIOImage(image,null,null), params); output.flush(); writer.dispose(); System.out.println(&quot;ok&quot;); } } } 4.效果明白了渐进式加载的原理后,我们就能想办法在app端也做到渐进式加载的效果了.(大概就是判断是否JPEG图片,然后根据每一帧的节点来判断并决定是否需要加载) 下面展示一下效果图(1)原图 (Progressive JPEG的图一打水印就变成Baseline JPEG,应该是CSDN打水印保存的时候处理了) (2)解码到第一个FFDA与第二个FFDA的中间 (3)刚好解码到第二个FFDA (4)解码到第五个FFDA 需要看图片二进制结构的,可以下载一些工具(如hex-editor-neo) hex-editor-neo下载 图片的尺寸大小 同一张jpg图片，如果保存为基本式和渐进式那个尺寸更小呢？ 根据我拿3终不同风格图片做测试，发现，百度百科中所说的渐进式图片的大小比基本式的小是不准确的。 其中，两者大小关系基本上没有什么规律。下面是我的测试结果： 图片品质59%及其以下时候，渐进JPEG图片更小；品质60%及其以上，基本JPEG更小图片品质82%及其以上时候，渐进JPEG图片更小；品质81%及其以下，基本JPEG更小无论图片品质多少，都是渐进JPEG图片更小 不过，个人臆测，从概率学上讲，大多数情况下，渐进式JPEG比基本式图片尺寸小一点。然而，其中的大小差异与原图尺寸相比，不值一提，因此，所谓图片大小不能作为两种图片选择的依据。 下载呈现速度 一个名叫Ann Robson的人，最近对各个浏览器下渐进式图片呈现做了测试。 下图为FireFox浏览器下呈现速度的对比图： 当大图轮廓加载OK的时候，小图最后一个乳猪还没有出世面；而基本式乳猪图还没有开始加载！显然，罗伯森是想告诉我们，渐进JPEG下载更快。 下表为其在各个浏览器下测试的结果： 浏览器 (特定测试版本) 渐进jpeg前景渲染 渐进jpeg背景渲染Chrome (v 25.0.1323.1 dev Mac, 23.0.1271.97 m Win) 渐进地 (相当快！) 渐进地 (相当快！)Firefox (v 15.0.1 Mac, 12.0 Win) 渐进地 (相当快！) 文件下载后立即地(慢)Internet Explorer 8 文件下载后立即地(慢) 文件下载后立即地(慢)Internet Explorer 9 渐进地 (相当快！) 文件下载后立即地(慢)Safari (v 6.0 Desktop, v 6.0 Mobile) 文件下载后立即地(慢) 文件下载后立即地(慢)Opera (v 11.60) 文件下载后立即地(慢) 文件下载后立即 结论很简单，Chrome + Firefox + IE9浏览器下，渐进式图片加载更快，而且是快很多，至于其他浏览器，与基本式图片的加载一致，至少不会拖后腿。 Scott Gilbertson对渐进式图片有其他的补充： 1. 你用永不知道基本式图片内容，除非他完全加载出来； 2. 渐进式图片一开始大小框架就定好，不会像基本式图片一样，由于尺寸未设定而造成回流——提高的渲染性能； 3. 渐进式图片也有不足，就是吃CPU吃内存。 内容就是这些，权衡使用在你手。一般而言，大尺寸图片建议使用渐进式JPEG. 另一种实现 图片在加载过程中由模糊到清晰的一个加载过程，需要两张图片实现，一张体积比较小，一张为原图，体积比较小的图片会先加载成功，然后对其进行模糊化处理，直到原图加载成功后，用原图替代体积较小的图。 css filter模糊处理： html 12345678910&lt;div class=&quot;placeholder&quot; data-large=&quot;&lt;https://pic2.zhimg.com/50/v2-c5174d0b98facea9584e7766862decdd_400x224.jpg&gt;&quot;&gt; &lt;imgsrc=&quot;&lt;https://pic2.zhimg.com/50/v2-c5174d0b98facea9584e7766862decdd_60w.jpg&gt;&quot;class=&quot;img-small&quot;&gt; &lt;div style=&quot;padding-bottom: 66.6%;&quot;&gt;&lt;/div&gt;&lt;/div&gt; css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.placeholder { width: 200px; background-color: #f6f6f6; background-size: cover; background-repeat: no-repeat; position: relative; overflow: hidden;} .placeholder img { position: absolute; opacity: 0; top: 0; left: 0; width: 100%; transition: opacity 1s linear;} .placeholder img.loaded { opacity: 1;} .img-small { filter: blur(50px); /* this is needed so Safari keeps sharp edges */ transform: scale(1);} js 1234567891011121314151617181920212223242526272829303132333435363738394041window.onload = function () { var placeholder = document.querySelector(&apos;.placeholder&apos;), small = placeholder.querySelector(&apos;.img-small&apos;) // 1: load small image and show it var img = new Image(); img.src = small.src; img.onload = function () { small.classList.add(&apos;loaded&apos;); }; // 2: load large image var imgLarge = new Image(); imgLarge.src = placeholder.dataset.large; imgLarge.onload = function () { // small.classList.remove(&apos;loaded&apos;); imgLarge.classList.add(&apos;loaded&apos;); }; placeholder.appendChild(imgLarge);} canvas模糊处理： html 123456789101112131415&lt;div class=&quot;figure&quot;&gt; &lt;div class=&quot;aspect-ratio-fill&quot;&gt;&lt;/div&gt; &lt;img id=&quot;smallImg&quot; class=&quot;small-img&quot; crossorigin=&quot;anonymous&quot;src=&quot;&lt;https://pic2.zhimg.com/50/v2-c5174d0b98facea9584e7766862decdd_60w.jpg&gt;&quot; alt=&quot;&quot;&gt; &lt;canvas id=&quot;canvas&quot; class=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;img class=&quot;big-img&quot; data-src=&quot;&lt;https://pic2.zhimg.com/50/v2-c5174d0b98facea9584e7766862decdd_400x224.jpg&gt;&quot;&gt;&lt;/div&gt; css .12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455figure { position: relative; width: 200px; overflow: hidden;} .aspect-ratio-fill { padding-bottom: 66.67%;} .figure img,.figure canvas { position: absolute; top: 0; left: 0; width: 100% !important; height: 100% !important; opacity: 1; transition: opacity 2s linear;} .canvas.loaded { opacity: 0;} .small-img { display: none;} js 1234567891011121314151617181920212223242526let smallImg = document.querySelector(&apos;.small-img&apos;), canvas = document.querySelector(&apos;.canvas&apos;), bigImg = document.querySelector(&apos;.big-img&apos;);ctx = canvas.getContext(&apos;2d&apos;);smallImg.onload = function () { StackBlur.image(smallImg, canvas, 20, true); if (bigImg.getBoundingClientRect().top &gt; 0 &amp;&amp;bigImg.getBoundingClientRect().bottom &lt; window.innerHeight) { bigImg.setAttribute(&apos;src&apos;, bigImg.dataset.src); bigImg.onload = function () { canvas.classList.add(&apos;loaded&apos;); } }} Jpeg渐进式图像数据解析为了更好的优化客户端体验，客户端在图像压缩的时候采用了渐进式Jpeg压缩。渐进式Jpeg的好处是，只需要很少的一部分数据包，就能够解码出一副完整的图像，随着数据的增加，图像会不断变清晰。渐进式图像还有一个好处是每一处SOS的Huffman编码都是优化编码，平均图像size会小一些。 https://blog.csdn.net/APIX_CN/article/details/49780397?utm_source=blogxgwz26","link":"/blog/2019/05/18/其他/渐进式加载/"},{"title":"黑客为什么不攻击支付宝？","text":"“支付宝被黑客搞了！！！” 女票发给我一段视频。 中哥我虎躯一震，这么大的事儿居委会咋没通知我？？赶紧打开视频。 我去，这是黑客吗？谁来解释一下，明明是黑客，为神马穿得这么白，连脸都是白的。。。 还有，你带着那个面具敲代码，能看清鬼啊？这是在练盲打么？？闭着眼睛攻击支付宝，是为了表现一种蔑视和侮辱么？？？ 往后看了五分钟，冷静了一下，我不禁三呼卧槽。这是一个叫做《智造将来》的节目，浙江卫视的。虽说黑客的装束槽点满满，但干的事情还是很刺激的： 他们在试图推倒三个身娇体柔的支付宝账户，把账户里的钱偷偷转走。。。 主持人说，他们之所以搞得这么硬核，就是为了现场检测一下支付宝的安全性能到底好不好，你的钱放在支付宝里到底安不安全。 为了让大家舒爽看片，这里中哥插一嘴： 支付宝怎么保护大家的账户安全呢？并不是你想的那样，在杭州有一个脸上贴着“支”的敢死队，每天在网上和黑客手动硬刚。 真实情况是，“安保工作”是由安全部门的童鞋开发的一套“风控系统”来自动完成的。这套风控系统有点像参加高考的你，在之前的学习阶段有“老师”各种辅导，但是一旦被推到实战场景里，就只能靠自己“自动滑行”了。 回到节目现场，情况很是危急。一边是黑客奋力攻击，一边是受害者支付宝各种殊死抵抗。 就在我为支付宝捏一把汗的时候，剧情突然走向癫狂：受害者家属也来到了现场！ 这个男人叫雄文，是支付宝风控部门的老大，蚂蚁金服的副总裁。支付宝的安全系统，就是他团队的作品。一堆头衔你也记不住，这么说吧，如果你支付宝里钱丢了，就找他赔。 看到雄文这个名字我就震精了，目测支付宝安全老大，应该管理很多码农。不叫“佳娃”（Java）或者“稀加”（C+），居然叫雄文，这是摆明了有野心跟中哥抢夺10w+啊。。。 对不起跑偏了，继续看节目。 对第一个账户的攻击开始惹。黑客攻击主持人蒋昌建的支付宝。他们事先通过钓鱼 Wi-Fi收集了他的手机号，然后又利用近场读卡器偷到了他的银行卡号。用这些信息尝试 重置他的支付宝密码。然而，重置支付宝密码还需要身份证，黑客并没有办法拿到蒋昌建的身份证号。于是登录他的支付宝 失败 。 对第二个账户的攻击开始惹。黑客攻击的是嘉宾王孟秋的支付宝。这次攻击的对象黑客通过“撞库”拿到了王孟秋的支付宝登录密码，顺利登陆。但是由于不知道支付宝支付密码，所以转账失败。 对第三个账户的攻击开始惹。这次攻击目标是现场一位观众的支付宝。由于提前在这部手机里植入了木马，黑客可以完全控制这部手机，所以他们使用手机验证码就直接登陆了支付宝。然后黑客选择修改支付密码，修改支付密码需要验证个人信息，黑客又通过手机里存储的银行卡和身份证照片，成功修改了支付密码。转账眼看就要成功。 我满心激动，等着看黑客使出最后的杀手锏一击致命。。。 然后。。。突然。。。转账失败了！节目结束了！结束了！束了！了！ 纳尼？XX都X了你就给我看这个？我期待中支付宝被黑客干翻在地的场景被XX总局吃了吗？ 我突然想起了一个新闻： 女棋士赢了。。。 用了好久，我才接受支付宝真的赢了这个事实。虽说在节目上支付宝赢了，然而，在日常和黑客的乱斗中，支付宝难道就没有输的时候吗？我不信。 于是，中哥下定决心要去和雄文聊聊，写一篇雄文背后故事的雄文，让大家认识一下我雄文里的雄文到底是怎样的雄文。 几天后，在支付宝童鞋的引荐下，我坐在了雄文大叔的对面。我不是要和他下棋，而是要探究一下支付宝背后的秘密。 雄文 （一） 支付宝能不能扛住“黑客围殴”？ “老实说，节目上被攻击的支付宝，是不是假的支付宝？”我劈头盖脸就问。 “当然是真的支付宝。”雄文云淡风轻。 “你怎么证明？”我说。 “为了电视节目，如果要模拟一个假的支付宝，还要做出一套假的风控系统，要开发好多代码。太麻烦了。还不如用真的。况且真的风控系统我们做了十几年，干嘛要用假的。。。”他说。 “所以，被攻击的那三个账户，也是真的咯？”我问。 “如假包换”他说。“支付宝账户都是实名制，背后挂着身份证的。不仅用不了假的，做节目的时候，连真的都差点用不了。。。” 纳尼？雄文大叔在说什么？ 原来，在节目录制之前，需要进行一次彩排。彩排时候选定了三个账户被黑客一顿锤，支付宝防住了，一切都没问题。结果第二天要正式录制的时候，奇特的事情发生了——这三个账户被支付宝风控系统判定为受攻击高危账户，直接保护起来了，暂时限制对外转账功能一段时间。。。无奈，节目组只能另外换三个账户。也就是最终出现在节目上的那三个。 “系统都是自动运行的，被封住的账户，就连我也无权解开。。。”雄文一摊手。 我去，你是魔鬼吗？支付宝风控系统疯起来连自己人都刚啊，六亲不认，肃然起敬。 “这支付宝的风控系统，叫个啥名？” “叫 AlphaRisk！”他说。 “账户是真的，攻击是真的，AlphaRisk 的防御也完全是自动化的，那么也就是说在节目现场，你根本不知道它能不能挡住黑客的进攻咯？”我问。 “是的。” “那你慌么？” “有点。” “。。。” 雄文这么不按套路出牌的坦诚，让我本来准备好的一万个质疑都瞬间失效。 “录节目时你最慌的是什么时候？” “AlphaRisk判断一个账户是不是被盗用，是要综合很多指标来判断的。其中一个重要的维度就是看转走多少钱。结果在节目彩排的时候，黑客强行登录支付宝账号以后，居然只转5块钱！说实话，这么少的金额，是有可能被AlphaRisk 放过的。转这么少钱，也没跟我商量，当时我真是捏了一把汗。还好支付宝给力，拦住了。”雄文吐槽。 感觉白衣黑客们费劲气力，才看清5这个按键在哪。。。 雄文当时的表情是这样的。 看看，在节目上黑客攻击三个支付宝账户都功败垂成时，雄文有多开心。 支付宝曾对外发布了一个数据：资损率低于千万分之五。意思就是，存在支付宝里的钱，出问题的概率低于千万分之五。 千万分之五，真牛X！等等，好像哪里不对。。。假如我就是那倒霉的千万分之五，我是不是要去杭州上访？ “不用，如果你的支付宝真的没被拦住，被盗了，我们赔给你就是了。”雄文淡定地说。 确实，我记得支付宝从2004年上线之后，就有一个口号叫“你敢付，我敢赔。”只不过说实话这么多年中哥的支付宝账户也没丢过钱，不知道他们到底是赔不赔。。。既然今天支付宝副总裁都这么说了，那我放心了。 也就是说，理论上支付宝并不能保证防御住每一次具体的黑客攻击，但这对于普通用户来说那不重要，因为每个人的钱都是绝对安全的。 说实话，见到雄文之前，我是没想到他会这么坦诚的。好不容易逮到他，得多问点电视台不让播的内容。 接下来就到了中哥硬核科普时间了，今天的话题是： ** ** 你家支付宝的门神——AlphaRisk——到底是咋工作的？ （二）黑客偷钱，总共分三步 你可以简单想象一下，用支付宝转账，要过三道大门： 第一道：登录密码； 第二道：支付密码； 第三道：AlphaRisk 风险控制系统。 雄文说。 来，我们一道一道地科普。 第一关、登录密码 这个很简单。你登录支付宝的时候，要输入登录密码，证明你是你。 你可能会杠说，不对啊，我每次在手机上登录支付宝，不用输入密码，直接就打开了啊！没错，那是因为你经常登录，并且没有换手机。这种情况下，你账户有风险的概率很低。支付宝没有必要每次都打扰你，让你输密码。 这里，我们学到了今天最重要的一个概念：打扰率。 一个App，每要求你做一件事，比如输入密码，比如让你接收一个短信验证码，这都算一次打扰。而在用户体验中，打扰是要扣分的。所以，通过频繁打扰用户的方式来保证你的“绝对安全”，并不是个好办法。 由上图可知，频繁打扰是一件很烦的事，这个问题涉及到深奥的产品哲学，我们在最后还会详细讨论。 我们继续说登录密码。 如果你在一部手机里很久都没有登录支付宝，那是需要重新输入密码的。如果你换了一部新手机登录支付宝，那么不仅要输入密码，还要二次校验（短信验证码或者回答安全问题）。 所以，黑客单单偷到了你的支付宝登录密码，是无法直接登录你的支付宝的。那他们是怎么做的呢？中哥可以告诉你几种可能性： 1）你的身份信息泄露严重。 刚才我说到，支付宝密码是可以被重置的，需要提供身份证、银行卡等一系列信息。如果这些信息隐私信息都被黑产掌握了，那么从某种程度上说，他就是你了。没办法，你的密码也会被重置，他可以登录。 2）你的手机丢了。 你的手机丢了的意思是——你的手机不仅丢了，并且没有设置开屏密码或指纹解锁。否则坏人解不开你的手机，就跟没丢一样。 反正黑客只要进入你的手机主屏，接下来就有两种情况： 你在几天内用过支付宝，那么，黑客不用输入密码，就像你本人使用一样，能直接登陆。 你最近没有登录支付宝，那么支付宝会要求你输入密码，此时黑客可以选择重置密码，选择手机接收验证码，也是可以重置密码成功登录的。 此乃第一关。 第二关、支付密码 ** ** 如果坏人破解了你的登录密码，那么接下来他想把钱转走，就要遇到“支付密码”这道关口。 你记得不，支付宝会要求你的支付密码和登录密码不同，目的就是为了防止坏人破解了你的登录密码，直接就能攻破你的支付密码。 这里有个小细节：支付宝最近几年会鼓励你用指纹代替支付密码。当然，用户也可以手动选择切换——这次支付不用指纹，就用密码。这关实际上挡不住黑客，但是你要记住这个细节，一会儿有用。 接下来我们继续说黑客怎么攻破你的支付密码： 1）用你之前泄露的其他登录密码尝试。 一般人不会把支付宝支付密码和其他应用的登录密码设置为一个，这种方法成功率从实战数据中看比较低。 2）重置你的支付密码。 重置你的密码，需要你的个人信息，或者需要你的手机。如果黑客已经掌握了这些，那么他很可能重置支付密码成功。 你一定以为：黑客破了我的支付密码，钱就会被转走了噜。 错！图样图森破！黑客的噩梦才刚刚开始。 马上就会进入第三步骤：AlphaRisk。 第三关、AlphaRisk 前面两步，黑客的所有操作，其实 AlphaRisk 都在默默看着，只是它没说话而已。 当前两个密码都输入正确后，AlphaRisk 会作为最后一道门神，像尉迟恭和秦叔宝一样，决定放不放走这个钱。 那么，AlphaRisk 判断的依据是什么呢？ 举个栗子：一个老警察靠在公交车站，他如何发现一个正在挤上车的小伙是个贼呢？他会通过几个维度：眼神、举止、穿着、和前人之间的距离、是否遮挡手上的行为等等等等。有经验的警察不用等到“偷钱”那个动作发生，就已经能准确判断谁是小偷。 同样，AlphaRisk 也像一个老警察，它也会从一些维度来观察一笔交易。比如：设备、环境、偏好、行为、关系、账户、身份、交易，等等。 如果其中所有维度任何一个或者多个有异常，都会引起 AlphaRisk 的警觉，直接强制操作者进行人脸活体验证，手机验证码，或者干脆就截断交易。 不知你感受到了没。日常你用支付宝转账给别人，你觉得非常自由，支付宝从来不添乱，恰恰是因为 AlphaRisk对每一笔交易都做了极其细致的评估之后，觉得没问题才不拦着的。 你可能会问，为神马 AlphaRisk 等到那么惊险的最后一步才起作用呢？早点出来这个“哔——”就装得不够到位吗？ 这个地方又涉及到刚才的概念——打扰率，如果支付宝在输入交易密码之前就用 AlphaRisk 跳出一堆人脸验证手机验证码，那就会让你觉得很烦。作为一个有尊严的App，支付宝把安全性最强的 AlphaRisk 放到最后一步，就是为了最少的打扰。 下面说 AlphaRisk 的工作细节。 以《制造将来》里面的操作举例。攻击第三个手机的时候，黑客已经拿到了登录密码和交易密码，并且是照着身份证的照片把身份证号一次输入正确的，为神马AlphaRisk 会认为这个交易有风险呢？ 用大家都能理解的话说，大概是酱： 首先，支付宝是在陌生的手机上登陆的； 其次，支付宝的登录密码是刚刚被重置过的； 再次，支付宝的支付密码也刚刚被重置过； 还有，转出账户和被转入账户之间没有任何人际关联； 还有，转出账户所在城市和被转入账户所在城市，本身就很少存在转账行为； 等等等等。 其实，还有很多不正常的维度可供 AlphaRisk 参考。 比如刚才我故意卖了关子的一个细节：操作者本来习惯用指纹支付，突然今天强制改成了密码支付。这一个蛛丝马迹，起码说明事出有因，足够让 AlphaRisk关注到这次交易的风险。 啊，说了这么多，终于大概解释清楚了支付宝风控的三道关。 雄文告诉我，支付宝也不是一开始就有这么强大的智能风控能力的。 在2004年，支付宝刚上线，他们就大喊“你敢付，我敢赔”的口号。实际上在那个时候，支付宝还真是“敢赔”。意思是，虽说风控技术有点糙，但我们胆子大，敢赔钱给用户而已。。。 “那后来你们是怎么一步步提高风控能力的呢？”我好奇的地问。 “你要是那么哗哗地赔钱，你也会拼了老命提高风控能力的！” “。。。” （三）偷不到钱，那骗钱行不行？ 有一个问题其实很值得一说。 宽泛来说，支付宝账户受损失，有两种情况：1、账户被盗；2、你被诈骗之后主动转钱给别人。 当然，你的账户被盗，支付宝会赔钱给你。但如果你被骗，用支付宝主动转钱给骗子，就没办法找支付宝赔钱了。毕竟，被骗不能赖钱包。 但是雄文告诉我，作为一个有追求的钱包，这两年支付宝恰恰在“识别诈骗”方面苦练技巧。 这种对诈骗的识别能力，同样在 AlphaRisk 身上。 骗子骗人，一般都是直接打电话，或者在微信上骗，那些过程支付宝肯定不知道。它只能看到一个账户给另一个账户转了钱。。。通过这么少的信息，它怎么能判断你是不是被骗了呢？？ 雄文给我讲了一个真实的例子。 一个妈妈，她的孩子在外地打工，做快递小哥。突然有一天，她接到了一个陌生电话，告诉她儿子出了车祸，急需抢救，需要她打钱过来。妈妈开始没相信，把电话挂了。但是身边的电视正好播出了一条新闻，说他儿子所在的城市，有一个送货小哥出了严重车祸。这下她着急了，赶快给对方回电话，要把钱转过去。 就在这位妈妈把钱转给骗子的时候，AlphaRisk判断了风险，并且弹出了提示，告诉她有这笔转账可能是被骗了。妈妈选择无视，关掉弹窗继续转账。这次，AlphaRisk判断强风险，直接阻断了交易，锁定账户两小时。 这位妈妈非常生气，觉得自己的儿子出了事，支付宝却不让转账，于是拨打客服理论。正在这时，他的儿子碰巧打电话给妈妈，这才揭穿了骗子的骗局。 在这个例子中，AlphaRisk 是凭什么判断转账存在诈骗风险呢？ 雄文说，至少有三点： 1、妈妈平常的支出，都是小额的日常生活，买菜超市，突然一下转几万块显得很异常。 2、对方的收款账户是新注册的。而且近几日只有大额收款和提现，并没有日常消费。 3、这两个账户之间从未有过直接转账。 你看，基础逻辑和判断账户被盗差不多，只不过，判断被骗可以利用的信息比判断被盗少得多，所以难得多。 但最让雄文头疼的是，截断用户付款固然好，但是万一截错了，用户是要跟支付宝拼命地。。。支付宝但凡截断用户的交易，必须证据确凿。如果没有百分百的证据，一般会选择弹窗提示。然鹅，很多时候即使支付宝弹出了警视窗，用户都会选择直接关掉，没啥作用。 即使是这样，雄文团队也对弹窗内容改了又改，可谓是苦口婆心啊。 这是修改前的 ↓↓↓ 这是修改后的↓↓↓ 前两天，雄文和团队突然找到了一个好方法，他们和地方反诈骗中心“合作弹窗”。例如你是重庆人，在支付宝判断你的一笔交易有风险时，弹出的内容不是“支付宝提醒您注意诈骗”，而是“重庆反诈骗中心提醒您，这个交易有可能是诈骗。” “这样一下，用户终止交易的比率大大增加！”改了几个字，就能让好多人少上当。雄文老激动了，这两天从地方到中央找反诈中心公安局各种合作。 “到目前为止，用户遭受诈骗，有85-90% 都能收到弹窗提示。”雄文大叔开心地说。 现在是这样↓↓↓ 说到这，雄文大叔给我普及了一个金融小常识： 一般的在线交易系统，对于转账这个操作，只涉及“转出”和“到账”两个状态。这边转出之后，那边就到账。就像一盏灯只存在“开”和“关”两个状态。不可能存在“这边钱扣掉，那边还不到账”的情况。 但是支付宝为了防止诈骗，开发了第三个状态：类似“预授权“。如果你觉得这次转账有风险，可以设置2小时或者24小时延时到账。这种情况下资金就在“预授权”状态。在这个期间如果你发现被诈骗，可以报警并向支付宝申请冻结资金。 “预授权“状态的钱，按理说到时之后就会顺利进入转入账户。但只要有公安机关的相关凭证，就可以退回到转出账户。 别看只是加了一个“预授权”的状态，这相当于给了受害者一个“时光机”，回到过去，改变那个无可挽回的错误。 雄文说，为了增加这个新状态，他们两年里对支付宝底的层代码做了很大的修改。虽然大动干戈，但这件事非常值得。 （四）玩漂移的老司机 讲真，人类对一台机器的要求是很变态的。好的机器不仅要代替人，还要比人更精神。 毕竟是亲生的， 说到 AlphaRisk，雄文特别开心。他觉得如果2017年支付宝没有开始研究AlphaRisk，现在很多风控策略还靠人肉的话，一定会被“时代的洪流”所击垮。 如今，AlphaRisk 有两个杀手锏： 1、和人比，它厉害到不知哪里去了。 你可能已经知道，AlphaRisk 就是一种“人工智能。你作为一个人每天家长里短悲欢离合其实本质都是判断，人工智能每天也是做一件事：判断。 人工智能判断事情的标准，和人又像又不像。这里涉及到一个大家普遍理解得不好的技术梗，中哥正好以 AlphaRisk 为例简单科普几句： 人工智能和人各自做一个判断，有点像两个大厨分别做一桌菜给你吃。这分为三步： 1、他们使用的原料种类都是一样的青椒、萝卜、鸡肉等等。（这意味着人工智能和人用于判断一件事情的基础数据是一样的。） 2、但是，他们炒菜的路数可就不一样了。人类可能会做出鱼香肉丝、宫保鸡丁、水果拼盘，但是机器会根据自己的理解做出西瓜披萨，苹果蒸蛋、巧克力烧茄子等等常人不能想象的饭菜。（这意味着人工智能的判断模型和人既相似又不同。） 3、最后，两桌菜分别上来，食客们会发现，两种菜虽然不一样，但是都能填饱肚子，而且机器做的明显更好吃更营养。（这意味着人工智能判断的准确度比人类还高。） 简单总结人工智能的工作原理：通过人类看都看不过来的数据，用风骚的机器思维，做出一击致命的判断。 这里给你几个数据你感受一下。 AlphaRisk用来判断的风险点有几千个（如交易金额、支付宝注册地、交易时间、使用密码支付还是指纹支付等）。把这么多数据进行惨无人道的交叉运算，总运算量是巨大的。 在平时，每秒钟全世界都会用支付宝进行上万次的交易。如果在双十一这种狂欢节，每秒支付宝要处理25万笔交易。你想想看，就像商场的收银台后面，排队排了25万个顾客，每一笔交易，AlphaRisk都还要计算无数次来判断它是不是有风险，这得累计多大的计算量。。。 如果这些计算量交给人来做，等到算完，估计已经到了9102年双11了吧。 这么疯狂的机器，日常得有不少码农为它检修上油吧。。。 雄文说哈哈哈NO！因为，这两年他们已经搞出了一套“自动驾驶”系统。 纳尼？支付宝也会开车了么？求车牌号！其实，不是你想的那样，这就到了 AlphaRisk 的第二个逆天优势。 2、这是个会自动驾驶的老司机。 那些做坏事的黑客，连过年都不休息，天天“苦炼内功”，不断升级自己盗取支付宝账户和诈骗用户的技术。这是为什么？因为他们知道，如果能早几天研究出一个盗取支付宝的方法，那赚的钱可比在支付宝上班的码农加班费多多了。 对手那么疯狂，AlphaRisk 也要加油才行啊。正常情况下，AlphaRisk 想要学会新的反诈骗套路，要工程师手动输入代码。 但是，雄文和支付宝安全团队的队员很“懒”，他们觉得，AlphaRisk 已经长大了，不能每天晚上给它“检查作业”，它要自己学习新的知识了。 所以过去两年，攻城狮们很少砍柴，主要磨刀。他们建立了一个自动建模的系统。每天都会有一些用户损失通过投诉渠道反馈到支付宝风控团队，这个自动建模系统就可以通过学习这些AlphaRisk没有拦截成功的案例来建立新的风险模型，然后把这个模型输入到 AlphaRisk 里，下次再遇到同样的问题，AlphaRisk 就能一眼识别。 自动建模还不是全部。 你知道，每年双11的时候，支付宝会像雷峰塔一样，承受一下交易量水漫金山的感觉。这个时候，如果还执行原来的风控策略，就会导致计算力严重不足的情况。本来人家零点秒杀，结果支付宝算了十秒钟，跟人家说没问题去付钱吧。结果秒杀的限量款衣服早都被人家抢得毛都不剩。这会造成大批群众到杭州上访的。。。 所以，支付宝需要根据不同的情景，调整 AlphaRisk 的风控策略。这就像一辆车，根据路况不同，切换12345档。 原来每到双11，攻城狮们就会写一套新的风控策略，为 AlphaRisk 手动换挡。从2017年开始，完全不用了。AlphaRisk学会了骚气的自动换挡。交易量巨大的时候，就自动切换为高档，交易量低的时候，就瞬间调回来。 这不就和汽车的自动驾驶是一回事么。。。 我第一次发现，原来自动驾驶不仅仅是汽车领域的人工智能。凡是需要复杂人工智能的场景，其实都有自动驾驶的一席之地。甭管是人是机，反正这个世界缺不了老司机。 （五）三个“隐秘战场” 其实，中哥知道，科普半天支付宝 AlphaRisk 的风险识别技术，你也未必听得进去，因为我已经提前剧透了，反正你丢了钱支付宝会赔给你。 不过，要是你以为雄文和支付宝风控团队只玩技术，那就太小看他们了。 有道是：“科学的尽头是哲学。” 这句话不无道理。好多事是科学解决不了的。比如你女票天天吵着要买钻石戒指，你告诉她从科学角度说那玩意儿其实就是碳，那你当晚必定自己睡。 虽说支付宝的风控做得很科学，但是雄文却每天都面临三个哲学问题： 第一，打扰率和资损率如何平衡？ 之前我们已经介绍过这个重要概念“打扰率”，就是支付宝为了保障你账户的安全，弹出来一些验证提示等等打扰你的行为的概率。 当然技术水平是在不断进步的。但假设在技术保持不变的情况下，这是个跷跷板。打扰率越高，资损率就越低。 如果让中哥这样的抠门来做决定，那估计是要把资损率降到极限，对用户的打扰率有多高。。。爱咋咋地。。。因为这样能保证赔出去的钱最少。 当然，支付宝没有这样做。他们在资损率降低到千万分之五之后，转而把技术重心放在了降低打扰率和诈骗识别上。 资损率低到千万分之五的时候，我们就认为被盗是小概率事件了。即使被盗，也能做到全额赔付。这个时候，我们要用技术的进步让用户体验到温度。 雄文说。 正所谓：“有技术的 App 千篇一律，有温度的 App 万里挑一”。表面上看，这是一个产品哲学和技术取舍。但在这个天平上，你其实可以测量用户的重量。 第二，赔付与不赔付如何平衡？ 你可能会说，不是刚刚都说了么，被盗就赔，自己转给骗子不赔。 没错，但是在现实生活中，总有那些让人哭笑不得的中间地带。 我随便给你举两个例子。 第一个例子：卖早点的老张，把自己的收款码放在早餐车柜台上，结果有一天，一个混球突然把老张的收款码偷偷换成自己的。老张忙着做早点，结果半个小时才发现。他联系支付宝客服，你是支付宝的话，你赔还是不赔？ 直接说答案，赔。原因很简单，做生意不容易，虽然二维码被偷梁换柱不是支付宝的责任，但是支付宝不想让诚实的人受损失。 别看雄文说得轻描淡写，当初决定二维码偷换也要赔的时候，所有人可是下了老大的决心的。因为，付款码偷换的整个流程，都不是支付宝能监督控制的，所以他们不知道如果赔的话，要赔出去多少钱。 雄文记得，那时候他跟支付宝老大井贤栋商量这件事，井贤栋立刻就同意了，他说：“我们准备个几亿，先赔着。”支付宝还专门给小摊主设计了一个语音播报的功能，收到款手机就会大声喊出来。 当然，事后证明广大摊主并没有那么粗心，自己的二维码被偷换了还不知道。数据显示，真正因此受损失的小商家很少。 第二个例子：小美联系支付宝客服要求赔偿，说一觉醒来支付宝里几万块的余额不翼而飞。但是支付宝通过数据查看， 这笔钱是用她的手机，在她家的 Wi-Fi环境里，密码根本没有被重置，都是一次输入正确而被转走的。AlphaRisk 认为这很可能不是被盗，说白了，有可能是“监守自盗”，如果你是支付宝，你赔不赔？ 直接说答案，不一定赔。原因也很简单，因为大家都要诚实。如果涉及到欺诈，支付宝并不能蒙受不白之冤。 这是个真实的案例。后来的警察调查发现，这是她交往十年的男朋友，因为沾上了赌博不敢说，趁她睡觉的时候偷偷把钱转走的。 雄文告诉我，支付宝风控部门有一个专门的团队，就是处理这种介于赔偿和不赔偿之间的中间地带。如果确实有警方介入，没有发现是监守自盗或亲友作案，那么支付宝就会赔付。 第三，安全和安全感之间如何平衡？ 你有没有过这样的经历：给别人转好大一笔钱，结果支付宝问都没问，直接放行了你的转账。这时你的心里会闪过一丝不安全感，就像穿着短裙的女装大佬，总感觉空空荡荡的。 其实，AlphaRisk 在背后已经帮你掐指一算，判断了你的转账没有风险，只不过没有明确告诉你。 雄文说，这是他们团队最近在努力思考的问题：“安全”没问题，但是用户的“安全感”有问题，这要怎么平衡？ 其实有关“安全”和“安全感”的问题，历史上有个经典公案。汽车门关上的时候，本来是没有声音的，但是广大司机们听不到声音，总觉得车门没关好，百爪挠心。于是，索性各大车厂专门设计了一个机关，让车门关闭的时候发出坚实的“砰——”。然后，天下太平。。。 “所以，你们也要在某些不需要打扰用户的时候，弹出验证消息吗？”我问。 “谁说得准呢？”雄文笑了。 没想到，每天我打开支付宝只是付个钱买个余额宝，其实它背后正在发生着无数秘密战争——支付宝风控团队带着 AlphaRisk时刻在改进风控技术，并且在这样那样的平衡之间精确腾挪。 告别雄文。走在杭州冬天温润的空气里，我突然觉得心情很舒畅。 一次偶然的电视节目，却让我认识了这么一位温暖的大叔，还有背后守护我们的工程师们。 我记得曾经在网上看到过这样一个帖子：“黑客这么厉害，为什么不去攻击支付宝？” 现在我觉得自己大概能回答这个问题了：他们攻击了，只是你不知道，因为有人在替你负重前行。 很多备受推崇的产品经理在介绍经验时，总是强调“人心”二字。当时，我未免觉得这是一种政治正确的姿态。但当我和无数大佬聊过之后，越来越发现一个真理： ** ** 技术可以打下世界， 但只有良知可以赢得人心。 世界辽阔，而且，没有想象中那么糟。 O，对了，想看这期节目的，可以上优酷搜索“智造将来”，2019年2月3日那期。","link":"/blog/2019/05/18/其他/黑客为什么不攻击支付宝？/"},{"title":"小程序整理","text":"https://github.com/hcq0618/MiniProgram-list 旅行地图手册，包含中国地图及世界地图，旅游出行必备 最新最全最准周公解梦，支持模糊搜索、梦境分类、快速查询","link":"/blog/2019/05/17/小程序/小程序整理/"},{"title":"MySQL 常用30种SQL查询语句优化方法","text":"1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 5、下面的查询也将导致全表扫描：(不能前置百分号) select id from t where name like ‘%c%’ 下面走索引 select id from t where name like ‘c%’ 若要提高效率，可以考虑全文检索。 6、in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 7、如果在 where子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’ –name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 12、不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) 13、很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或update时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数较好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 16.应尽可能的避免更新 clustered 索引数据列，因为 clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18、尽可能的使用 varchar/nvarchar 代替 char/nchar，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21、避免频繁创建和删除临时表，以减少系统表资源的消耗。 22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，较好使 用导出表。 23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table，这样可以避免系统表的较长时间锁定。 25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF。无需在执行存储过程和触发器的每个语句后向客户端发送 DONEINPROC 消息。 29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30、尽量避免大事务操作，提高系统并发能力。","link":"/blog/2019/05/18/后端/MySQL 常用30种SQL查询语句优化方法/"},{"title":"DB主从一致性架构优化4种方法","text":"需求缘起 大部分互联网的业务都是“读多写少”的场景，数据库层面，读性能往往成为瓶颈。如下图：业界通常采用“一主多从，读写分离，冗余多个读库”的数据库架构来提升数据库的读性能。 这种架构的一个潜在缺点是，业务方有可能读取到并不是最新的旧数据： （1）系统先对DB-master进行了一个写操作，写主库 （2）很短的时间内并发进行了一个读操作，读从库，此时主从同步没有完成，故读取到了一个旧数据 （3）主从同步完成 有没有办法解决或者缓解这类“由于主从延时导致读取到旧数据”的问题呢，这是本文要集中讨论的问题。 方案一（半同步复制） 不一致是因为写完成后，主从同步有一个时间差，假设是500ms，这个时间差有读请求落到从库上产生的。有没有办法做到，等主从同步完成之后，主库上的写请求再返回呢？答案是肯定的，就是大家常说的“半同步复制”semi-sync： （1）系统先对DB-master进行了一个写操作，写主库 （2）等主从同步完成，写主库的请求才返回 （3）读从库，读到最新的数据（如果读请求先完成，写请求后完成，读取到的是“当时”最新的数据） 方案优点：利用数据库原生功能，比较简单 方案缺点：主库的写请求时延会增长，吞吐量会降低 方案二（强制读主库） 如果不使用“增加从库”的方式来增加提升系统的读性能，完全可以读写都落到主库，这样就不会出现不一致了： 方案优点：“一致性”上不需要进行系统改造 方案缺点：只能通过cache来提升系统的读性能，这里要进行系统改造 方案三（数据库中间件） 如果有了数据库中间件，所有的数据库请求都走中间件，这个主从不一致的问题可以这么解决： （1）所有的读写都走数据库中间件，通常情况下，写请求路由到主库，读请求路由到从库 （2）记录所有路由到写库的key，在经验主从同步时间窗口内（假设是500ms），如果有读请求访问中间件，此时有可能从库还是旧数据，就把这个key上的读请求路由到主库 （3）经验主从同步时间过完后，对应key的读请求继续路由到从库 方案优点：能保证绝对一致 方案缺点：数据库中间件的成本比较高 方案四（缓存记录写key法） 既然数据库中间件的成本比较高，有没有更低成本的方案来记录某一个库的某一个key上发生了写请求呢？很容易想到使用缓存，当写请求发生的时候： （1）将某个库上的某个key要发生写操作，记录在cache里，并设置“经验主从同步时间”的cache超时时间，例如500ms （2）修改数据库 而读请求发生的时候： （1）先到cache里查看，对应库的对应key有没有相关数据 （2）如果cache hit，有相关数据，说明这个key上刚发生过写操作，此时需要将请求路由到主库读最新的数据 （3）如果cache miss，说明这个key上近期没有发生过写操作，此时将请求路由到从库，继续读写分离 方案优点：相对数据库中间件，成本较低 方案缺点：为了保证“一致性”，引入了一个cache组件，并且读写数据库时都多了一步cache操作 总结 为了解决主从数据库读取旧数据的问题，常用的方案有四种： （1）半同步复制 （2）强制读主 （3）数据库中间件 （4）缓存记录写key 前3个方案在今年数据库大会（DTCC2016）上share过，相关的材料在网上能下载到。第4个方案是大会现场有其他同学share的一个好方法，感谢这位同学。","link":"/blog/2019/05/18/后端/DB主从一致性架构优化4种方法/"},{"title":"互联网架构的演变","text":"互联网架构的演变 1 最初是前端一个web 加一个DB的结构 这种结构，web容易挂掉，业务就会终止，由于高可用的需求，出现了下面这样的架构。 2 加了一个web，两个web之间是主备的关系，一个挂了，另一个来代替，用来解决高可用问题 3 之后发现这样的架构支持的访问量不够了，前端撑不住那么大的访问量，因为前端的访问量和DB的落库有大概是10比1的比例，前端访问10个，会有1个能够落库，所以随着访问量的增加，前端先扛不住了，这个时候主、备结构已经不能解决高可用的问题，所以在web前面加了一个ngx，作为负载均衡进行访问的转发，这个时候，web和web之间的主备关系就不存在了，在ngx进行转发的时候会有一个session保持的操作，再后来就出现无状态的概念，在两个web之间进行轮询，给谁都行 4 当无状态的概念出来以后，web这一层就可以进行多次的横向扩展，这是第一次质的飞越 后来人们觉得一个ngx也会出问题，就设计了主、备结构的ngx 5 后来主、备ngx结构也不满足需求了，就在ngx前面加了一个lvs，lvs是一个负载均衡的结构，lvs先对ngx做分发 这时nginx就解放出来了，不是主、备结构了，而是作为一个层级的结构，可以进行无限横向扩展，lvs被设计成主、备的结构，至此，lvs作为第一层就不再变化了，第一层始终是主、备的结构，lvs的负载特别小，所有的负载到lvs直接就传给ngx，ngx再往下分发 这个时候，转发层活了，web层活了，压力就全到DB了，DB就开始演变 6 最初DB演变出来master和slave这样的架构 所有的web既连master也连slave，连slave只进行读操作，连master只进行写操作，这样把读和写进行分离，这时速度就有一个质的提升 然后如果一个slave不够的时候，再加一个slave，就解决了这个架构对数据库读的压力，这个时候的网站的并发访问量，理论上可以到万级了 但是有一个问题，master是一个单点，如果它挂了，整个系统就都挂了，这个时候要考虑的不只是吞吐量，也要看性能、可靠性，前端已经没有问题了，但是数据库这里有一个单点的问题，后来人们就开始想办法，怎么能保证DB不会出问题呢，后来人们就把DB这块给重构了。 7 在web下面加了一层proxy结构，可以说是转发，也可以说是中间件，这一层结构可以做成集群，这个集群是给数据库做切片的，做成类似于分布式的功能，这一层下来给DB做切片转发，这样DB这一层的库之间就不再有主、从的关系了，都认为是主，挂掉一个，其他的还能正常工作，既做高可用，又做高性能，保证某一台挂掉的时候，另外两台可以做到高可用，如果负载不够的时候，还可以添加 这个4层结构，可以在很高的性能下，很高的可靠性下做到万级甚至十万级的并发。 这是5年前开始流行的架构，现在的使用率也很高，在对可靠性和性能方面要求不是很高的系统中可以很稳定的应用，但它存在一个问题，就是访问量再大的时候，落库的时候会有一个瓶颈，因为DB不只是做插入和查询，还要做分析和关联，速度会很慢，那怎么办呢？ 8 人们开始在DB层的上边加两个缓存层（读和写），读缓存层是用redis，它也是集群，在业务层下边，DB层的上边，redis从数据库里抽数据，到自己的缓存中，然后提供给业务，只要被缓存命中的数据，读的是特别快的，redis把DB中的热数据提取到缓存层，直接给业务层来用。 写的话用的是MQ，来实现写的业务，一读一写合起来就大大的提升了并发的处理。 这个架构中的lvs负责四层转发，ngx做7层转发，转发下来后，web做接收。 读的时候，热数据从DB里抽到redis里读，就不会因为DB的计算卡着web了，在像双十一这种秒杀的业务，可以把数据提前放到redis里，供web来读，写数据时可以快速的写给mq，之后web就不用管了，用户就可以接着做下一步了，然后mq往DB里一点一点的落库，就是说通过缓存层把高速的web和低速的DB给隔离开，这样给前边的用户体验就会特别好。 比如双十一之前加购物车，都是提前被写好了放到redis里边，然后下订单都是通过mq来落库，你这边一点刷一下就过去了，你觉得过去了，实际上都在mq里往DB里处理，不可能一下子就落到DB里，目前还没有一家公司能够做到，就算是分布式数据库也不行，分布式数据库只能解决中型的业务场景，解决不了巨型的业务场景，这是这两年很典型的比较火的架构，但是它比不上分布式数据库，这种结构即使很快，如果技术实力不够也只能达到十万级，如果要扩的话，只能是横向的扩，一套一套的往上累加。 9 出现了新型分布式数据库以后，这个架构变得很简单，很明晰，速度也很快。 lvs，nginx，web这三层不变，下边的缓存层，代理层都没有了，只剩数据库本身了，这个DB目前可以撑住10万甚至20万（瞬间的并发写），没有理论上限，各种的复杂的计算在一秒内都可以完成，这就是分布式架构的架构之美，越来越简洁。这个DB实际上是很复杂的。 它的底层有自己的分布式存储dfs结构，另外有控制节点，还有提供实际计算，运行sql的计算节点，这三部分是没有中心（去中心），可扩展，对称的（坏掉一台、加一台都没问题），可以做到平行的扩展，做到无限制的可行性，也是分布式的目的所在。 他是怎么做到高速的呢？实际上就是分布式存储和计算的理念，如果有中心的话，需求下来一定是发给一个中心节点上，这个中心就会成为瓶颈，无中心的话，需求下来抛给控制节点，控制节点也没有中心，控制节点接到请求以后告诉它你去哪个计算节点上去，然后计算节点去计算的时候，如果这时所有的数据放到一个dfs上边（存储DB），读写势必会很慢，但是分布式存储它是完全散开的（多个dfs），一个请求过来后是放到所有的计算节点上去算的，然后拿的时候是到所有的dfs上去拿的，这个速度会特别快，这个过程完全都是分布的，所以，这种新型的数据库架构，就可以做到每秒10万个查询、写入、update，也可以做分析，最快可以到每秒10万。 目前能做到千万级别的并发的，有BAT和12306，其他就没有了，这种架构覆盖了当前互联网基本上 95%甚至是99%的需求。 数据在下发的时候，是多副本，挂掉一个机器数据是不会丢失的，它的数据是打散的，这样读的才会快，这个结构出来之后直接干掉缓存层，而且可以支持列式数据库，目前的数据库基本是行式的，列式数据库对那种特别大的数据量支持的特别好。（The End）","link":"/blog/2019/05/18/后端/互联网架构的演变/"},{"title":"如何在开发过程中搭建简单的假数据服务器","text":"在开发一块新功能的过程中，我们通常会涉及到与后端接口联调的问题。新的界面、新的后端接口，这时候在开发的时候往往前端就很尴尬，后端不依赖前端，但是前端十分依赖后端。 大部分应用都会有或多或少地依赖后端数据，有的界面只需要简单搞个假数据传入即可，但是我们还需要应对很多复杂情况，比如： 处理无数据、返回错误、各类非正常的状态； 处理分页数据的情况； 模拟一个请求中、请求失败、请求结果返回的情景； 这时候如果能够写一个简单的服务器，你请求真实的接口url，只需要给手机设置一个代理，就返回你设置的假数据。这样你就可以完全抛开其他依赖的顾虑，可以像正常情况一样开发、校验结果，而不是依赖写死在代码里的各种假逻辑（这样做也会为后面的开发带来一些隐患）。 实际上服务器本身的逻辑是非常简单的，但是要真正得搭建成你所需要的环境，需要一些复杂功夫。本文以[nodejs](http://blog.desmondyao.com/fake-server/node)为例，具体描述一下如何在本机上搭建测试服务器。 使用node搭建起简单的服务器脚本1. 安装Unix 用户可以使用命令行安装nodejs。 Windows 用户可以直接下载安装包。 安装成功后如果在命令行下输入node -v能够打印出版本信息，说明安装成功了。 2. 简单服务器Node 服务器可以运行在“IP:PORT”上，我们可以通过如下代码来在127.0.0.1:2333端口上搭建起一个简单的服务器： server.js 1234567891011121314151617181920212223242526272829const http = require(&apos;http&apos;);http.createServer( (req, res) =&gt; {// 返回码200，返回头中标识内容为jsonres.writeHead(200, {&apos;Content-Type&apos;: &apos;text/json&apos;});let resp = {code : 0,time : 1469981217,data : {name : &apos;desmond&apos;,gender : &apos;male&apos;}};res.end(JSON.stringify(resp)); // 将resp转换为JSON字符串返回。}).listen(2333, &apos;127.0.0.1&apos;, ) 之后输入node server.js，然后我们到浏览器中访问localhost:2333就可以看见： 具体的信息可以参考Nodejs-http. 3. IDE配置从IDE环境切换到脚本环境来写代码总会不顺手，推荐一个我认为比较容易上手的配置吧： Nginx反向代理nginx搭建服务器的强大处之一就是它的代理能力，配置也十分简洁。 如果要模拟最终的请求的话，我们应该是原封不动的保留请求url: ‘www.desmond.com/api/something’。首先我们需要在手机上设置代理，将ip配置到自己电脑上，端口配为80。但是你的电脑识别到这个请求后，怎么让它导流到你的node服务器，这是一个问题。如果你代码写死的ip+端口来访问，未免有点太low了，我们既然折腾了这么多，那可以继续往下走一步：反向代理。 反向代理，简而言之，就是一个分发请求的代理。前向代理是直接发给目标服务器，但是它会做一些额外的处理工作。反向代理不一样，它自己相当于是一个服务器，请求到它手里，它根据请求去不同服务器上拉取数据。 1. 安装NginxLinux用户可以使用命令行: 123apt-get updateapt-get install nginx OSX用户可以用Homebrew: 1brew install nginx Windows用户可以下载安装包 2. 配置代理我们希望针对’www.desmond.com/api/something’下的url交由node服务器(2333端口)处理，其他情况下继续发送，可以在nginx.conf里面这么配置（可以在命令行下输入nginx-t找到配置文件位置）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647server {listen 本机ip:80;server_name www.desmond.com;#charset koi8-r;access_log /Users/desmond/Nginx/api.access.log;error_log /Users/desmond/Nginx/api.error.log;location / { //默认情况原路继续resolver 8.8.8.8;proxy_pass http://$http_host$request_uri;proxy_set_header Host $http_host;proxy_connect_timeout 5;}location /api { //检测到api路径下的，转发到端口2333proxy_pass http://localhost:2333;}#error_page 404 /404.html;# redirect server error pages to the static page /50x.html#error_page 500 502 503 504 /50x.html;location = /50x.html {root html;}} 这里如果希望原路继续的那些url域名解析配合你的host（此处使用8.8.8.8来做DNS解析），你可以参考[StackOverflow的一个提问](http://stackoverflow.com/questions/8305015/when-using-proxy-pass-can-etc-hosts-be-used-to-resolve-domain-names-instead-of)。 这样一来，你所有手机上访问的www.desmond.com/api/something就导到你的nodejs服务器上啦，尽情配置假数据来测试吧~~ 4. 配合Charles使用如果使用Charles的话，手机上一般配的代理是”ip:8888”，那么此时需要做一件事：本地的host设置本机ipwww.desmond.com，这样才能保证 www.desmond.com域名下的请求被导流到nginx服务器，从而导流到自己的nodejs服务器上。 最终搭建直接使用node，还是有一些繁琐的。既然我们的目的是“简单”，那么可以考虑一下使用express。它封装了很多API，然呢使用起来非常方便。其中一项就是路由(Route)。它意思简单来说就是： www.desmond.com/api/a 由 a的逻辑处理，www.desmond.com/api/b 由 b 的逻辑处理。 我相信一个新模块的服务器接口肯定不止一个，假如我们现在接口文档上写着： 1. 提交个人信息：www.desmond.com/api/personal 方法：POST 返回示例： 1234567{code : 0,time : 1469981217} 2. 获取未来n天天气信息：www.desmond.com/api/weather 方法：GET 参数：day 未来天数 返回示例： 12345678910111213141516171819202122{code : 0,time : 1469981217,data : {items : [date : &apos;2016-08-02&apos;,state : &apos;sunny&apos;],//...}} 那么你可以使用来做一个简单的ROUTE+请求处理： server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const express = require(&apos;express&apos;);const url = require(&apos;url&apos;);let app = express();app.post(&apos;/api/personal&apos;, function (req, res) { //针对/api/personal 的 post请求返回 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/json;charset=utf-8&apos;}); res.end(JSON.stringify({code : 0,time : 1469981217}));});app.get(&apos;/api/weather&apos;, function (req, res) { //针对/api/weather 的 get请求返回 res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/json;charset=utf-8&apos;});let count = url.parse(req.url, true).query.day; //解析传入的day参数if(count) { //若有，根据day参数生成itemlet tmpList = [];let tmpDate = newDate();for(let i = 0; i &lt; count; i++ ) {tmpDate.setDate(tmpDate.getDate() + 1);tmpList.push({date : `${tmpDate.getFullYear()}-${tmpDate.getMonth() +1}-${tmpDate.getDate()}`,state : `sunny - ${i}`});}res.end(JSON.stringify({code : 0,time : 1469981217,items : tmpList}));} else { //若无，则返回错误信息res.end(JSON.stringify({code : -1,msg: &apos;you must send param \\&quot;day\\&quot;&apos;,time : 1469981217}));}});app.listen(2333, function(req, res) { console.log(`You have run node host.`);}); 注意：不要忘记安装express，（npm install express –save)即可。 编辑结束后运行一下node server.js，你可以看到输出： You have run node host. 这时我们可以尝试请求一下 localhost:2333，可以看到返回： 大功告成~~ 如果希望node server一直在后台跑（使用nodeserver.js时shell会卡在当前运行中），可以使用ForeverJS。 更简单的办法如果不想折腾太多，可以直接写一个json静态文件去返回： data.json 1234567{&quot;code&quot; : 0,&quot;time&quot; : 1469981217} *注意：手写json的话，里面的 key 必须以字符串形式（双冒号包围）存在。 server.js 12345678910111213141516171819202122232425262728293031323334353637const fs = require(&apos;fs&apos;);const express = require(&apos;express&apos;);let app = express();app.get(&apos;/api/weather&apos;, function (req, res) { //针对/api/weather 的 get请求返回res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/json;charset=utf-8&apos;});fs.readFile(&apos;data.json&apos;, &apos;utf8&apos;, (err, data) =&gt; { //读取data.jsonif(err) { //错误时返回异常res.end(JSON.stringify({code : -1,msg : &apos;Read File error!&apos;}));return;}res.end(data);});});app.listen(2333, function(req, res) {console.log(`You have run node host.`);}); 这样就非常简单，不过缺点就是无法动态地处理。","link":"/blog/2019/05/18/后端/如何在开发过程中搭建简单的假数据服务器/"},{"title":"直播平台整体架构","text":"直播平台整体架构 视频直播链路 视频流转换成不同清晰度不同的端，不同的网络环境，需要不同码率，以保流畅 播放器的基本实现 SDK在播放器上做层管理 视频相关技术细节 消息发送流程 不同消息通道的优劣对比 心跳及房间结构 用户按需分桶 固定分桶与按需分桶对比 关键词及垃圾文本过滤 大促风险控制 平台化的挑战 想了解可以私信我！ 1 SpringBoot+ 高并发消息处理 EDM?项目 实战 2 SpringBoot ELK?分布式 数据分析 3 Netty?高 并发 UTS?项目实战 4 SpringCloud?微服务+NoSQL+ 负载均衡平台设计","link":"/blog/2019/05/18/后端/直播平台整体架构/"},{"title":"HTTP 传输编码增大了传输量，只为解决这一个问题 | 实用 HTTP","text":"Hi，大家好，我是承香墨影！ HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文，而报文又是由报文头（Header）和实体组成。大多数 HTTP协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。 本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 HTTP协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。 HTTP协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。 “这里写了建议零售价 2 元…” “哦，不接受建议！” 前两篇文章中，我们分别聊了 HTTP的缓存机制和 HTTP内容实体编码压缩机制，在说到实体编码压缩的时候，还提到了一个传输编码，让我们优化传输的方式。实体编码和传输编码二者是相辅相成的，一般我们会配合使用。 本文就来聊聊 HTTP 的传输编码机制。 二、HTTP 的传输编码2.1 什么是传输编码?传输编码在 HTTP 的报文头中，使用 Transfer-Encoding 首部进行标记，它就是指明当前使用的传输编码。 Transfer-Encoding会改变报文的格式和传输的方式，使用它不但不会减少内容传输的大小，甚至还有可能会使传输变大，看似是一个不环保的做法，但是其实是为了解决一些特殊问题。 简单来说，传输编码必须配合持久连接去使用，为了在一个持久连接中，将数据分块传输，并标记传输结束而设计的，后面会详细讲解。 在早年间的设计里，和内容编码使用 Accept-Encoding 来标记客户端接收的压缩编码类型一样，传输编码还需要配合 TE这个请求报文头来使用，用于指定支持的传输编码。但是在最新的 HTTP/1.1协议规范中，只定义了一种传输编码：分块编码（chunked），所以并不需要再依赖 TE 这个头部。 这些细节，后面都会讲到。既然传输编码和持久连接是息息相关的，那我们就先来了解一下什么是持久连接。 2.2 持久连接（Persistent Connection）持久连接通俗来讲，就是长连接，英文叫 Persistent Connection，其实按字面意思理解就好了。 在早期的 HTTP协议中，传输数据的顺序大致分为发起请求、建立连接、传输数据、关闭连接等步骤，而持久连接，就是去掉关闭连接这个步骤，让客户端和服务端可以继续通过此次连接传输内容。 这其实也是为了提高传输效率，我们知道 HTTP 协议是建立在 TCP 协议之上的，自然有 TCP一样的三次握手、慢启动等特性，这样每一次连接其实都是一次宝贵的资源。为了尽可能的提高 HTTP 的性能，使用持久连接就显得很重要了。为此在 HTTP协议中，就引入了相关的机制。 在早期的 HTTP/1.0 协议中并没有持久连接，持久连接的概念是在后期才引入的，当时是通过 Connection:Keep-Alive这个头部来标记实现，用于通知客户端或服务端相对的另一端，在发送完数据之后，不要断开 TCP 连接，之后还需要再次使用。 而在 HTTP/1.1 协议中，发现持久连接的重要性了，它规定所有的连接必须都是持久的，除非显式的在报文头里，通过 Connection:close这个首部，指定在传输结束之后会关闭此连接。 实际上在 HTTP/1.1 中Connect 这个头部已经没有 Keep-Alive 这个取值了，由于历史原因，很多客户端和服务端，依然保留了这个报文头。 长连接带来了另外一个问题，如何判定当前数据发送完成。 2.3 判断传输完成在早期不支持持久连接的时候，其实是可以依靠连接断开来判定当前传输已经结束，大部分浏览器也是这么干的，但这并不是规范的操作。应该使用 Content-Length 这个头部，来指定当前传输的实体内容长度。 下面举个例子，在保持持久连接的情况下，依赖 Content-Length 来确定数据发送完毕。 Content-Length 在这里起到了一个响应实体已经发送结束的判断依据。这样的情况下，我们就要求 Content-Length必须和内容实体的长度一致，如果不一致，就会出现各种问题。 如上图所示，如果 Content-Length 小于内容实体的长度，则会截断，反之则无法判定当前响应已经结束，会将请求持续挂起造成 Padding 状态。 理想情况下，我们在响应一个请求的时候，就需要知道它的内容实体的大小。但是在实际应用中，有些时候内容实体的长度并没有那么容易获得。例如内容实体来自网络文件、或者是动态生成的。这个时候如果依然想要提前获取到内容实体的长度，只能开一个足够大的Buffer，等内容全部缓存好了再计算。 但这并不是一个好的方案，全部缓存到 Buffer 里，第一会消耗更多的内存，第二也会更耗时，让客户端等待过久。 此时就需要一个新的机制，不依赖 Content-Length 的值，来判定当前内容实体是否传输完成，此时就需要 Transfer-Encoding这个头部来判定。 2.4 Transfer-Encoding:chunked前面也提到，Transfer-Encoding 在最新的 HTTP/1.1 协议里，就只有 chunked 这个参数，标识当前为分块编码传输。 分块编码传输既然只有一个可选的参数，我们就只需要指定它为 Transfer-Encoding:chunked，后续我们就可以将内容实体包装一个个块进行传输。 分块传输的规则： 每个分块包含一个 16 进制的数据长度值和真实数据。 数据长度值独占一行，和真实数据通过 CRLF(\\r\\n) 分割。 数据长度值，不计算真实数据末尾的 CRLF，只计算当前传输块的数据长度。 最后通过一个数据长度值为 0 的分块，来标记当前内容实体传输结束。 在这个例子中，首先在响应头部里标记了 Transfer-Encoding: chunked，后续先传递了第一个分块 “0123456780”，长度为b（11 的十六进制），之后分别传输了 “Hello CxmyDev” 和 “123”，最后以一个长度为 0 的分块标记当前响应结束。 2.5 chunked 的拖挂当我们使用 chunked 进行分块编码传输的时候，传输结束之后，还有机会在分块报文的末尾，再追加一段数据，此数据称为拖挂（Trailer）。 拖挂的数据，可以是服务端在末尾需要传递的数据，客户端其实是可以忽略并丢弃拖挂的内容的，这就需要双方协商好传输的内容了。 在拖挂中可以包含附带的首部字段，除了 Transfer-Encoding、Trailer 以及 Content-Length 首部之外，其他 HTTP首部都可以作为拖挂发送。 一般我们会使用拖挂来传递一些在响应报文开始的时候，无法确定的某些值，例如：Content-MD5首部就是一个常见的在拖挂中追加发送的首部。和长度一样，对于需要分块编码传输的内容实体，在开始响应的时候，我们也很难算出它的 MD5 值。 注意这里在头部增加了 Trailder，用以指定末尾还会传递一个 Content-MD5 的拖挂首部，如果有多个拖挂的数据，可以使用逗号进行分割。 三、内容编码和传输编码结合内容编码和传输编码一般都是配合使用的。我们会先使用内容编码，将内容实体进行压缩，然后再通过传输编码分块发送出去。客户端接收到分块的数据，再将数据进行重新整合，还原成最初的数据。 四、传输编码小结我们对传输编码应该有一定的了解了。这里简单总结一下： 传输编码使用 Transfer-Encoding 首部进行标记，在最新的 HTTP/1.1 协议里，它只有 chunked 这一个取值，表示分块编码。 传输编码主要是为了解决持久连接里将数据分块传输之后，判定内容实体传输结束。 分块的格式：数据长度（16进制）+ 分块数据。 如果还有额外的数据，可以在结束之后，使用 Trailer 进行拖挂传输额外的数据。 传输编码通常会配合内容编码一起使用。 此外，传输编码应该是所有 HTTP/1.1 的标准实现，应该都有支持，如果收到无法理解的经过传输编码的报文，应该直接返回 501 Unimplemented这个状态码来回复即可。 参考连接： HTTP 协议中的 Transfer-Encoding：https://imququ.com/post/transfer-encoding-header-in-http.html REC 7230, 3.3.1 Transfer-Encoding：https://tools.ietf.org/html/rfc7230#page-28 RFC 7230, section 4.4: Trailer：https://tools.ietf.org/html/rfc7230#section-4.4 RFC 7230, section 4.1.2: Chunked trailer part：https://tools.ietf.org/html/rfc7230#section-4.1.2","link":"/blog/2019/05/17/网络/HTTP 传输编码增大了传输量，只为解决这一个问题 | 实用 HTTP/"},{"title":"HTTP 内容编码，也就这 2 点需要知道 | 实用 HTTP","text":"Hi，大家好，我是承香墨影！ HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文，而报文又是由报文头（Header）和实体组成。大多数 Http协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。 本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 HTTP协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。 HTTP协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。 “这里写了建议零售价 2 元…” “哦，不接受建议！” 在上一篇文章中，聊到了 HTTP的缓存机制，其实缓存的主要起因就是为了减少网络请求次数，来达到快速响应的目的。而除了减少网络请求之外，其实我们还可以通过对实体内容，进行编码压缩的方式，减少传输的内容大小，从而加快响应的速度。 本文就就继续来聊聊 HTTP 的实体内容压缩编码机制。 二、HTTP 的内容编码2.1 为什么要对内容进行编码？编码的目的就是为了压缩报文实体内容的大小，而通过压缩服务器响应报文传输的内容实体，在一定程度上就可以加快响应的速度。 毕竟传输一个 10kb 的内容，会比传输一个 100kb 的内容快很多。这就是需要使用内容编码进行压缩的原因。 2.2 压缩编码说到压缩编码，就先简单聊聊压缩算法，对于压缩算法而言，分为两类： 无损压缩算法 有损压缩算法 从名称上就可以理解，无损压缩意味着它是可以被还原的，通常被应用在文本，而有损压缩会对原始数据进行修改，以加大压缩率的目的，对文件进行有损失的压缩，这是一种不可逆的操作，通常一些对质量要求不高的图片和视频上，虽然压缩以后可能会导致文件模糊，但是勉强还可以看。 而在 HTTP协议中，通常我们只会对文本内容，进行压缩编码。一个主要的原因在于，压缩本身是会消耗服务器资源的，而文件比多媒体文件轻便了很多。并且多媒体文件多数情况下，本身就已经是高度压缩的二进制格式，再次进行压缩的意义也不大。 2.3 设计一个“压缩协议”前面提到，HTTP 协议是一种松散的 “协商协议”，需要客户端和服务端双端配合，才可以生效。而压缩算法有很多种，到底应该选择哪一种，也是需要双方协商的。 如果我们尝试设计一下这个 HTTP 的 “压缩协议”，主要需要关注这两点。 1.通知服务端，客户端支持的压缩算法 一个 HTTP 事务，总是由客户端发起请求，而服务端将响应返回。那么客户端就要在发起请求的时候，率先告知服务端，当前客户端支持的压缩算法。 通常客户端会支持多种压缩算法，为了让服务端有选择的空间，应该允许传递多个支持的压缩算法。既然有多选的空间，那么就一定要有优先级的概念。 类似于我们在市场上交易，我接受人民币、美元、比特币的交易，但是因为我使用人民币更方便，所以我需要指明交易方，如果方便的话最好通过人民币交易。 2.服务端选择支持的压缩算法压缩内容 服务端接受到客户端的请求后，辨识出客户端支持的压缩算法，现在当前环境最优的一种压缩算法对响应内容体进行压缩，然后将压缩后的内容返回。 为了让客户端接收到响应后，能明确知道服务端使用的压缩算法，还需要在响应中明确指明，当前的响应实体的数据使用的压缩算法（当然也可以不压缩）。 2.4 HTTP 的“压缩协议”前面我们自己设计的两个条件，都是基于 HTTP 报文中的报文头来实现的。接下来我们看看 HTTP 协议中，是如何设计“压缩协议”的。 1.请求头中的 Accept-Encoding 客户端为了告知服务端当前支持的压缩编码，可以在请求头中，增加 Accept-Encoding这个头部字段，用来指定当前客户端支持的压缩编码，如果有多个可以使用逗号 , 进行分割。 为了满足优先级，其实是可以通过 , 分割的顺序来指定的。HTTP 协议中，还可以使用 Q 值来说明编码的优先级，Q 值的取值范围是 0.0 ~ 1.0。0.0 表示客户端不想接受此编码，而 1.0 则表示希望使用此编码，不过通常我们不需要明确的指定它，大家了解一下即可。 2.响应头中的 content-encoding 服务端为了在响应报文里体现当前对内容压缩使用的编码格式，会在响应头中使用 Content-Encoding 标记，它是一个明确值，所以只可能有一个。 编码的目的就是为了压缩，所以当服务端选择压缩内容实体的时候，同时还会修改 Content-Length 来明确表示当前实体被编码压缩后的长度。 发两张压缩前和压缩后的流程图，就清晰了。 压缩前： 压缩后： 三、HTTP 的编码类型3.2 HTTP 编码类型HTTP定义了一些标准的内容编码类型，并且可以扩展更多的编码类型。由互联网号码分配机构（IANA）对各种编码进行标准化，它给每个内容编码算法分配一个唯一的代号。 Content-Encoding 就是用这些标准化的代号来说明编码使用的算法。 比较常用的算法有： gzip：表明实体采用 GNU zip 编码。 compress：表明实体采用 Unix 的文件压缩程序。 deflate：表明使用是用 zlib 的格式压缩的。 br：表明实体使用 Brotli 算法的压缩格式。 identity：表明没有对实体进行编码，为默认值。 在这些算法中，除了 identity 之外，都是无损压缩，他们都是需要可还原成原始的文本内容的。gzip 通常是效率最高的，使用最广泛的。 但是 gzip 对媒体文件的压缩效果相对较差，本身 JPG/PNG 这类文件已经是一种高度压缩的二进制文件，开启 gzip 效果甚微还会浪费大量 CPU资源。 浏览器的默认实现中，这些压缩编码通常只会作用在文本内容上，就是 Content-Type 为 text/Xxx的请求上，而对于一些媒体文件，则不会使用这种方式对其进行压缩。 3.2 GZIP既然 gzip 是 HTTP 的内容编码中，比较常用的一种编码方式，这里抛砖引玉，简单介绍一些 gzip，其他编码方式，有兴趣的可以自行查阅相关资料。 gzip 编码是采用的 GNU Zip 编码，是一种无损的压缩算法，用于减少传输报文实体的大小，它是可逆的压缩算法，不会导致信息损失。 gzip 的压缩效率相对较高，并且使用也是最为广泛的，我们在工作中如果不特殊说明，说到的 HTTP 压缩，通常就是指的 gzip。 gzip的原理，简单来说，就是会去扫描整个文本的字符串，找到一样的字符串，就只保留一个并分配一个标识，然后将其他相同的字符串使用这个标识替换，使整个文件变小。在还原的时候，只需要将每个标识代表的字符串，替换还原，就可以还原成最初的内容实体。 这种压缩算法，非常适用于现在的互联网产品，HTML、CSS、JavaScript 以及 Json 中，都包含了大量重复的字符串，所以在这里使用 gzip是非常合适的。 gzip 具体能压缩多少，完全取决于压缩的实体内容，内容文本中，包含越多相同的字符串，压缩率就越高，相反则越低。在理想状态下，gzip 的压缩率能高达70%。 四、内容编码的完整过程到此我们就算了解清楚 HTTP 对内容编码的完整流程了。大致流程如下图。 再总结几个关键点： 请求头中，通过 Accept-Encoding 来指定客户端支持的内容编码格式。 服务端选择一个支持的内容编码去压缩原始响应内容实体。 修改响应头，增加 Content-Encoding 用于指定使用的编码方式，并且修改 Content-Length 来表明压缩后的内容大小。 内容压缩的算法有很多，但是 gzip 是最常用的。 内容压缩算法，都是基于无损压缩，最终都需要在客户端将内容还原。 五、小结一个报文通常会包含报文头部和报文实体，而本文介绍的 HTTP 压缩编码，主要是针对报文实体内容中，文本内容的压缩编码，并为涉及到报文头部的压缩。主要是因为在HTTP/1中，报文头部始终是以 ASCII 文本传输，没有经过任何压缩，而在 HTTP/2 中才对其实现了解决方案，所以 HTTP的编码压缩只是针对报文实体的，这句话并不全对，这个有机会以后再说。 除了内容编码之外，HTTP 还有传输编码，这个同样也是有机会再说。 在本文中，说明了 HTTP 对报文实体内容的压缩策略和方法，希望对你有帮助。","link":"/blog/2019/05/17/网络/HTTP 内容编码，也就这 2 点需要知道 | 实用 HTTP/"},{"title":"HTTP1.0、HTTP1.1和HTTP2.0的区别","text":"一、HTTP的历史早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Javascript，来丰富我们的页面展示，当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 二、HTTP的基本优化影响一个HTTP网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 三、HTTP1.0和HTTP1.1的一些区别HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。主要区别主要体现在： ** 缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 四、HTTPS与HTTP的一些区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 五、SPDY：HTTP1.x的优化2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 六、HTTP2.0性能惊人HTTP/2: the Future of theInternet是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。 七、HTTP2.0：SPDY的升级版HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下： HTTP2.0和SPDY的区别： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE 八、HTTP2.0和HTTP1.X相比的新特性 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。 header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。 九、HTTP2.0的升级改造 前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 十、附注HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？ HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接； HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞； HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行； 具体如图： 服务器推送到底是什么？ 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下： 普通的客户端请求过程： 服务端推送的过程： 为什么需要头部压缩？ 假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）,而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）,则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：[HTTP/2头部压缩技术介绍](https://link.jianshu.com/?t=https://imququ.com/post/header-compression-in-http2.html) HTTP2.0多路复用有多好？ HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。 HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。 十一、参考HTTP/2.0相比1.0有哪些重大改进？ 深入研究：HTTP2的真正性能到底如何 [HTTP/2 头部压缩技术介绍](https://link.jianshu.com/?t=https://imququ.com/post/header-compression-in-http2.html)","link":"/blog/2019/05/17/网络/HTTP1.0、HTTP1.1和HTTP2.0的区别/"},{"title":"再好好聊一聊 HTTP 中的 Cookie 细节 | 实用 HTTP","text":"一、序Hi，大家好，我是承香墨影！ HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文，而报文又是由报文头（Header）和实体组成。大多数 HTTP协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。 本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 HTTP协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。 HTTP协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。 “这里写了建议零售价 2 元…” “哦，不接受建议！” 文本是本系列的第四篇，前三篇传送门： HTTP 的缓存机制 HTTP 内容实体编码压缩机制 HTTP 传输编码压缩机制 本身 HTTP 就是一个无状态的协议，但是有时候我们又有需要增加状态的需求，这个时候延伸出来了 Cookie，利用 Cookie可以让传输的时候保持一些状态信息。 本文就来讲讲 Cookie 的所有细节。 二、Cookie的使用2.1 什么是 Cookie？先明确一点，Cookie 就是为了解决 HTTP 协议无状态的问题，接下来举个例子说明。 早年间医院对患者的病例还没有在线建档的时候，都需要患者在就医之前，办理一个病历的小册子，医生会在病历中写上此次就医的情况，什么时间、有什么表现的反映、诊断是什么病、开了一些什么药等等。如果下次又生病了，有病历的情况下，都会要求患者再把病历带上，这样医生就能通过病历了解到之前的情况。 在 Cookie 的实现上，也是这样的。 服务端（医生）在收到客户端（患者）请求的时候，将一些用户标识信息加入到 Cookie （病例）中，随着响应返回给客户端，客户端将 Cookie中的信息存储在本地，下次再请求此服务器的时候，再将 Cookie 中携带的数据原样传输给服务端，此时服务端就能通过 Cookie中的用户标识，识别出这是之前请求过的某个用户。 在这个例子中，服务端就是医生的角色、客户端是患者的角色、Cookie 就是病历。 Netscape 官方文档中的定义为：Cookie 是指在 HTTP 协议下，服务器或脚本可以维护客户端计算机上信息的一种方式 。通俗地说，Cookie是一种能够让网站 Web 服务器把少量数据储存到客户端的硬盘或内存里，或是从客户端的硬盘里读取数据的一种技术。 Cookie 文件则是指在浏览某个网站时，由Web 服务器的 CGI 脚本创建的存储在浏览器客户端计算机上的一个小文本文件。 2.2 一个完整的 Cookie 传输流程HTTP 协议中的规则，都是通过在请求头和响应头中写入输入来实现，Cookie 也是这样的。 服务端通过 Set-Cookie 这个响应头来向客户端中写入 Cookie 信息，而客户端读取 Set-Cookie这个响应头中的信息存储起来，在下次请求的时候取出来，再通过 Cookie 这个请求头，将 Cookie 的数据传输给服务端。 再看一个浏览器中，Cookie 使用的实例。 在响应头（Response Header）中，使用 Set-Cookie 传递不同的 Cookie 数据，多个数据可以分开成多个 Set-Cookie 头。 在请求头中（Request Header）中，使用 Cookie 这个请求头传递 Cookie 数据，不同的数据通过 ;分割。 三、Cookie 的细节到这里，我想你应该弄清楚了 cookie 的整个执行流程，接下来我们再来探究一些 cookie 的细节。 3.1 Cookie 的类型cookie 其实都是存储在客户端，通常我们说 cookie 对应的客户端，就是在说浏览器。 对于 cookie，我们可以简单的将 cookie 分为两类： 会话 cookie。 持久 cookie。 会话 cookie 是一种临时的 cookie，用于存储一些临时的信息，存储在内存中，会话 cookie 在用户退出浏览器的时候，会被清空删除。而持久cookie 的生存周期会更长久一些，被存储在磁盘上，浏览器重启后它们依然存在，但是他们会有一个过期的时间，只在此时间之后会被置为失效。 会话 cookie 和持久 cookie 之间唯一的区别就是它们的过期时间，只要是设置了过期时间的 cookie 就是持久 cookie，反之则是会话cookie。 仔细看前面的流程图中，有一个 domain 的字段是用于标识当前 Cookie 支持的域名的，而想要设置过期时间，可以使用 Expires 或者 Max-Age 参数进行设置，有点类似我们前面讲 HTTP 缓存的参数。 3.2 Cookie 的配置参数到现在我们已经介绍了两个 Cookie 配置的信息，Domain 和 Expires/Max-Age，分别用来配置域名和过期策略。 这些都很好理解，毕竟浏览器是开放的，它会访问很多不同的网址，如果每个请求都将所有的 Cookie 信息都传递过去，基本上是不现实的。而这些配置参数，就是对Cookie 增加一些附加的设置，进行一些简单的限制和过滤，在减少传输量的同时也保证了安全。 Domain 这个参数可以限制只在此域名下的请求，才传递该 Cookie，其他的不传递。 Cookie 其实还支持其他的一些参数配置，打开 Chrome 的调试模式，在 Application 中就可以看到当前页面的 Cookie 信息。 下面以一篇微信文章页面所存储的 Cookie 为例。 这个表中，就是当前存储的所有 Cookie 信息，而表头，则是 Chrome 支持的 Cookie 信息。 下面我们分别来介绍它们。 Name:Value ：Cookie 存储的数据就是一个 Key-Value 的键值对，所以这两个参数没什么争议，就是数据的 Key 和 Value。 Domain：Cookie 的域，限制请求头传输的域。 Path：域中与 Cookie 相关的路径前缀。 Expires/Max-Age：过期时间或者超时间隔。 http：此属性为 True，表示只会在 HTTP 请求头中携带此 Cookie 信息，而无法通过 document.cookie 来访问此 Cookie。 Secure：安全，是否只有在使用 SSL 连接时才发送这个 Cookie。 其实都很好理解，就不展开讲解了。 3.3 Set-Cookie2 和 Cookie2有些资料里会提到 Set-Cookie2 和 Cookie2 ，这些都是历史遗留问题，当初想对 Cookie再进行一些功能上的扩展，但并未得到广泛的实施，现在已经弃用了。 大家了解一下即可，有兴趣可以参考 RFC 6265。 RFC 6265: https://tools.ietf.org/html/rfc6265 3.4 浏览器对 Cookie 的限制大部分时候我们聊到 Cookie 都在说的是服务器和浏览器进行通信时候，而不同的浏览器对 Cookie 存储的限制是不一样的。例如：单个域名可存储的Cookie 数量、Cookie 大小等。 我简单找了一些资料，来说明不同浏览器对 Cookie 的支持情况。 这些数据我没有验证过，但是也能说明不同浏览器对 Cookie 的支持情况。在进行页面 Cookie 操作的时候，应该尽量保证 Cookie 的个数小于 20个，总大小小于 4KB，这是一个安全且保险的范围。 四、Cookie的查缺补漏4.1 Cookie 安全前面配置 Cookie 参数的时候，有两个参数：http 和 secure 属性，它们就在一定程度上保证了安全。 http 属性 设置了 http 属性，标识它是一个 “HttpOnly” 的，那么通过一些脚本程序（例如 JS的 document.cookie）将无法读取到这个Cookie 信息，它只会出现在请求的报文头内。 secure 属性 secure 属性强制该 Cookie 只有在 SSL 的环境下才会想服务器传输，相对也保证了传输的安全。 4.2 Cookie 不支持跨域Cookie 本身是不支持跨域的，一定程度也保证了 Cookie 的安全，如果非要跨域其实作为前端基本上能做的很少，大部分都需要服务端的二次配合。 例如：nginx 反向代理、Jsonp、nodejs 的 superagent、iframe 等方法。 有兴趣再单独了解就好了。 五、Cookie 小结HTTP 中的 Cookie 知识点，基本上都已经讲解清楚了，我们再次总结一下关键知识点。 Cookie 主要是为了解决 HTTP 协议无状态的问题。 服务端通过 Set-Cookie 响应头来向客户端设置 Cookie。 客户端通过 Cookie 请求头向服务端发送之前存储的 Cookie 数据。 Cookie 依据过期时间进行区分，将类型分为：临时 Cookie 和 持久 Cookie。 Cookie 可以通过配置不同的参数，进行限制，例如过期时间、支持的域名、是否安全（secure）等。 Cookie 不支持跨域，跨域还需要其他的方式绕开来实现。 Cookie 只能做到相对的安全，任何事情没有绝对的安全。 参考： Cookie 个数限制及大小：https://my.oschina.net/gaollg/blog/71299。 RFC 6265：https://tools.ietf.org/html/rfc6265 cookie 小结：http://www.cnblogs.com/xianyulaodi/p/6476991.html","link":"/blog/2019/05/17/网络/再好好聊一聊 HTTP 中的 Cookie 细节 | 实用 HTTP/"},{"title":"图解 HTTP 的缓存机制 | 实用 HTTP","text":"一、序Hi，大家好，我是承香墨影！ HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文头（Header），大多数 Http协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。 本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 Http协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。 HTTP协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。例如：服务端说，这个数据缓存有一天的时效性，但是客户端可以说，我不听我不听，我就要每次去重新请求。 “这里写了建议零售价 2 元…” “哦，不接受建议！” 说到缓存，本文就来说说 HTTP 缓存相关的内容。 二、HTTP缓存使用2.1 为什么需要缓存缓存说白了就是为了快，无论是从磁盘到内存还是从网络到本地，都是为了在下次实用此资源的时候，能够快速响应，避免多次的 I/O 操作。 通过网络获取资源，是一件耗时的操作，较大的资源还会需要客户端和服务端之间进行多次往返通信，这不但会增加客户端响应的时间，同时还会增加网络流量。 在 HTTP 协议中，天然就有对缓存的支持，浏览器和 App 使用的开源网络库中，都是利用 HTTP 缓存来实现对资源的缓存。 浏览器是天然支持 HTTP 缓存，开源库则需要进行一些例如存规则和缓存的资源存放路径之类的简单设定。 2.2 设计一个缓存策略那如果让我们来设计缓存的策略，首先有两个重要的指标需要考虑。 1.缓存失效 既然缓存主要是针对数据的复用，那我们就需要有一个条件来判定当前缓存的数据，是否依然有效。 总是不能一次缓存，终身使用吧，我们还需要在缓存失效之后，重新获取新的数据并进行缓存。这个前提就是，缓存都需要有一个失效的策略。 2.减少读取 虽然缓存会有失效策略，但是这只是客户端单方面认为失效，此时应该再去服务端重新获取一遍数据。 可有些情况下，其实资源可能依然有效，并没有发生变动。那就需要有一个策略，让服务端通知客户端，当前缓存依然有效，可以继续使用。这样在减少传输流量之外，也可以加快相应时间，提高效率。 这就是一个好的缓存策略必须要考虑的地方，实际上 HTTP 缓存，也是这样设计的。 2.3 HTTP 缓存HTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。 这里主要涉及两个 Header： Cache-Control：设定缓存策略，是否使用缓存，超时时间是多少。 ETag：当前返回数据的验证令牌，可能是 Hash 值也可能是其他指纹，主要用于在下次请求的时候携带上，让服务端依此判断当前数据是否有更改。 服务端在返回响应数据的时候，会在报文头中，增加用于描述当前响应的内容类型、数据长度、缓存策略（Cache-Control）、验证令牌（ETag）等信息。 例如上图就表示了一次请求响应的事务，大概客户端请求一个文件的时候，服务端返回了一个 200 的状态码，表示响应正常，响应的数据长度为 1024个字节，建议客户端将此资源缓存最多 120 秒，并且提供了一个指纹令牌（“cxmyDev123”），用来作为当前数据的唯一标识。 2.4 ETag 数据令牌Cache-Control 中设定的 max-age 很好理解，就是设定缓存超时的时间，HTTP 缓存是限定一个超时的秒数，来确定缓存失效的时间。 上古时期还会使用 expires 来决定超时的日期，但是已经被废弃了，如果和 Cache-Control 同时存在，以 Cache-Control为准。 在此时间间隔范围内，客户端不会再向服务端发送新的请求。当资源距离上一次缓存的时间间隔，大于 120 秒后，客户端才会再次向服务端发送请求。 假如没有数据令牌的情况下，大概步骤应该是这样的： 客户端会首先找到本地缓存，然后发现它已经失效，无法再次使用。 客户端再次向服务端发出新的请求，并获取完整的数据再次进行缓存。之后再刷新该缓存的超时时间。 但是这是一件效率非常低的事情，服务端并无法确定所持有的源资源什么时候会失效，所以提供的 max-age值，只是一个参考值，是需要取平衡的，太短会导致请求频繁，太长又会导致无法及时刷新客户端资源。而此时再次请求的时候，是存在一定的概率，客户端缓存的数据和服务端上持有的数据是一致的，我们就不需要再次对此数据资源进行二次缓存，直接使用客户端之前缓存的数据即可，同时还需要刷新缓存超时时间。 这正是数据验证令牌（ETag）想要解决的问题，服务端生成并返回的这个数据指纹令牌，通常就是返回数据的 Hash值或者其他数据指纹，客户端无需关心它的生成规则，只需要知道它是当前数据的一个唯一标识。 客户端需要在下次请求时将其通过 If-None-Match这个请求报文头，将此验证令牌发送至服务端，如果数据令牌指纹和服务端当前的数据一致，则标识资源未发生新的变化。就会返回一个 304的状态码，表示可以继续使用客户端本地缓存的数据，并刷新超时时间。注意当响应码为 304 的时候，它是不包含数据内容的。 通常此缓存操作对我们都是透明的，它是浏览器和开源网络库的基本实现，我们无需自己去判断 max-age 和 ETag的值，这一步我们只需要确定服务端对此有支持即可。 这里只是提到了 If-None-Match，它标识比较 ETag 是否不一致，除此之外，还有一些其他的相关报文头，例如 If-Match，有兴趣可以查阅相关资料。 2.5 Cache-Control前面举的例子中，我们只为 Cache-Control 设定了一个 max-age，但是其实还有一些更丰富的配置。 从缓存性能最优化的角度来看，最佳的缓存是无需与服务端通信的缓存，可以通过缓存来消灭网络延迟以及数据请求，从而来提高用户的体验。 Cache-Control 是在 HTTP/1.1 中被定义的，它可以用于取代之前的缓存策略，现在所有的浏览器都支持 Cache-Control，它已经成为一种通用的标准。 Cache-Control 还有一些更灵活的配置，用来对缓存做一些更细致的操作。 “no-cache” 和 “no-store” 这两个参数都表示每一次请求，都需要真实的发送一个网络请求。 它们之间的区别在于，“no-cache”并不是真的不缓存数据，它只是要求每次都确认资源是否过期，也就是它会利用数据令牌 ETag来一定程度的减小传输的流量。 而 “no-store” 完全是要求客户端，每次都重新请求数据并下载最新的数据，不做任何缓存处理。这种不缓存的策略，也包括中间连接的代理、网关等中间传输的通道，也一并不对数据进行缓存，每次都从源服务器上获取数据。 “public” 和 “private” “public” 是一种默认的策略，表示当前缓存是开放的，任何请求响应的中间环节，都可以对其进行缓存，如果我们不显式指定，则当前为 “public” 缓存。 与之相对的“private”，则表示当前响应是针对单个用户的，并非通用数据，因此不建议任何中间缓存对其进行缓存。例如：浏览器就是一个比较私人的缓存源，它会缓存“private” 的缓存，而 CDN 则不会。 三、最佳的缓存策略树前面提到，缓存的核心目的就是为了快，能让下次使用的时候快速复用。所以在理想情况下，我们应该将响应数据尽可能多的缓存，尽可能的缓存足够长的时间，并且为每个资源提供单独的数据验证令牌，以便在时间过期之后快速校验。 但是任何事情都是要取其平衡点的，不存在什么最佳缓存策略，并非所有响应资源都需要加缓存，这就需要根据业务场景来设定。 这里给出一个增加 HTTP 缓存的通用策略树，你在对响应增加缓存的时候，可以参考它来执行。 正常情况下，我们针对不同的响应属性，会对它设置不同的缓存策略，下面根据场景，举几个例子。 3.1 用户相关的数据和单个用户紧密相关的数据，通常我们是不建议使用缓存的，但是依然存在几个等级。 严格不使用缓存 Cache-Control:no-store 允许客户终端缓存，但是每次使用都需要确认 Cache-Control:no-cache ETag:”cxmyDev1234” 允许客户终端短时间缓存 Cache-Control:private max-age=600 ETag:”cxmyDev1234” 3.2 通用数据一些通用响应资源，更新的频率非常的低，我们可以根据需要调整 max-age 的大小即可。 Cache-Control:max-age=86400 ETag:”cxmyDev1234” 四、废弃和更新缓存的响应缓存的策略，一旦确定并下发到客户端，服务端就失去了对齐的控制权。也就是说，如果我们设定了 max-age，在此资源有效期超时之前，哪怕服务端的源资源已经被替换修改，我们也没有一个合适的时机去通知客户端更新新的响应数据。 那么有没有什么好的策略去标记资源废弃？同时又能友好的利用缓存策略。 在互联网上，所有服务上的资源，都有一个对应的 URL（统一资源定位符），它可以明确说明如何从一个精确且固定的位置获取资源。而 HTTP 缓存，也是依赖于URL 的，注意 URL 是大小写敏感的，同一个 URL 表示同一个请求响应，依此来判断缓存和后续缓存的复用。 所以我们是可以在 URL 上做文章的。 4.1 浏览器的废弃策略前面提到，浏览器是天然支持 HTTP 缓存的，对于浏览器来说，它所面对的就是一个个 HTML 页面，页面内会包含一些CSS、Image、JavaScript、JSON 资源和数据。 针对不同的资源和数据，我们可以在其 URL 上，增加数据令牌指纹，当资源变动的时候，同时也去刷新改指纹令牌。 到这里就很好理解了： HTML 页面，使用 no-cache，强制每次都向源服务器确认数据。 CSS文件通常变动的频率非常低，所以可以允许中间层缓存，并且缓存时间为一年不过期。 JavaScript内有业务逻辑，可以设定为只允许客户终端缓存。 getUserInfo，是为个人用户数据相关，这里推荐可缓存，但是需要每次向服务器重新确认。 4.2 App 接口的缓存策略在 App 中使用的接口，其实和网页又不一样，HTML 网页的结构类似一个树形结构，先通过获取 .html文件获取其内所有资源的表，然后依次根据缓存策略进行访问。 但是在 App 中，和服务器的交互都是通过数据接口来实现的，就不存在最开始获取一个类似 HTML文件这样的树形接口，每个接口都是一个个“孤岛”，可以单独存在。我们就无法提前知道某个接口的响应数据已经过期，同时也无法修改 URL 上携带的数据指纹令牌。 但是其实我们是可以通过 App 和设备的一些固有信息，作为 URL 的参数传递，以此来刷新数据。 例如这里 /app/main 获取主页的数据，这里将当前 App 的版本号当参数拼接在 URL的后面，以此方式来强制不同的版本，刷新不同的数据。避免刚升级上来的 App，还在使用旧版本的数据。 这个例子中，版本号只是其中一个维度，如果有必要，还可以传递其他维度的信息，例如当前网络状态，当前用户 id 等等。 五、小结到这里我们基本上把 HTTP 的缓存所有相关的内容都讲了一遍，这里简单总结一下。 HTTP 缓存依赖 URL 做唯一标识，不同的 URL 使用不同的缓存。 Cache-Control 可以控制缓存策略，共有或者私有、缓存超时时长等。 通过 ETag 来标记数据指纹令牌，以此来确定响应数据是否更新。 应该为每个响应资源提供对应的缓存策略。 如果需要废弃之前的缓存，可以利用修改请求 URL 的方式，将数据指纹令牌追加在 URL 之后，以此来更新数据。","link":"/blog/2019/05/17/网络/图解 HTTP 的缓存机制 | 实用 HTTP/"},{"title":"图解：HTTP 范围请求，助力断点续传，多线程下载的核心原理 | 实用HTTP","text":"一、序Hi，大家好，我是承香墨影！ HTTP 协议在网络知识中占据了重要的地位，HTTP 协议最基础的就是请求和响应的报文，而报文又是由报文头（Header）和实体组成。大多数 HTTP协议的使用方式，都是依赖设置不同的 HTTP 请求/响应 的 Header 来实现的。 本系列《实用 HTTP》就抛开常规的 Header 讲解式的表述方式，从实际问题出发，来分析这些 HTTP协议的使用方式，到底是为了解决什么问题？同时讲解它是如何设计的和它实现原理。 HTTP协议是一种无状态的“松散协议”，它不会记录不同请求的状态，并且因为它本身包含了两端（客户端和服务端），根据请求和响应来区分，它大部分的内容都只是一个建议，其实双边是可以不遵守此建议的。 “这里写了建议零售价 2 元…” “哦，不接受建议！” 文本是本系列的第五篇，前四篇传送门： HTTP 的缓存机制 HTTP 内容实体编码压缩机制 HTTP 传输编码压缩机制 HTTP 的 Cookie 细节 今天再来介绍一下 HTTP 的范围请求。范围请求主要是针对较大的文件的请求或者上传，可以仅操作它的某一段。 一个比较常见的场景，就是断点续传/下载，在网络情况不好的时候，可以在断开连接以后，仅继续获取部分内容。例如在网上下载软件，已经下载了 95%了，此时网络断了，如果不支持范围请求，那就只有被迫重头开始下载。但是如果有范围请求的加持，就只需要下载最后 5% 的资源，避免重新下载。 另一个场景就是多线程下载，对大型文件，开启多个线程，每个线程下载其中的某一段，最后下载完成之后，在本地拼接成一个完整的文件，可以更有效的利用资源。 这算是两个比较常见的场景，接下来我们来看看范围请求的 HTTP 协议支持的技术细节。 二、HTTP 的范围请求2.1 是否支持范围请求HTTP 本身是一种无状态的“松散”协议，而在经历了很多版本的迭代之后，只在 HTTP/1.1（RFC2616）之上，才支持范围请求。所以如果客户端或者服务端两端的某一端低于 HTTP/1.1，我们就不应该使用范围请求的功能。 而在 HTTP/1.1 中，很明确的声明了一个响应头部 Access-Ranges 来标记是否支持范围请求，它只有一个可选参数 bytes。 例如这里给了一个 MP4 的响应头，可以看到它是有 Accept-Ranges:bytes 来标记的，有此标记标识当前资源支持范围请求。 2.2 使用范围请求如果已经确定双端都支持范围请求，我们就可以在请求资源的时候使用它。 所有的文件最终都是存储在磁盘或者内存中的字节，对于待操作的文件可以将其以字节为单位分割。这样只需要 HTTP 支持请求该文件从 n 到 n+x这个范围内的资源，就可以实现范围请求了。 HTTP/1.1 中定义了一个 Ranges 的请求头，来指定请求实体的范围。它的范围取值是在 0 - Content-Length 之间，使用 -分割。。 例如已经下载了 1000 bytes 的资源内容，想接着继续下载之后的资源内容，只要在 HTTP 请求头部，增加 Ranges:bytes=1000-就可以了。 Range 还有几种不同的方式来限定范围，可以根据需要灵活定制： 500-1000：指定开始和结束的范围，一般用于多线程下载。 500- ：指定开始区间，一直传递到结束。这个就比较适用于断点续传、或者在线播放等等。 -500：无开始区间，只意思是需要最后 500 bytes 的内容实体。 100-300,1000-3000：指定多个范围，这种方式使用的场景很少，了解一下就好了。 HTTP 协议是一种双边协商的协议，既然请求头部已经确定是使用 Ranges 了，还有响应头部中，也需要使用 Content-Ragne这个响应头来标记响应的实体内容范围。 Content-Range 的格式也很清晰，首先标记它的单位是 bytes 然后标记当前传递的内容实体范围和总长度。 Content-Range: bytes 100-999/1000 在这个例子中，会传递 100 ~ 999 范围的内容实体，而该资源文件的总大小是 1000 bytes。并且此时的 HTTP 响应状态码为 206Partial Content 。 HTTP 206 Partial Content 成功状态响应代码表示请求已成功，并且主体包含所请求的数据区间，该数据区间是在请求的 Range首部指定的。 有关 206 状态码的解释可以参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206 所以一个正常的流程应该如下图所示： 注意这里的每个 HTTP 事务中的响应头里，都是会包含 Content-Length的，只是它包含的是当前范围请求响应的内容实体长度，而非此资源完整的长度。 到这里基本上算是讲清楚 HTTP 范围请求的正确流程了，接下来看看一些特殊的情况。 2.3 资源变化当我们在一些下载工具中，下载大尺寸资源的时候，偶尔中间暂停过再重新下载，可能会遇见它又重头开始下载的情况。 这看似是 HTTP 的范围请求失效了，但是实际上并不一定如此，很可能是因为请求的资源，在请求的这个过程中，发生了改变。 假如你下载的过程中，下载的源资源文件发生了变化，但是 URL没有改变，此时文件长度可能已经变化了（这是非常容易发现的），极端情况下就算没有长度没有变化，你再继续下载，很可能最终下载完成之后，无法将下载的内容拼接成我们需要的文件。 如果我们需要从服务器上下载某个资源，一定要预防此资源可能发生的变动。在之前讲 HTTP缓存的时候讲到，在HTTP 协议中，可以通过 ETag 或者 Last-Modified 来标识当前资源是否变化。 ETag：当前文件的一个验证令牌指纹，用于标识文件的唯一性。 Last-Modified：标记当前文件最后被修改的时间。 在 HTTP 的范围请求中，也可以使用这两个字段来区分分段请求的资源，是否有修改过，只需要在请求头中，将它放在 If-Range 这个请求报文头中即可。If-Range 使用 ETag 或者 Last-Modified 两个参数任意一个，原样填入即可。 此时，如果两次操作的都是同一个资源文件，就会继续返回 206 状态码，开始后续的操作，反之则会返回 200 状态码，表示文件发生改变，要从头下载。 需要注意的是 If-Range 需要和 Range 配合起来使用，否则会被服务端忽略。 再额外提一点，如果客户端请求报文头中，对 Range 填入的范围错误，会返回 416 状态码。 HTTP 416 Range Not Satisfiable错误状态码意味着服务器无法处理所请求的数据区间。最常见的情况是所请求的数据区间不在文件范围之内，也就是说，Range首部的值，虽然从语法上来说是没问题的，但是从语义上来说却没有意义。 有关 416 状态码，可以参考：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/416 三、范围请求的例子3.1 用 Chrome 播放一个适配前面介绍的概念，很多技术点其实描述的都是某一个请求片段，接下来我们以一个实际的例子来说明范围请求的具体细节。 在这个例子中，我找了一个视频的播放地址，直接在 Chrome 中进行播放。正常播放之后，再随手拖动视频进度，之后无操作让其自动播放一段时间，来看看 HTTP的事务报文。 简单描述一下情况，自然播放的时候，会首先想资源的 URL 发送请求，返回 200 的响应码，可以判断出当前资源支持 Accept-Ranges，接下来会去使用 Range 发送范围请求，得到的响应码就是206，并返回对应范围的实体内容。而在每次拖动进度的时候，都会去重新发送一个范围请求，依照拖动的进度来计算请求范围。此处不存在资源被修改的情况，所以不会出现重新请求下载的情况。 就不一个一个对 HTTP 事务截图了，大概抽象了一下流程，如下图所示： 可以看到，一次资源下载其实包含了很多次的请求过程，我们需要站在全局的角度来看到它。 四、范围请求小结到这里我们就已经把 HTTP 范围请求的整个流程都说明清楚了。 再重新整理一下关键点： HTTP 范围请求，需要 HTTP/1.1 及之上支持，如果双端某一段低于此版本，则认为不支持。 通过响应头中的 Accept-Ranges 来确定是否支持范围请求。 通过在请求头中添加 Range 这个请求头，来指定请求的内容实体的字节范围。 在响应头中，通过 Content-Range 来标识当前返回的内容实体范围，并使用 Content-Length 来标识当前返回的内容实体范围长度。 在请求过程中，可以通过 If-Range 来区分资源文件是否变动，它的值来自 ETag 或者 Last-Modifled。如果资源文件有改动，会重新走下载流程。 再配一张流程图，就更清晰了。 到此 HTTP 范围请求的所有关键技术点，就已经讲解清楚。范围请求被用在诸如：断点续传、多线程下载等场景下，大部分 CDN上的资源都是支持范围请求的，具体你能在什么场景下应用，就看你的想象力了。","link":"/blog/2019/05/17/网络/图解：HTTP 范围请求，助力断点续传，多线程下载的核心原理 | 实用HTTP/"},{"title":"移动端网络优化","text":"一个网络请求可以简单分为连接服务器 -&gt; 获取数据两个部分。其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。 一、连接服务器优化策略1. 不用域名，用 IP 直连省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的 IP 地址。 如http://www.codekk.com 的域名解析结果就是 104.236.147.76。 首次域名解析一般需要几百毫秒，可通过直接向 IP 而非域名请求，节省掉这部分时间，同时可以预防域名劫持等带来的风险。 当然为了安全和扩展考虑，这个 IP 可能是一个动态更新的 IP 列表，并在 IP 不可用情况下通过域名访问。 2. 服务器合理部署服务器多运营商多地部署，一般至少含三大运营商、南中北三地部署。 配合上面说到的动态 IP 列表，支持优先级，每次根据地域、网络类型等选择最优的服务器 IP 进行连接。 对于服务器端还可以调优服务器的 TCP 拥塞窗口大小、重传超时时间(RTO)、最大传输单元(MTU)等。 二、获取数据优化策略1. 连接复用节省连接建立时间，如开启 keep-alive。 Http 1.1 默认启动了 keep-alive。对于 Android 来说默认情况下 HttpURLConnection 和 HttpClient都开启了 keep-alive。只是 2.2 之前 HttpURLConnection 存在影响连接池的 Bug，具体可见：[AndroidHttpURLConnection 及 HttpClient 选择](http://www.trinea.cn/android/android-http-api-compare/) 2. 请求合并即将多个请求合并为一个进行请求，比较常见的就是网页中的 CSS Image Sprites。 如果某个页面内请求过多，也可以考虑做一定的请求合并。 3. 减小请求数据大小(1) 对于 POST 请求，Body 可以做 Gzip 压缩，如日志。 (2) 对请求头进行压缩这个 Http 1.1 不支持，SPDY 及 Http 2.0 支持。 Http 1.1 可以通过服务端对前一个请求的请求头进行缓存，后面相同请求头用md5 之类的 id 来表示即可。 4. CDN 缓存静态资源缓存常见的图片、JS、CSS 等静态资源。 5. 减小返回数据大小(1) 压缩一般 API 数据使用 Gzip 压缩，下图是之前测试的 Gzip 压缩前后对比图。 (2) 精简数据格式如 JSON 代替 XML，WebP 代替其他图片格式。关注公众号 codekk，回复 20 查看关于 WebP 的介绍。 (3) 对于不同的设备不同网络返回不同的内容 如不同分辨率图片大小。 (4) 增量更新需要数据更新时，可考虑增量更新。如常见的服务端进行 bsdiff，客户端进行 bspatch。 (5) 大文件下载支持断点续传，并缓存 Http Resonse 的 ETag 标识，下次请求时带上，从而确定是否数据改变过，未改变则直接返回 304。 6. 数据缓存缓存获取到的数据，在一定的有效时间内再次请求可以直接从缓存读取数据。 关于 Http 缓存规则 Grumoon 在 Volley源码解析最后杂谈中有详细介绍。 三、其他优化手段这类优化方式在性能优化系列总篇中已经有过完整介绍1. 预取包括预连接、预取数据。 2. 分优先级、延迟部分请求将不重要的请求延迟，这样既可以削峰减少并发、又可以和后面类似的请求做合并。 3. 多连接对于较大文件，如大图片、文件下载可考虑多连接。 需要控制请求的最大并发量，毕竟移动端网络受限。 四、监控优化需要通过数据对比才能看出效果，所以监控系统必不可少，通过前后端的数据监控确定调优效果。","link":"/blog/2019/05/17/网络/移动端网络优化/"},{"title":"详解 Cookie 纪要","text":"# 从事 Web开发已有近17个月；在学以致用的工作学习里，对于不怎么使用的部分，多少有些雾里探花的窘迫感～差不多是了解一二，然而又非真切的明晰；这就使得再用的时候，总要去再搜索一番；如此颇为难受，倒不如总结纪录下来，一方面加深认知，也易便于查阅；对于某相关技术，不断学习、运用、总结、更新，积淀过后也能对别人给予帮助。写博，真是一件值得去做的事。 背景 在HTTP协议的定义中，采用了一种机制来记录客户端和服务器端交互的信息，这种机制被称为cookie，cookie规范定义了服务器和客户端交互信息的格式、生存期、使用范围、安全性。 在JavaScript中可以通过 document.cookie 来读取或设置这些信息。由于 cookie多用在客户端和服务端之间进行通信，所以除了JavaScript以外，服务端的语言（如PHP）也可以存取 cookie。 Cookie详解 Cookie在远程浏览器端存储数据并以此跟踪和识别用户的机制。从实现上说，Cookie是存储在客户端上的一小段数据，浏览器（即客户端）通过HTTP协议和服务器端进行Cookie交互。 Cooke独立于语言存在，严格地说，Cookie并不是由PHP、Java等语言实现的，而是由这些语言对Cookie进行间接操作，即发送HTTP指令，浏览器收到指令便操作Cookie并返回给服务器。因此，Cookie是由浏览器实现和管理的。举例说，PHP并没有真正设置过Cookie，只是发出指令让浏览器来做这件事。PHP中可以使用setcookie()或 setrawcookie()函数设置Cookie。setcookie()最后一个参数HttpOnly设置了后，JavaScript就无法读取到这个Cookie。 设置Cookie时需注意：①函数有返回值，false失败，true成功，成功仅供参考，不代表客户端一定能接收到；②PHP设置的Cookie不能立即生效，要等下一个页面才能看到（Cookie从服务器传给浏览器，下个页面浏览器才能把设置的Cookie传回给服务器）；如果是JavaScript设置的，是立即生效的；③Cookie没有显示的删除函数，可以设置expire过期时间，自动触发浏览器的删除机制。 Cookie是HTTP头的一部分，即现发送或请求Cookie，才是data域；setcookie()等函数必须在数据之前调用，这和header()函数是相同的。不过也可以使用输出缓冲函数延迟脚本的输出，知道设置好所有Cookie和其他HTTP标头。 Cookie通常用来存储一些不是很敏感的信息，或者进行登录控制，也可用来记住用户名、记住免密码登录、防止刷票等。每个域名下允许的Cookie是有限制的，根据浏览器这个限制也不同。Cookie不是越多越好，它会增加宽带，增加流量消耗，所以不要滥用Cookie；不要把Cookie当作客户端的存储器来用。一个域名的每个Cookie限制以4千字节（KB）键值对的形式存储。 还有一种Cookie是Flash创建的，成为Flash Shard Object，又称FlashCookie，即使清空浏览器所有隐私数据，这类顽固的Cookie还会存在硬盘上，因为它只受Flash管理，很多网站采用这种技术识别用户。 Cookie跨域，主要是为了统一应用平台，实现单点登录；需使用P3P协议（Platform for PrivacyPreferences），通过P3P使用户自己可以指定浏览器的隐私策略，达到存储第三方Cookie的目的，只需要在响应用户请求时，在HTTP的头信息中增加关于P3P的配置信息就可以了。Cookie跨域涉及两个不同的应用，习惯上称为第一方和第三方。第三方通常是来自别人的广告、或Iframe别的网站的URL，这些第三方网站可能使用的Cookie。 Cookie格式 Cookie中保存的信息都是文本信息，在客户端和服务器端交互过程中，cookie信息被附加在HTTP消息头中传递，cookie的信息由键/值对组成。下面是一个HTTP头中cookie的例子： Set-Cookie: key = value; Path=/ Cookie中存放的信息包含cookie本身属性和用户自定义属性，一个cookie只能包含一个自定义键/值对。Cookie本身属性有”Comment”、”Domain”、”Max-Age”、”Path”、”Secure”、”Version”。 Comment 属性是cookie的产生着对该cookie的描述； Domain 属性定义可访问该cookie的域名，对一些大的网站，如果希望cookie可以在子网站中共享，可以使用该属性。例如设置Domain为.bigsite.com,则sub1.bigsite.com和sub2.bigsite.com都可以访问已保存在客户端的cookie，这时还需要将Path设置为/。 Max-Age 属性定义cookie的有效时间，用秒计数，当超过有效期后，cookie的信息不会从客户端附加在HTTP消息头中发送到服务端。 Path属性定义网站上可以访问cookie的页面的路径，缺省状态下Path为产生cookie时的路径，此时cookie可以被该路径以及其子路径下的页面访问；可以将Path设置为/，使cookie可以被网站下所有页面访问。 Secure属性值定义cookie的安全性，当该值为true时必须是HTTPS状态下cookie才从客户端附加在HTTP消息中发送到服务端，在HTTP时cookie是不发送的；Secure为false时则可在HTTP状态下传递cookie，Secure缺省为false。 Version 属性定义cookie的版本，由cookie的创建者定义。 Cookie的创建 Cookie可以在服务器端创建，然后cookie信息附加在HTTP消息头中传到客户端，如果cookie定义了有效期，则本保存在客户端本地磁盘。保存cookie的文件是一个文本文件，因此不用担心此文件中的内容会被执行而破坏客户的机器。支持Web端开发的语言都有创建cookie的方法或函数，以及设置cookie属性和添加自定义属性的方法或函数，最后是将cookie附加到返回客户端的HTTP消息头中。 创建cookie时如果不指定生存有效时间，则cookie只在浏览器关闭前有效，cookie会在服务器端和客户端传输，但是不会保存在客户机的磁盘上，打开新的浏览器将不能获得原先创建的cookie信息。 Cookie信息保存在本地时会保存到当前登录用户专门目录下，保存的cookie文件名中会包含创建cookie所在页面网站的域名，当浏览器再次连接该网站时，会从本机cookie存放目录下选出该网站的有效cookie，将保存在其中的信息附加在HTTP消息头中发送到服务器端，服务器端程序就可根据上次保存在cookie的信息为访问客户提供“记忆”或个性化服务。 Cookie除了可以在服务器端创建外，也可以在客户端的浏览器中用客户端脚本(如javascript)创建。客户端创建的cookie的性质和服务器端创建的cookie一样，可以保存在本地，也可以被传送到服务器端被服务器程序读取。 Cookie 基础知识 cookie 是有大小限制的，大多数浏览器支持最大为 4096 字节的 Cookie(具体会有所差异，可以使用这个好用的工具:http://browsercookielimits.squawky.net/ 进行测试);如果 cookie 字符串的长度超过最大限制，则该属性将返回空字符串。 由于 cookie 最终都是以文件形式存放在客户端计算机中，所以查看和修改 cookie 都是很方便的，这就是为什么常说 cookie 不能存放重要信息的原因。 每个 cookie 的格式都是这样的：cookieName = Vaue；名称和值都必须是合法的标示符。 cookie 是存在 有效期的。在默认情况下，一个 cookie 的生命周期就是在浏览器关闭的时候结束。如果想要 cookie 能在浏览器关掉之后还可以使用，就必须要为该 cookie 设置有效期，也就是 cookie 的失效日期。 alert(typeof document.cookie)结果是 string. cookie 有域和路径这个概念。域就是domain的概念，因为浏览器是个注意安全的环境，所以不同的域之间是不能互相访问 cookie 的(当然可以通过特殊设置的达到 cookie 跨域访问)。路径就是routing的概念，一个网页所创建的 cookie 只能被与这个网页在同一目录或子目录下得所有网页访问，而不能被其他目录下得网页访问（这句话有点绕，一会看个例子就好理解了）。 其实创建cookie的方式和定义变量的方式有些相似，都需要使用 cookie 名称和 cookie 值。同个网站可以创建多个 cookie ，而多个 cookie 可以存放在同一个cookie 文件中。 cookie 存在两种类型：①:你浏览的当前网站本身设置的 cookie ②来自在网页上嵌入广告或图片等其他域来源的 第三方 cookie (网站可通过使用这些 cookie 跟踪你的使用信息) cookie 有两种清除方式：①:通过浏览器工具清除 cookie (有第三方的工具，浏览器自身也有这种功能) ②通过设置 cookie 的有效期来清除 cookie.注：删除 cookie 有时可能导致某些网页无法正常运行。 浏览器可以通过设置来接受和拒绝访问 cookie。出于功能和性能的原因考虑，建议尽量降低 cookie 的使用数量，并且要尽量使用小 cookie。 Cookie的使用 从cookie的定义可以看到，cookie一般用于采用HTTP作为进行信息交换协议的客户端和服务器端用于记录需要持久化的信息。一般是由服务器端创建要记录的信息，然后传递到客户端，由客户端从HTTP消息中取出信息，保存在本机磁盘上。当客户端再次访问服务器端时，从本机磁盘上读出原来保存的信息，附加到HTTP消息中发送给服务器端，服务器端从HTTP消息中读取信息，根据实际应用的需求进行进一步的处理。 服务器端cookie的创建和再次读取功能通常由服务器端编程语言实现，客户端cookie的保存、读取一般由浏览器来提供，并且对cookie的安全性方面可以进行设置，如是否可以在本机保存cookie。 由于cookie信息以明文方式保存在文本文件中，对一些敏感信息如口令、银行帐号如果要保存在本地cookie文件中，最好采用加密形式。 与cookie类似的另一个概念是会话（Session），会话一般是记录客户端和服务器端从客户端浏览器连接上服务器端到关闭浏览器期间的持久信息。会话一般保存在内存中，不保存到磁盘上。会话可以通过cookie机制来实现，对于不支持cookie的客户端，会话可以采用URL重写方式来实现。可以将会话理解为内存中的cookie。 使用会话会对系统伸缩性造成负面影响，当服务器端要在很多台服务器上同步复制会话对象时，系统性能会受到较大伤害，尤其会话对象较大时。这种情况下可以采用cookie，将需要记录的信息保存在客户端，每次请求时发送到服务器端，服务器端不保留状态信息，避免在服务器端多台机器上复制会话而造成的性能下降。 Cookie 基本操作 对于 Cookie 得常用操作有，存取，读取，以及设置有效期；具体可以参照 JavaScript 操作 Cookie一文；但，近期在前端编码方面，皆以Vue为冲锋利器，所以就有用到一款插件 vue-cookie,其代码仅30行，堪称精妙，读取操作如下： set: function (name, value, days) { var d = new Date; d.setTime(d.getTime() + 2460601000days); window.document.cookie = name + “=” + value + “;path=/;expires=” +d.toGMTString(); }, get: function (name) { var v = window.document.cookie.match(‘(^|;) ?’ + name + ‘=([^;]*)(;|$)’);return v ? v[2] : null; }, delete: function (name) { this.set(name, ‘’, -1); } cookie 域概念 路径能解决在同一个域下访问 cookie 的问题，咱们接着说 cookie 实现同域之间访问的问题。语法如下： document.cookie = “name=value;path=path;domain=domain“ 红色的domain就是设置的 cookie 域的值。例如 “www.qq.com” 与 “sports.qq.com”公用一个关联的域名”qq.com”，我们如果想让”sports.qq.com” 下的cookie被 “www.qq.com”访问，我们就需要用到cookie 的domain属性，并且需要把path属性设置为 “/“。例： document.cookie = “username=Darren;path=/;domain=qq.com“ 注：一定的是同域之间的访问，不能把domain的值设置成非主域的域名。 cookie 安全性 通常 cookie 信息都是使用HTTP连接传递数据，这种传递方式很容易被查看，在控制台下运行document.cookie,一目了然；所以 cookie存储的信息容易被窃取。假如 cookie 中所传递的内容比较重要，那么就要求使用加密的数据传输。所以 cookie的这个属性的名称是“secure”，默认的值为空。如果一个 cookie的属性为secure，那么它与服务器之间就通过HTTPS或者其它安全协议传递数据。语法如下： document.cookie = “username=Darren;secure” 把cookie设置为secure，只保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据。 注： 就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以说到底，别把重要信息放cookie就对了。 Session详解 Session即回话，指一种持续性的、双向的连接。Session与Cookie在本质上没有区别，都是针对HTTP协议的局限性而提出的一种保持客户端和服务器间保持会话连接状态的机制。Session也是一个通用的标准，但在不同的语言中实现有所不同。针对Web网站来说，Session指用户在浏览某个网站时，从进入网站到浏览器关闭这段时间内的会话。由此可知，Session实际上是一个特定的时间概念。 使用Session可以在网站的上下文不同页面间传递变量、用户身份认证、程序状态记录等。常见的形式就是配合Cookie使用，实现保存用户登录状态功能。和Cookie一样，session_start()必须在程序最开始执行，前面不能有任何输出内容，否则会出现警告。PHP的Session默认通过文件的方式实现，即存储在服务器端的Session文件，每个Session一个文件。 Session通过一个称为PHPSESSID的Cookie和服务器联系。Session是通过sessionID判断客户端用户的，即Session文件的文件名。sessionID实际上是在客户端和服务端之间通过HTTPRequest 和 HTTP Response传来传去。sessionID按照一定的算法生成，必须包含在 HTTP Request里面，保证唯一性和随机性，以确保Session的安全。如果没有设置 Session 的生成周期，sessionID存储在内存中，关闭浏览器后该ID自动注销；重新请求该页面，会重新注册一个sessionID。如果客户端没有禁用Cookie，Cookie在启动Session回话的时候扮演的是存储sessionID和 Session 生存期的角色。Session过期后，PHP会对其进行回收。 假设客户端禁用Cookie，可以通过URL或者隐藏表单传递sessionID；php.ini中把session.use_trans_sid设成1，那么连接后就会自己加Session的ID。 Session以文件的形式存放在本地硬盘的一个目录中，当比较多时，磁盘读取文件就会比较慢，因此把Session分目录存放。 对于访问量大的站点，用默认的Session存储方式并不适合，较优的方法是用DataBase存取Session。在大流量的网站中，Session入库存在效率不高、占据数据库connection资源等问题。针对这种情况，可以使用Memcached、Redis等Key-Value数据存储方案实现高并发、大流量的Session存储。 session与cookie的区别： 1，session 在服务器端，cookie 在客户端（浏览器） 2，session 存在在服务器的一个文件里（默认），不是内存 3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果 浏览器禁用了 cookie，同时 session 也会失效（当然也可以在 url 中传递） 4，session 可以放在 文件，数据库，或内存中都可以。 5，用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id 更为详尽的说法： 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 所以，总结一下： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 Cookie与Session问答 Cookie运行在客户端，Session运行在服务端，对吗？ A：不完全正确。Cookie是运行在客户端，有客户端进行管理；Session虽然是运行在服务器端，但是sessionID作为一个Cookie是存储在客户端的。 浏览器禁止Cookie，Cookie就不能用了，但Session不会受浏览器影响，对吗？ A：错。浏览器禁止Cookie，Cookie确实不能用了，Session会受浏览器端的影响。很简单的实验，在登录一个网站后，清空浏览器的Cookie和隐私数据，单机后台的连接，就会因为丢失Cookie而退出。当然，有办法通过URL传递Session。 浏览器关闭后，Cookie和Session都消失了，对吗？ A：错。存储在内存中额Cookie确实会随着浏览器的关闭而消失，但存储在硬盘上的不会。更顽固的是Flash Cookie，不过现在很多系统优化软件和新版浏览器都已经支持删除Flash Cookie。百度采用了这样的技术记忆用户：Session在浏览器关闭后也不会消失，除非正常退出，代码中使用了显示的unset删除Session。否则Session可能被回收，也有可能永远残留在系统中。 Session 比 Cookie 更安全吗？ 不应该大量使用Cookie吗？ A：错误。Cookie确实可能存在一些不安全因素，但和JavaScript一样，即使突破前端验证，还有后端保障安全。一切都还要看设计，尤其是涉及提权的时候，特别需要注意。通常情况下，Cookie和Session是绑定的，获得Cookie就相当于获得了Session，客户端把劫持的Cookie原封不动地传给服务器，服务器收到后，原封不动地验证Session，若Session存在，就实现了Cookie和Session的绑定过程。因此，不存在Session比Cookie更安全这种说法。如果说不安全，也是由于代码不安全，错误地把用作身份验证的Cookie作为权限验证来使用。 Session是创建在服务器上的，应该少用Session而多用Cookie，对吗？ A：错。Cookie可以提高用户体验，但会加大网络之间的数据传输量，应尽量在Cookie中仅保存必要的数据。 如果把别人机器上的Cookie文件复制到我的电脑上（假设使用相同的浏览器），是不是能够登录别人的帐号呢？如何防范？ A：是的。这属于Cookie劫持的一种做法。要避免这种情况，需要在Cookie中针对IP、UA等加上特殊的校验信息，然后和服务器端进行比对。 在IE浏览器下登录某网站，换成Firefox浏览器是否仍然是未登录状态？使用IE登录了腾讯网站后，为什么使用Firefox能保持登录状态？ A：不同浏览器使用不同的Cookie管理机制，无法实现公用Cookie。如果使用IE登录腾讯网站，使用Firefox也能登录，这是由于在安装腾讯QQ软件时，你的电脑上同时安装了针对这两个浏览器的插件，可以识别本地已登录QQ号码进而自动登录。本质上，不属于共用Cookie的范畴。","link":"/blog/2019/05/17/网络/详解 Cookie 纪要/"}],"tags":[{"name":"ReactNative库","slug":"ReactNative库","link":"/blog/tags/ReactNative库/"},{"name":"ReactNative插件","slug":"ReactNative插件","link":"/blog/tags/ReactNative插件/"},{"name":"ReactNative","slug":"ReactNative","link":"/blog/tags/ReactNative/"},{"name":"ReactNative优化","slug":"ReactNative优化","link":"/blog/tags/ReactNative优化/"},{"name":"C#","slug":"C","link":"/blog/tags/C/"},{"name":"C#优化","slug":"C-优化","link":"/blog/tags/C-优化/"},{"name":"Unity","slug":"Unity","link":"/blog/tags/Unity/"},{"name":"Unity优化","slug":"Unity优化","link":"/blog/tags/Unity优化/"},{"name":"Unity插件","slug":"Unity插件","link":"/blog/tags/Unity插件/"},{"name":"VR","slug":"VR","link":"/blog/tags/VR/"},{"name":"Web","slug":"Web","link":"/blog/tags/Web/"},{"name":"AR","slug":"AR","link":"/blog/tags/AR/"},{"name":"UML","slug":"UML","link":"/blog/tags/UML/"},{"name":"图像","slug":"图像","link":"/blog/tags/图像/"},{"name":"Google","slug":"Google","link":"/blog/tags/Google/"},{"name":"网络安全","slug":"网络安全","link":"/blog/tags/网络安全/"},{"name":"开源","slug":"开源","link":"/blog/tags/开源/"},{"name":"移动支付","slug":"移动支付","link":"/blog/tags/移动支付/"},{"name":"小程序","slug":"小程序","link":"/blog/tags/小程序/"},{"name":"后端","slug":"后端","link":"/blog/tags/后端/"},{"name":"数据库","slug":"数据库","link":"/blog/tags/数据库/"},{"name":"架构","slug":"架构","link":"/blog/tags/架构/"},{"name":"网络","slug":"网络","link":"/blog/tags/网络/"}],"categories":[{"name":"ReactNative","slug":"ReactNative","link":"/blog/categories/ReactNative/"},{"name":"C#","slug":"C","link":"/blog/categories/C/"},{"name":"Unity","slug":"Unity","link":"/blog/categories/Unity/"},{"name":"Unity优化","slug":"Unity优化","link":"/blog/categories/Unity优化/"},{"name":"Unity插件","slug":"Unity插件","link":"/blog/categories/Unity插件/"},{"name":"VR","slug":"VR","link":"/blog/categories/VR/"},{"name":"Web","slug":"Web","link":"/blog/categories/Web/"},{"name":"AR","slug":"AR","link":"/blog/categories/AR/"},{"name":"其他","slug":"其他","link":"/blog/categories/其他/"},{"name":"小程序","slug":"小程序","link":"/blog/categories/小程序/"},{"name":"后端","slug":"后端","link":"/blog/categories/后端/"},{"name":"网络","slug":"网络","link":"/blog/categories/网络/"}]}